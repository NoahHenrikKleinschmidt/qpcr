<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>qpcr.Pipes.Pipes API documentation</title>
<meta name="description" content="This module contains a set of common lightweight wrappers to perform simple and non-customised DeltaDeltaCt analyses.
This is designed for lightweight …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>qpcr.Pipes.Pipes</code></h1>
</header>
<section id="section-intro">
<p>This module contains a set of common lightweight wrappers to perform simple and non-customised DeltaDeltaCt analyses.
This is designed for lightweight users that do not wish to employ specialised pipelines.</p>
<blockquote>
<h3 id="a-word-on-plotters">A Word on Plotters</h3>
<p>Please, note that pipelines fully support mixing "static" and "interactive" Plotters,
but static figures will not stay open if interactive plotters are called to plot after them!
Because <code><a title="qpcr.Filters" href="../Filters/index.html">qpcr.Filters</a></code> are always called to plot <em>before</em> any other <code><a title="qpcr.Plotters" href="../Plotters/index.html">qpcr.Plotters</a></code>, this will mainly
affect visualising the <code>qpcr.Plotters.ReplicateBoxplots</code> generated as Filter-Summaries.</p>
</blockquote>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This module contains a set of common lightweight wrappers to perform simple and non-customised DeltaDeltaCt analyses.
This is designed for lightweight users that do not wish to employ specialised pipelines.

&gt; ### A Word on Plotters 
&gt; Please, note that pipelines fully support mixing &#34;static&#34; and &#34;interactive&#34; Plotters, 
&gt; but static figures will not stay open if interactive plotters are called to plot after them! 
&gt; Because `qpcr.Filters` are always called to plot *before* any other `qpcr.Plotters`, this will mainly
&gt; affect visualising the `qpcr.Plotters.ReplicateBoxplots` generated as Filter-Summaries.
&#34;&#34;&#34;

import qpcr
import matplotlib.pyplot as plt
import pandas as pd 
import statistics as stats
import qpcr._auxiliary.warnings as aw
import qpcr._auxiliary as aux
import qpcr.Plotters as Plotters
import qpcr.Filters as Filters
import qpcr.Readers as Readers
import re
import os 
import difflib

class Pipeline:
    &#34;&#34;&#34;
    This is the basic template class for qpcr Pipelines. 
    It contains a set of basic preliminary methods
    that ensure that elementary required inputs are provided.

    Note
    ----
    The simplest implementation of this `Pipeline` template is the `Basic` pipeline.
    &#34;&#34;&#34;
    def __init__(self):
        # super().__init__()
        self._Normalisers = []
        self._Assays = []
        self._save_to = None
        self._df = None
        self._stats_df = None
        self._Results = None
        self._replicates = None
        self._names = None
        self._softlink = True

    def assays(self):
        &#34;&#34;&#34;
        Returns
        -------
        assays : list
            The linked `qpcr.Assay` objects for assays-of-interest.
        &#34;&#34;&#34;
        assays = self._Assays
        return assays
    
    def normalisers(self):
        &#34;&#34;&#34;
        Returns
        -------
        normalisers : list
            The linked `qpcr.Assay` objects for normaliser-assays.
        &#34;&#34;&#34;
        normalisers = self._Normalisers
        return normalisers

    def replicates(self, replicates:(int or tuple)):
        &#34;&#34;&#34;
        Set the replicates specifics to use for grouping.

        Parameters
        ----------
        replicates : int or tuple
            Can be an `integer` (equal group sizes, e.g. `3` for triplicates), 
            or a `tuple` (uneven group sizes, e.g. `(3,2,3)` if the second group is only a duplicate). 
        &#34;&#34;&#34;
        self._replicates = replicates

    def names(self, names:(list or dict)):
        &#34;&#34;&#34;
        Set names for replicates groups.

        Parameters
        ----------
        names : list or dict
            Either a `list` (new names without repetitions) or `dict` (key = old name, value = new name) specifying new group names. 
            Group names only need to be specified once, and are applied to all replicate entries.
        &#34;&#34;&#34;
        self._names = names


    def run(self, **kwargs):
        &#34;&#34;&#34;
        Will run the pipeline provided that at least minimal inputs have been provided (i.e. Assays and Normalisers, as well as replicate specifics have been provided).
        This is a wrapper, the actual functional core is defined in the method `self._run()`. 
        To implement your own pipeline, make sure to define your own `_run()`, redefine `run()`
        as you require.

        Parameters
        ----------
        **kwargs
            Any additional keyword arguments that will be passed to the actual `_run()` method.
        &#34;&#34;&#34;

        # vet if there are at least one normaliser and assay present
        if self._Normalisers == [] or self._Assays == []:
            aw.HardWarning(&#34;Pipeline:no_data&#34;)

        self._run(**kwargs)
    
    def save_to(self, directory:str):
        &#34;&#34;&#34;
        Set the location where to save result files

        Parameters
        ----------
        directory : str
            A directory to save the results to.
        &#34;&#34;&#34;
        self._save_to = directory
        # if the directory does not yet exist, we make it
        if not os.path.exists(self._save_to):
            os.mkdir(self._save_to)

    def get(self, kind=&#34;stats&#34;):
        &#34;&#34;&#34;
        Returns
        -------
        data 
            A pandas dataframe either in replicate version `kind=&#34;df&#34;`
            or in stats version `kind=&#34;stats&#34;` (default). Alternatively,
            a qpcr.Results object can be returned using `kind=&#34;obj&#34;`.
        &#34;&#34;&#34;
        if kind == &#34;stats&#34;:
            return self._stats_df
        elif kind == &#34;df&#34;:
            df = self._df
            if &#34;assay&#34; in df.columns: 
                df = df.drop(columns = [&#34;assay&#34;])
            return df
        elif kind == &#34;obj&#34;:
            return self._Results
    
    def link(self, assays:(list or str) = None, normalisers:(list or str) = None):
        &#34;&#34;&#34;
        Links new assays-of-interest / sample assays and/or normaliser assays 
        to the pipline, either replacing old ones or keeping them, 
        depending on `softlink()` settings.

        Parameters
        ----------
        assays : list or str
            A `list` of filepaths to raw datafiles of assays-of-interest, or a directory (`str`) where these are stored.
        normalisers : list or str
            A `list` of filepaths to raw datafiles of normaliser assays, or a directory (`str`) where these are stored.
        &#34;&#34;&#34;
        if self._softlink:
            self.prune()
        self.add_assays(assays)
        self.add_normalisers(normalisers)


    def prune(self, assays = True, results = True, normalisers = True):
        &#34;&#34;&#34;
        Will clear assays, results, and/or normalisers

        Parameters
        ----------
        assays : bool
            Will clear any sample assays in the pipeline if True (default).
        
        results : bool
            Will clear any computed results in the pipline if True (default).
        
        normalisers : bool
            Will clear any normalisers in the pipline if True (default).
        &#34;&#34;&#34;
        if assays: self._Assays = []
        if normalisers: self._Normalisers = []
        if results: 
            self._df = None
            self._stats_df = None
            self._Results = None

    def add_normalisers(self, normalisers):
        &#34;&#34;&#34;
        Adds normalisers (filepaths) (keeping any already present)
        
        Parameters
        ----------
        normalisers : list or str
            A `list` of filepaths to raw datafiles of normaliser assays, or a directory (`str`) where these are stored.
        &#34;&#34;&#34;
        normalisers = self._from_directory(normalisers)
        self._Normalisers.extend(normalisers)
    
    def add_assays(self, assays):
        &#34;&#34;&#34;
        Adds assays-of-interest / sample assays (filepaths) (keeping any already present)

        Parameters
        ----------
        assays : list or str
            A `list` of filepaths to raw datafiles of sample assays, or a directory (`str`) where these are stored.
        &#34;&#34;&#34;
        assays = self._from_directory(assays)
        self._Assays.extend(assays)

    def softlink(self, bool = None):
        &#34;&#34;&#34;
        If `softlink = True`, then `link_assays()` will 
        prune any previous assays. Otherwise, it will 
        add new ones and keep old ones.

        Parameters
        ----------
        bool
            Set to False to disable `softlinking` (default is True).
        &#34;&#34;&#34;
        if bool is None:
            return self._softlink
        else:
            self._softlink = bool

    def _from_directory(self, files):
        &#34;&#34;&#34;
        Checks if a directory was provided for assays / normalisers and returns a list of all contained files if so.
        Otherwise it just returns the list of files.
        This is used for add_assays and add_normalisers
        &#34;&#34;&#34;
        if isinstance(files, str):

            # if inputs are a directory
            if os.path.isdir(files):
            
                # get files from the directory
                datafiles = os.listdir(files)
            
                # if no files are found, raise error
                if len(datafiles) == 0:
                    aw.HardWarning(&#34;Pipeline:no_data_input&#34;, file = files, traceback = False)
            
                # combine paths with parent directory
                datafiles = [os.path.join(files,n) for n in datafiles]
                return datafiles

            # else check if inputs are a single file
            # then just put it into a list to be valid input for .extend()
            elif os.path.isfile(files):
                
                return [files]

            else: 
                aw.HardWarning(&#34;Pipeline:no_data_input&#34;, file = files, traceback = False)
        
        # else check if we got a list or tuple of files
        elif isinstance(files, (list or tuple)):
            return files
        
        # raise error for anything else...
        else: 
            aw.HardWarning(&#34;Pipeline:no_data_input&#34;, file = files, traceback = False)


    def _run(self, **kwargs):
        &#34;&#34;&#34;
        This is the actual function that each custom Pipeline has to define...
        &#34;&#34;&#34;
        print(&#34;self._run() is the actual function that each custom Pipeline has to define...&#34;)


class Basic(Pipeline):
    &#34;&#34;&#34;
    Performs simple standardized DeltaDeltaCt analysis 
    based on two lists of files, one for normaliser assays and one for sample assays.
    This makes use of standard settings for `qpcr.Analyser` and `qpcr.Normaliser`
    which cannot be customized! 
    For customization check out the `Blueprint` pipeline or generate your own.
    &#34;&#34;&#34;
    def __init__(self):
        super().__init__()
    
    def _run(self, **kwargs):
        &#34;&#34;&#34;
        The automated standard DeltaDeltaCt pipeline. 
        Using default settings of `qpcr.Analyser` and `qpcr.Normaliser`
        &#34;&#34;&#34;
        reader = qpcr.DataReader()
        analyser = qpcr.Analyser()
        normaliser = qpcr.Normaliser()

        # add replicate and names info to kwargs
        kwargs = dict(kwargs, replicates = self._replicates, names = self._names)

        # analyse normalisers
        normalisers = [  reader.read(i, **kwargs) for i in self._Normalisers  ]     
        normalisers = [  analyser.pipe(i) for i in normalisers  ]
       
        # analyse sample assays
        assays = [  reader.read(i, **kwargs) for i in self._Assays  ]   
        assays = [  analyser.pipe(i) for i in assays  ]

        # now normalise
        normaliser.link( assays = assays, normalisers = normalisers )
        normaliser.normalise()

        # get and store results
        results = normaliser.get()
        self._Results = results
        self._df = results.get()
        self._stats_df = results.stats()

        if self._save_to is not None:
            results.save(self._save_to)

class BasicPlus(Basic):
    &#34;&#34;&#34;
    The same as the Basic Pipeline, but has the option to integrate Plotters and Filters.
    &#34;&#34;&#34;
    def __init__(self):
        super().__init__()
        self._Plotters = []
        self._Figures = []
        self._Filters = []
    
    def prune(self, assays = True, results = True, normalisers = True, figures = True, plotters = False, filters = False):
        &#34;&#34;&#34;
        Will clear the pipeline.

        Parameters
        ----------
        assays : bool
            Will clear any sample assays in the pipeline if True (default).
        
        results : bool
            Will clear any computed results in the pipline if True (default).
        
        normalisers : bool
            Will clear any normalisers in the pipline if True (default).
        figures : bool
            Will clear any figures in the pipline if True (default).
        plotters : bool
            Will clear any Plotters from the pipeline if True (default False).
        filters : bool
            Will clear any Filters in the pipline if True (default False).
        &#34;&#34;&#34;
        super().prune(assays = assays, results = results, normalisers = normalisers)
        if figures: 
            self._Figures = []
        if filters:
            self._Filters = []
        if plotters: 
            self._Plotters = []

    def add_plotters(self, *Plotters:object):
        &#34;&#34;&#34;
        Adds already specified qpcr.Plotter objects to the Pipeline.
        
        Parameters
        ----------
        *Plotters
            Any number of qpcr.Plotters.Plotter objects.
        &#34;&#34;&#34;
        self._Plotters.extend(Plotters)
    
    def add_filters(self, *Filters:object):
        &#34;&#34;&#34;
        Adds already specified qpcr.Filter instances to the Pipeline.
        
        Parameters
        ----------
        *Filters
            Any number of `qpcr.Filters.Filter` objects.
        &#34;&#34;&#34;
        self._Filters.extend(Filters)

    def Figures(self):
        &#34;&#34;&#34;
        Returns
        -------
        list
            A list of all Figures generated by the pipeline&#39;s Plotters.
        &#34;&#34;&#34;
        return self._Figures

    def _run(self, **kwargs):
        &#34;&#34;&#34;
        The automated standard DeltaDeltaCt pipeline. 
        Also produces applies and Plotters to produce figures...
        &#34;&#34;&#34;

        # simply set up the Blueprint pipeline 
        # and run with default settings
        pipeline = Blueprint()

        pipeline.replicates(self._replicates)
        pipeline.names(self._names)

        if self._save_to is not None:
            pipeline.save_to(self._save_to)

        pipeline.add_assays(self._Assays)
        pipeline.add_normalisers(self._Normalisers)

        pipeline.add_plotters(*self._Plotters)
        pipeline.add_filters(*self._Filters)

        pipeline.run()

        # and store the results
        self._Results = pipeline.get(kind = &#34;obj&#34;)
        self._df = pipeline.get(kind = &#34;df&#34;)
        self._stats_df = pipeline.get(kind = &#34;stats&#34;)




class Blueprint(BasicPlus):
    &#34;&#34;&#34;
    Performs simple Delta-Delta-Ct analysis based on the same workflow as the `BasicPlus` pipeline, but allows full costumization of SampleReader, Analyser, and Normaliser objects.
    Optionally, `qpcr.SampleReader`, `qpcr.Analyser`, and `qpcr.Normaliser` may be set up externally and linked into the pipeline. Any non-linked processing classes will be set up using defaults.
    &#34;&#34;&#34;
    def __init__(self):
        super().__init__()
        self._Reader = None
        self._Analyser = None
        self._Normaliser = None

    def prune(self, assays = True, results = True, normalisers = True, figures = True, plotters = False, filters = False, cores = False, reader = False, analyser = False, normaliser = False):
        &#34;&#34;&#34;
        Will clear the pipeline.

        Parameters
        ----------
        assays : bool
            Will clear any sample assays in the pipeline if True (default).
        
        results : bool
            Will clear any computed results in the pipline if True (default).
        
        normalisers : bool
            Will clear any normalisers in the pipline if True (default).
        figures : bool
            Will clear any figures in the pipline if True (default).
        plotters : bool
            Will clear any Plotters from the pipeline if True (default False).
        filters : bool
            Will clear any Filters in the pipline if True (default False).
        cores : bool
            Will clear Reader, Analyser, and Normaliser if True (default False).
        reader : bool
            Will only clear the Reader if True (default False).
        analyser : bool
            Will only clear the Analyser if True (default False).
        normaliser : bool
            Will only clear the Normaliser if True (default False).
            Note, that clearing `results` will also clear the `Normaliser`&#39;s results,
            but keep the Normaliser itself!
        &#34;&#34;&#34;
        super().prune(
                        assays = assays, 
                        results = results, 
                        normalisers = normalisers,
                        figures = figures, 
                        plotters = plotters, 
                        filters = filters
                    )
        
        self._Normaliser.prune(
                                assays = assays, 
                                normalisers = normalisers, 
                                results = results
                            )
        if cores: 
            self._Reader = None
            self._Analyser = None
            self._Normaliser = None
        else:
            if reader:
                self._Reader = None
            if analyser:
                self._Analyser = None
            if normaliser:
                self._Normaliser = None

    def Reader(self, Reader : qpcr.SampleReader = None):
        &#34;&#34;&#34;
        Links a `qpcr.SampleReader` object to the pipeline.

        Parameters
        ----------
        Reader : qpcr.SampleReader
            A `qpcr.SampleReader` object
        &#34;&#34;&#34;
        if Reader is not None: 
            self._Reader = Reader
        return self._Reader

    def Analyser(self, Analyser : qpcr.Analyser = None):
        &#34;&#34;&#34;
        Links a `qpcr.Analyser` object to the pipeline.

        Parameters
        ----------
        Analyser : qpcr.Analyser
            A `qpcr.Analyser` object
        &#34;&#34;&#34;
        if Analyser is not None:
            self._Analyser = Analyser
        return self._Analyser

    def Normaliser(self, Normaliser : qpcr.Normaliser = None):
        &#34;&#34;&#34;
        Links a `qpcr.Normaliser` object to the pipeline.

        Parameters
        ----------
        Normaliser : qpcr.Normaliser
            A `qpcr.Normaliser` object
        &#34;&#34;&#34;
        if Normaliser is not None:
            self._Normaliser = Normaliser
        return self._Normaliser
    
    def _setup_cores(self):
        &#34;&#34;&#34;
        Sets SampleReader, Analyser, and Normaliser to defaults, if no external ones were provided...
        &#34;&#34;&#34;
        if self.Reader() is None: 
            self.Reader(qpcr.DataReader())
        if self.Analyser() is None: 
            self.Analyser(qpcr.Analyser())
        if self.Normaliser() is None:
            self.Normaliser(qpcr.Normaliser())

    def _run(self, **kwargs):
        &#34;&#34;&#34;
        The automated standard DeltaDeltaCt pipeline. 
        Also produces applies and Plotters to produce figures...
        &#34;&#34;&#34;
        # setup Analyser, and Normaliser (if none were provided)
        self._setup_cores()
        
        reader = self.Reader()
        analyser = self.Analyser()
        normaliser = self.Normaliser()

        # check if we have plotters or filters
        have_plotters = len(self._Plotters) != 0 
        have_filters = len(self._Filters) != 0

        # add replicate and names info to kwargs
        kwargs = dict(kwargs, replicates = self._replicates, names = self._names)

        # analyse normalisers
        normalisers = [  reader.read(i, **kwargs) for i in self._Normalisers  ]

        if have_filters:
            for filter in self._Filters:
                normalisers = [  filter.pipe(i) for i in normalisers  ]
            
        normalisers = [  analyser.pipe(i) for i in normalisers  ]
       
        # analyse sample assays
        assays = [  reader.read(i, **kwargs) for i in self._Assays  ]

        if have_filters:
            for filter in self._Filters:
                assays = [  filter.pipe(i) for i in assays  ]
        
        assays = [  analyser.pipe(i) for i in assays  ]

        # now normalise
        normaliser.link( assays = assays, normalisers = normalisers )
        normaliser.normalise()

        # get and store results
        results = normaliser.get()
        self._Results = results
        self._df = results.get()
        self._stats_df = results.stats()

        if self._save_to is not None:
            results.save(self._save_to)

        # plot filtering report
        if have_filters:
            for filter in self._Filters:
                if self._save_to is not None or filter.report() is not None:
                    
                    # add report location if none was specified...
                    if filter.report() is None: 
                        filter.report(self._save_to)

                # save filter summary fig
                figs = filter.plot()
                self._Figures.extend(figs)

        # plot results
        if have_plotters:
            for plotter in self._Plotters:

                # generate plotter fig and save
                plotter.link(self._Results)
                fig = plotter.plot()
                self._Figures.append(fig)

                if self._save_to is not None:
                    filename = self._make_figure_filename(plotter)
                    plotter.save(filename)

    def _make_figure_filename(self, plotter):
        &#34;&#34;&#34;
        Increments a filename with a numeric counter...
        &#34;&#34;&#34;
        num = 1
        suffix = plotter.suffix()
        while True:
            filename = os.path.join(self._save_to, f&#34;{plotter.id()}_{num}.{suffix}&#34;)
            if not os.path.exists(filename):
                break
            num+=1
        return filename


class _Qupid_Blueprint(Blueprint):
    &#34;&#34;&#34;
    This is the implementation of the Plueprint pipeline for the Qupid webapp.
    It redefines the file-reading functions with methods compatible with the UploadedFile objects from streamlit.
    &#34;&#34;&#34;
    def __init__(self):
        super().__init__()

    def _setup_cores(self):
        &#34;&#34;&#34;
        Sets SampleReader, Analyser, and Normaliser to defaults, if no external ones were provided...
        &#34;&#34;&#34;
        if self.Reader() is None: 
            self.Reader(qpcr._Qupid_SampleReader())
        if self.Analyser() is None: 
            self.Analyser(qpcr.Analyser())
        if self.Normaliser() is None:
            self.Normaliser(qpcr.Normaliser())


# We push this one behind in the release...
# Since we now have the ddCt pipeline we should be able to slim down most of the pipelines here anyway...

# class MultiAssay(Blueprint):
#     &#34;&#34;&#34;
#     Performs Delta-Delta-Ct based on data from a single multi-assay datafile.
#     Datasets within this datafile must be decorated to identify them as assays-of-interest or normalisers.
#     Check out the documentation of `qpcr.Parsers` for more information on decorators.

#     Note
#     -------
#     This class relies on `qpcr.Parsers` and decorated assays to get its input data. 
#     If your file does not offer this kind of architecture, choose another pipeline.

#     &#34;&#34;&#34;
#     def __init__(self):
#         super().__init__()
#         self._src = None
    
#     def link(self, filename : str, **kwargs):
#         &#34;&#34;&#34;
#         Reads a datafile in csv or excel format containing 
#         multiple decorated datasets and extracts sample and normalisers assays. 

#         Parameters
#         ----------
#         filename : str
#             A filepath to a raw data file.
#         **kwargs
#             Any additional keyword arguments that shall be passed to the `qpcr.MultiReader`&#39;s `pipe` method.
#         &#34;&#34;&#34;
#         self._src = filename

#         # setup Reader, Analyser, and Normaliser (if none were provided)
#         self._setup_cores(**kwargs)
#         reader = self.Reader()

#         # read the multi-assay datafile
#         self._Assays, self._Normalisers = reader.pipe(self._src, **kwargs)
        
        
#     def _run(self, **kwargs):
#         &#34;&#34;&#34;
#         The main workflow
#         &#34;&#34;&#34;
#         # setup Reader, Analyser, and Normaliser (if none were provided)
#         self._setup_cores()
        
#         analyser = self.Analyser()
#         normaliser = self.Normaliser()

#         normalisers = []
#         samples = []

#         # analyse normalisers:
#         for norm in self._Normalisers:
#             for filter in self._Filters:
#                 norm = filter.pipe(norm)
#             norm = analyser.pipe(norm)
#             normalisers.append(norm)
#         normaliser.link(normalisers = normalisers)

#         # analyse sample assays
#         for sample in self._Assays:
#             for filter in self._Filters:
#                 sample = filter.pipe(sample)
#             sample = analyser.pipe(sample)
#             samples.append(sample)
#         normaliser.link(assays = samples)

#         normaliser.normalise()
#         results = normaliser.get()

#         self._Results = results
#         self._df = results.get()
#         self._stats_df = results.stats()

#         if self._save_to is not None:
#             results.save(self._save_to)

#         # plot filtering report
#         for filter in self._Filters:
#             if self._save_to is not None or filter.report() is not None:
#                 # add report location if none was specified...
#                 if filter.report() is None: 
#                     filter.report(self._save_to)

#             figs = filter.plot()
#             self._Figures.extend(figs)

#         # plot results
#         for plotter in self._Plotters:
#             plotter.link(self._Results)
#             fig = plotter.plot()
#             self._Figures.append(fig)

#             if self._save_to is not None:
#                 filename = self._make_figure_filename(plotter)
#                 plotter.save(filename)

#     def _setup_cores(self, **kwargs):
#         &#34;&#34;&#34;
#         Sets Reader, Analyser, and Normaliser to defaults, if no external ones were provided...
#         &#34;&#34;&#34;
#         # check if a sheet_name was specified in case of multi-sheet files...
#         use_multi_sheet = &#34;sheet_name&#34; not in kwargs
#         if self.Reader() is None: 
#             if self._is_multisheet() and use_multi_sheet:
#                 self.Reader(Readers.MultiSheetReader())
#             else: 
#                 self.Reader(Readers.MultiReader())
#         if self.Analyser() is None: 
#             self.Analyser(qpcr.Analyser())
#         if self.Normaliser() is None:
#             self.Normaliser(qpcr.Normaliser())
    
#     def _is_multisheet(self):
#         &#34;&#34;&#34;
#         Checks if a provided excel file contains multiple sheets
#         &#34;&#34;&#34;
#         verdict = False
#         if self._src.endswith(&#34;xlsx&#34;):
#             data = pd.read_excel(self._src, sheet_name = None)
#             verdict = len(data.keys()) &gt; 1
#         return verdict

#     # add_assays is disabled
#     def add_assays(self):
#         print(&#34;To provide a data input file use link()!\nIf you wish to supply separate files for assays-of-interest and normalisers, checkout another Pipeline as this one only works with a single Mlit-Assay file!&#34;)

#     # add_normalisers is disabled
#     def add_assays(self):
#         print(&#34;To provide a data input file use link()!\nIf you wish to supply separate files for assays-of-interest and normalisers, checkout another Pipeline as this one only works with a single Mlit-Assay file!&#34;)
    
class ddCt(Blueprint):
    &#34;&#34;&#34;
    Performs only Delta-Delta-Ct and requires `qpcr.Assay` objects as inputs.
    Hence, this pipeline does NOT read any files!

    It follows the default workflow of the `BasicPlus`pipeline and is based on the `BluePrint`
    pipeline to allow customisation.

    Note
    ----
    As the pipeline inherits from the `Blueprint` pipeline it does have a `Reader` method (which won&#39;t do anything though!). 
    &#34;&#34;&#34;
    def __init__(self):
        super().__init__()
        
    def _setup_cores(self):
        &#34;&#34;&#34;
        Sets Analyser, and Normaliser to defaults, if no external ones were provided...
        &#34;&#34;&#34;
        if self.Analyser() is None: 
            self.Analyser(qpcr.Analyser())
        if self.Normaliser() is None:
            self.Normaliser(qpcr.Normaliser())
        
    def _run(self, **kwargs):
        # setup Analyser, and Normaliser (if none were provided)
        self._setup_cores()
        
        analyser = self.Analyser()
        normaliser = self.Normaliser()

        # check if we have plotters or filters
        have_plotters = len(self._Plotters) != 0 
        have_filters = len(self._Filters) != 0

        # analyse normalisers
        normalisers = [  i for i in self._Normalisers  ]

        if have_filters:
            for filter in self._Filters:
                normalisers = [  filter.pipe(i) for i in normalisers  ]
            
        normalisers = [  analyser.pipe(i) for i in normalisers  ]
       
        # analyse sample assays
        assays = [  i for i in self._Assays  ]

        if have_filters:
            for filter in self._Filters:
                assays = [  filter.pipe(i) for i in assays  ]
        
        assays = [  analyser.pipe(i) for i in assays  ]

        # now normalise
        normaliser.link( assays = assays, normalisers = normalisers )
        normaliser.normalise()

        # get and store results
        results = normaliser.get()
        self._Results = results
        self._df = results.get()
        self._stats_df = results.stats()

        if self._save_to is not None:
            results.save(self._save_to)

        # plot filtering report
        if have_filters:
            for filter in self._Filters:
                if self._save_to is not None or filter.report() is not None:
                    
                    # add report location if none was specified...
                    if filter.report() is None: 
                        filter.report(self._save_to)

                # save filter summary fig
                figs = filter.plot()
                self._Figures.extend(figs)

        # plot results
        if have_plotters:
            for plotter in self._Plotters:

                # generate plotter fig and save
                plotter.link(self._Results)
                fig = plotter.plot()
                self._Figures.append(fig)

                if self._save_to is not None:
                    filename = self._make_figure_filename(plotter)
                    plotter.save(filename)

if __name__ == &#34;__main__&#34;:

    norm_files = [&#34;./Examples/Example Data/28S.csv&#34;, &#34;./Examples/Example Data/actin.csv&#34;]
    sample_files = [&#34;./Examples/Example Data/HNRNPL_nmd.csv&#34;, &#34;./Examples/Example Data/HNRNPL_prot.csv&#34;]

    norm_folder = &#34;./Example Data 3/normalisers/&#34;
    sample_folder = &#34;./Example Data 3/samples/&#34;

    groupnames = [&#34;wt-&#34;, &#34;wt+&#34;, &#34;ko-&#34;, &#34;ko+&#34;]
    
    analysis = Blueprint()
    
    # grouped_analyser = qpcr.Analyser()
    # grouped_analyser.anchor(&#34;first&#34;)
    # analysis.Analyser(grouped_analyser)

    # analysis.save_to(&#34;Example Data 2&#34;)
    # analysis.add_assays(sample_files) # alternative: link() for iteratively linking new assays...
    # analysis.add_normalisers(norm_files)

    analysis.add_assays(sample_folder)
    analysis.add_normalisers(norm_folder)
    
    # print(&#34;No Reps specified, all inferred!&#34;)
    analysis.replicates(6)
    analysis.names(groupnames)

    iqr_filter = Filters.RangeFilter()
    iqr_filter.plotmode(&#34;interactive&#34;)

    iqr_filter.report(&#34;Example Data 4&#34;)
    analysis.add_filters(iqr_filter)

    preview = Plotters.PreviewResults(mode = &#34;static&#34;)
    analysis.add_plotters(preview)

    # now that pipeline is ready, we can run!
    analysis.run()

    # now we can get results!
    results = analysis.get(kind=&#34;df&#34;)
    print(results)    
    # norm_folder = &#34;Example Data 3/normalisers&#34;
    # exp_folder = &#34;Example Data 3/experimental/samples&#34;
    # ctr_folder = &#34;Example Data 3/experimental/samples&#34;

    # groupnames = [&#34;wt-&#34;, &#34;wt+&#34;, &#34;ko-&#34;, &#34;ko+&#34;]
    
    # analysis = BasicPlus(index = &#34;Example Data 2/index.csv&#34;)
    # analysis.save_to(&#34;Example Data &#34;)
    
    # print(analysis._index)
    # # analysis.set_experimental(assays = exp_folder, normalisers = norm_folder)
    # # analysis.set_control(assays = ctr_folder, normalisers = norm_folder)

    # # analysis.replicates(6)
    # # analysis.names(groupnames)

    # iqr_filter = Filters.RangeFilter()
    # # iqr_filter.report(&#34;Example Data 2&#34;)
    # analysis.add_filters(iqr_filter)

    # # preview = Plotters.PreviewResults(mode = &#34;interactive&#34;)
    # # analysis.add_plotters(preview)

    # # # now that pipeline is ready, we can run!
    # # analysis.run()

    # # # now we can get results!
    # # results = analysis.get(kind=&#34;df&#34;)
    # # print(results)

    # # exit(0)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="qpcr.Pipes.Pipes.Basic"><code class="flex name class">
<span>class <span class="ident">Basic</span></span>
</code></dt>
<dd>
<div class="desc"><p>Performs simple standardized DeltaDeltaCt analysis
based on two lists of files, one for normaliser assays and one for sample assays.
This makes use of standard settings for <code><a title="qpcr.Analyser" href="../index.html#qpcr.Analyser">Analyser</a></code> and <code><a title="qpcr.Normaliser" href="../index.html#qpcr.Normaliser">Normaliser</a></code>
which cannot be customized!
For customization check out the <code><a title="qpcr.Pipes.Pipes.Blueprint" href="#qpcr.Pipes.Pipes.Blueprint">Blueprint</a></code> pipeline or generate your own.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Basic(Pipeline):
    &#34;&#34;&#34;
    Performs simple standardized DeltaDeltaCt analysis 
    based on two lists of files, one for normaliser assays and one for sample assays.
    This makes use of standard settings for `qpcr.Analyser` and `qpcr.Normaliser`
    which cannot be customized! 
    For customization check out the `Blueprint` pipeline or generate your own.
    &#34;&#34;&#34;
    def __init__(self):
        super().__init__()
    
    def _run(self, **kwargs):
        &#34;&#34;&#34;
        The automated standard DeltaDeltaCt pipeline. 
        Using default settings of `qpcr.Analyser` and `qpcr.Normaliser`
        &#34;&#34;&#34;
        reader = qpcr.DataReader()
        analyser = qpcr.Analyser()
        normaliser = qpcr.Normaliser()

        # add replicate and names info to kwargs
        kwargs = dict(kwargs, replicates = self._replicates, names = self._names)

        # analyse normalisers
        normalisers = [  reader.read(i, **kwargs) for i in self._Normalisers  ]     
        normalisers = [  analyser.pipe(i) for i in normalisers  ]
       
        # analyse sample assays
        assays = [  reader.read(i, **kwargs) for i in self._Assays  ]   
        assays = [  analyser.pipe(i) for i in assays  ]

        # now normalise
        normaliser.link( assays = assays, normalisers = normalisers )
        normaliser.normalise()

        # get and store results
        results = normaliser.get()
        self._Results = results
        self._df = results.get()
        self._stats_df = results.stats()

        if self._save_to is not None:
            results.save(self._save_to)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="qpcr.Pipes.Pipes.Pipeline" href="#qpcr.Pipes.Pipes.Pipeline">Pipeline</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="qpcr.Pipes.Pipes.BasicPlus" href="#qpcr.Pipes.Pipes.BasicPlus">BasicPlus</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="qpcr.Pipes.Pipes.Pipeline" href="#qpcr.Pipes.Pipes.Pipeline">Pipeline</a></b></code>:
<ul class="hlist">
<li><code><a title="qpcr.Pipes.Pipes.Pipeline.add_assays" href="#qpcr.Pipes.Pipes.Pipeline.add_assays">add_assays</a></code></li>
<li><code><a title="qpcr.Pipes.Pipes.Pipeline.add_normalisers" href="#qpcr.Pipes.Pipes.Pipeline.add_normalisers">add_normalisers</a></code></li>
<li><code><a title="qpcr.Pipes.Pipes.Pipeline.assays" href="#qpcr.Pipes.Pipes.Pipeline.assays">assays</a></code></li>
<li><code><a title="qpcr.Pipes.Pipes.Pipeline.get" href="#qpcr.Pipes.Pipes.Pipeline.get">get</a></code></li>
<li><code><a title="qpcr.Pipes.Pipes.Pipeline.link" href="#qpcr.Pipes.Pipes.Pipeline.link">link</a></code></li>
<li><code><a title="qpcr.Pipes.Pipes.Pipeline.names" href="#qpcr.Pipes.Pipes.Pipeline.names">names</a></code></li>
<li><code><a title="qpcr.Pipes.Pipes.Pipeline.normalisers" href="#qpcr.Pipes.Pipes.Pipeline.normalisers">normalisers</a></code></li>
<li><code><a title="qpcr.Pipes.Pipes.Pipeline.prune" href="#qpcr.Pipes.Pipes.Pipeline.prune">prune</a></code></li>
<li><code><a title="qpcr.Pipes.Pipes.Pipeline.replicates" href="#qpcr.Pipes.Pipes.Pipeline.replicates">replicates</a></code></li>
<li><code><a title="qpcr.Pipes.Pipes.Pipeline.run" href="#qpcr.Pipes.Pipes.Pipeline.run">run</a></code></li>
<li><code><a title="qpcr.Pipes.Pipes.Pipeline.save_to" href="#qpcr.Pipes.Pipes.Pipeline.save_to">save_to</a></code></li>
<li><code><a title="qpcr.Pipes.Pipes.Pipeline.softlink" href="#qpcr.Pipes.Pipes.Pipeline.softlink">softlink</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="qpcr.Pipes.Pipes.BasicPlus"><code class="flex name class">
<span>class <span class="ident">BasicPlus</span></span>
</code></dt>
<dd>
<div class="desc"><p>The same as the Basic Pipeline, but has the option to integrate Plotters and Filters.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BasicPlus(Basic):
    &#34;&#34;&#34;
    The same as the Basic Pipeline, but has the option to integrate Plotters and Filters.
    &#34;&#34;&#34;
    def __init__(self):
        super().__init__()
        self._Plotters = []
        self._Figures = []
        self._Filters = []
    
    def prune(self, assays = True, results = True, normalisers = True, figures = True, plotters = False, filters = False):
        &#34;&#34;&#34;
        Will clear the pipeline.

        Parameters
        ----------
        assays : bool
            Will clear any sample assays in the pipeline if True (default).
        
        results : bool
            Will clear any computed results in the pipline if True (default).
        
        normalisers : bool
            Will clear any normalisers in the pipline if True (default).
        figures : bool
            Will clear any figures in the pipline if True (default).
        plotters : bool
            Will clear any Plotters from the pipeline if True (default False).
        filters : bool
            Will clear any Filters in the pipline if True (default False).
        &#34;&#34;&#34;
        super().prune(assays = assays, results = results, normalisers = normalisers)
        if figures: 
            self._Figures = []
        if filters:
            self._Filters = []
        if plotters: 
            self._Plotters = []

    def add_plotters(self, *Plotters:object):
        &#34;&#34;&#34;
        Adds already specified qpcr.Plotter objects to the Pipeline.
        
        Parameters
        ----------
        *Plotters
            Any number of qpcr.Plotters.Plotter objects.
        &#34;&#34;&#34;
        self._Plotters.extend(Plotters)
    
    def add_filters(self, *Filters:object):
        &#34;&#34;&#34;
        Adds already specified qpcr.Filter instances to the Pipeline.
        
        Parameters
        ----------
        *Filters
            Any number of `qpcr.Filters.Filter` objects.
        &#34;&#34;&#34;
        self._Filters.extend(Filters)

    def Figures(self):
        &#34;&#34;&#34;
        Returns
        -------
        list
            A list of all Figures generated by the pipeline&#39;s Plotters.
        &#34;&#34;&#34;
        return self._Figures

    def _run(self, **kwargs):
        &#34;&#34;&#34;
        The automated standard DeltaDeltaCt pipeline. 
        Also produces applies and Plotters to produce figures...
        &#34;&#34;&#34;

        # simply set up the Blueprint pipeline 
        # and run with default settings
        pipeline = Blueprint()

        pipeline.replicates(self._replicates)
        pipeline.names(self._names)

        if self._save_to is not None:
            pipeline.save_to(self._save_to)

        pipeline.add_assays(self._Assays)
        pipeline.add_normalisers(self._Normalisers)

        pipeline.add_plotters(*self._Plotters)
        pipeline.add_filters(*self._Filters)

        pipeline.run()

        # and store the results
        self._Results = pipeline.get(kind = &#34;obj&#34;)
        self._df = pipeline.get(kind = &#34;df&#34;)
        self._stats_df = pipeline.get(kind = &#34;stats&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="qpcr.Pipes.Pipes.Basic" href="#qpcr.Pipes.Pipes.Basic">Basic</a></li>
<li><a title="qpcr.Pipes.Pipes.Pipeline" href="#qpcr.Pipes.Pipes.Pipeline">Pipeline</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="qpcr.Pipes.Pipes.Blueprint" href="#qpcr.Pipes.Pipes.Blueprint">Blueprint</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="qpcr.Pipes.Pipes.BasicPlus.Figures"><code class="name flex">
<span>def <span class="ident">Figures</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>A list of all Figures generated by the pipeline's Plotters.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Figures(self):
    &#34;&#34;&#34;
    Returns
    -------
    list
        A list of all Figures generated by the pipeline&#39;s Plotters.
    &#34;&#34;&#34;
    return self._Figures</code></pre>
</details>
</dd>
<dt id="qpcr.Pipes.Pipes.BasicPlus.add_filters"><code class="name flex">
<span>def <span class="ident">add_filters</span></span>(<span>self, *Filters: object)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds already specified qpcr.Filter instances to the Pipeline.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>*Filters</code></strong></dt>
<dd>Any number of <code>qpcr.Filters.Filter</code> objects.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_filters(self, *Filters:object):
    &#34;&#34;&#34;
    Adds already specified qpcr.Filter instances to the Pipeline.
    
    Parameters
    ----------
    *Filters
        Any number of `qpcr.Filters.Filter` objects.
    &#34;&#34;&#34;
    self._Filters.extend(Filters)</code></pre>
</details>
</dd>
<dt id="qpcr.Pipes.Pipes.BasicPlus.add_plotters"><code class="name flex">
<span>def <span class="ident">add_plotters</span></span>(<span>self, *Plotters: object)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds already specified qpcr.Plotter objects to the Pipeline.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>*Plotters</code></strong></dt>
<dd>Any number of qpcr.Plotters.Plotter objects.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_plotters(self, *Plotters:object):
    &#34;&#34;&#34;
    Adds already specified qpcr.Plotter objects to the Pipeline.
    
    Parameters
    ----------
    *Plotters
        Any number of qpcr.Plotters.Plotter objects.
    &#34;&#34;&#34;
    self._Plotters.extend(Plotters)</code></pre>
</details>
</dd>
<dt id="qpcr.Pipes.Pipes.BasicPlus.prune"><code class="name flex">
<span>def <span class="ident">prune</span></span>(<span>self, assays=True, results=True, normalisers=True, figures=True, plotters=False, filters=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Will clear the pipeline.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>assays</code></strong> :&ensp;<code>bool</code></dt>
<dd>Will clear any sample assays in the pipeline if True (default).</dd>
<dt><strong><code>results</code></strong> :&ensp;<code>bool</code></dt>
<dd>Will clear any computed results in the pipline if True (default).</dd>
<dt><strong><code>normalisers</code></strong> :&ensp;<code>bool</code></dt>
<dd>Will clear any normalisers in the pipline if True (default).</dd>
<dt><strong><code>figures</code></strong> :&ensp;<code>bool</code></dt>
<dd>Will clear any figures in the pipline if True (default).</dd>
<dt><strong><code>plotters</code></strong> :&ensp;<code>bool</code></dt>
<dd>Will clear any Plotters from the pipeline if True (default False).</dd>
<dt><strong><code>filters</code></strong> :&ensp;<code>bool</code></dt>
<dd>Will clear any Filters in the pipline if True (default False).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prune(self, assays = True, results = True, normalisers = True, figures = True, plotters = False, filters = False):
    &#34;&#34;&#34;
    Will clear the pipeline.

    Parameters
    ----------
    assays : bool
        Will clear any sample assays in the pipeline if True (default).
    
    results : bool
        Will clear any computed results in the pipline if True (default).
    
    normalisers : bool
        Will clear any normalisers in the pipline if True (default).
    figures : bool
        Will clear any figures in the pipline if True (default).
    plotters : bool
        Will clear any Plotters from the pipeline if True (default False).
    filters : bool
        Will clear any Filters in the pipline if True (default False).
    &#34;&#34;&#34;
    super().prune(assays = assays, results = results, normalisers = normalisers)
    if figures: 
        self._Figures = []
    if filters:
        self._Filters = []
    if plotters: 
        self._Plotters = []</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="qpcr.Pipes.Pipes.Basic" href="#qpcr.Pipes.Pipes.Basic">Basic</a></b></code>:
<ul class="hlist">
<li><code><a title="qpcr.Pipes.Pipes.Basic.add_assays" href="#qpcr.Pipes.Pipes.Pipeline.add_assays">add_assays</a></code></li>
<li><code><a title="qpcr.Pipes.Pipes.Basic.add_normalisers" href="#qpcr.Pipes.Pipes.Pipeline.add_normalisers">add_normalisers</a></code></li>
<li><code><a title="qpcr.Pipes.Pipes.Basic.assays" href="#qpcr.Pipes.Pipes.Pipeline.assays">assays</a></code></li>
<li><code><a title="qpcr.Pipes.Pipes.Basic.get" href="#qpcr.Pipes.Pipes.Pipeline.get">get</a></code></li>
<li><code><a title="qpcr.Pipes.Pipes.Basic.link" href="#qpcr.Pipes.Pipes.Pipeline.link">link</a></code></li>
<li><code><a title="qpcr.Pipes.Pipes.Basic.names" href="#qpcr.Pipes.Pipes.Pipeline.names">names</a></code></li>
<li><code><a title="qpcr.Pipes.Pipes.Basic.normalisers" href="#qpcr.Pipes.Pipes.Pipeline.normalisers">normalisers</a></code></li>
<li><code><a title="qpcr.Pipes.Pipes.Basic.replicates" href="#qpcr.Pipes.Pipes.Pipeline.replicates">replicates</a></code></li>
<li><code><a title="qpcr.Pipes.Pipes.Basic.run" href="#qpcr.Pipes.Pipes.Pipeline.run">run</a></code></li>
<li><code><a title="qpcr.Pipes.Pipes.Basic.save_to" href="#qpcr.Pipes.Pipes.Pipeline.save_to">save_to</a></code></li>
<li><code><a title="qpcr.Pipes.Pipes.Basic.softlink" href="#qpcr.Pipes.Pipes.Pipeline.softlink">softlink</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="qpcr.Pipes.Pipes.Blueprint"><code class="flex name class">
<span>class <span class="ident">Blueprint</span></span>
</code></dt>
<dd>
<div class="desc"><p>Performs simple Delta-Delta-Ct analysis based on the same workflow as the <code><a title="qpcr.Pipes.Pipes.BasicPlus" href="#qpcr.Pipes.Pipes.BasicPlus">BasicPlus</a></code> pipeline, but allows full costumization of SampleReader, Analyser, and Normaliser objects.
Optionally, <code><a title="qpcr.SampleReader" href="../index.html#qpcr.SampleReader">SampleReader</a></code>, <code><a title="qpcr.Analyser" href="../index.html#qpcr.Analyser">Analyser</a></code>, and <code><a title="qpcr.Normaliser" href="../index.html#qpcr.Normaliser">Normaliser</a></code> may be set up externally and linked into the pipeline. Any non-linked processing classes will be set up using defaults.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Blueprint(BasicPlus):
    &#34;&#34;&#34;
    Performs simple Delta-Delta-Ct analysis based on the same workflow as the `BasicPlus` pipeline, but allows full costumization of SampleReader, Analyser, and Normaliser objects.
    Optionally, `qpcr.SampleReader`, `qpcr.Analyser`, and `qpcr.Normaliser` may be set up externally and linked into the pipeline. Any non-linked processing classes will be set up using defaults.
    &#34;&#34;&#34;
    def __init__(self):
        super().__init__()
        self._Reader = None
        self._Analyser = None
        self._Normaliser = None

    def prune(self, assays = True, results = True, normalisers = True, figures = True, plotters = False, filters = False, cores = False, reader = False, analyser = False, normaliser = False):
        &#34;&#34;&#34;
        Will clear the pipeline.

        Parameters
        ----------
        assays : bool
            Will clear any sample assays in the pipeline if True (default).
        
        results : bool
            Will clear any computed results in the pipline if True (default).
        
        normalisers : bool
            Will clear any normalisers in the pipline if True (default).
        figures : bool
            Will clear any figures in the pipline if True (default).
        plotters : bool
            Will clear any Plotters from the pipeline if True (default False).
        filters : bool
            Will clear any Filters in the pipline if True (default False).
        cores : bool
            Will clear Reader, Analyser, and Normaliser if True (default False).
        reader : bool
            Will only clear the Reader if True (default False).
        analyser : bool
            Will only clear the Analyser if True (default False).
        normaliser : bool
            Will only clear the Normaliser if True (default False).
            Note, that clearing `results` will also clear the `Normaliser`&#39;s results,
            but keep the Normaliser itself!
        &#34;&#34;&#34;
        super().prune(
                        assays = assays, 
                        results = results, 
                        normalisers = normalisers,
                        figures = figures, 
                        plotters = plotters, 
                        filters = filters
                    )
        
        self._Normaliser.prune(
                                assays = assays, 
                                normalisers = normalisers, 
                                results = results
                            )
        if cores: 
            self._Reader = None
            self._Analyser = None
            self._Normaliser = None
        else:
            if reader:
                self._Reader = None
            if analyser:
                self._Analyser = None
            if normaliser:
                self._Normaliser = None

    def Reader(self, Reader : qpcr.SampleReader = None):
        &#34;&#34;&#34;
        Links a `qpcr.SampleReader` object to the pipeline.

        Parameters
        ----------
        Reader : qpcr.SampleReader
            A `qpcr.SampleReader` object
        &#34;&#34;&#34;
        if Reader is not None: 
            self._Reader = Reader
        return self._Reader

    def Analyser(self, Analyser : qpcr.Analyser = None):
        &#34;&#34;&#34;
        Links a `qpcr.Analyser` object to the pipeline.

        Parameters
        ----------
        Analyser : qpcr.Analyser
            A `qpcr.Analyser` object
        &#34;&#34;&#34;
        if Analyser is not None:
            self._Analyser = Analyser
        return self._Analyser

    def Normaliser(self, Normaliser : qpcr.Normaliser = None):
        &#34;&#34;&#34;
        Links a `qpcr.Normaliser` object to the pipeline.

        Parameters
        ----------
        Normaliser : qpcr.Normaliser
            A `qpcr.Normaliser` object
        &#34;&#34;&#34;
        if Normaliser is not None:
            self._Normaliser = Normaliser
        return self._Normaliser
    
    def _setup_cores(self):
        &#34;&#34;&#34;
        Sets SampleReader, Analyser, and Normaliser to defaults, if no external ones were provided...
        &#34;&#34;&#34;
        if self.Reader() is None: 
            self.Reader(qpcr.DataReader())
        if self.Analyser() is None: 
            self.Analyser(qpcr.Analyser())
        if self.Normaliser() is None:
            self.Normaliser(qpcr.Normaliser())

    def _run(self, **kwargs):
        &#34;&#34;&#34;
        The automated standard DeltaDeltaCt pipeline. 
        Also produces applies and Plotters to produce figures...
        &#34;&#34;&#34;
        # setup Analyser, and Normaliser (if none were provided)
        self._setup_cores()
        
        reader = self.Reader()
        analyser = self.Analyser()
        normaliser = self.Normaliser()

        # check if we have plotters or filters
        have_plotters = len(self._Plotters) != 0 
        have_filters = len(self._Filters) != 0

        # add replicate and names info to kwargs
        kwargs = dict(kwargs, replicates = self._replicates, names = self._names)

        # analyse normalisers
        normalisers = [  reader.read(i, **kwargs) for i in self._Normalisers  ]

        if have_filters:
            for filter in self._Filters:
                normalisers = [  filter.pipe(i) for i in normalisers  ]
            
        normalisers = [  analyser.pipe(i) for i in normalisers  ]
       
        # analyse sample assays
        assays = [  reader.read(i, **kwargs) for i in self._Assays  ]

        if have_filters:
            for filter in self._Filters:
                assays = [  filter.pipe(i) for i in assays  ]
        
        assays = [  analyser.pipe(i) for i in assays  ]

        # now normalise
        normaliser.link( assays = assays, normalisers = normalisers )
        normaliser.normalise()

        # get and store results
        results = normaliser.get()
        self._Results = results
        self._df = results.get()
        self._stats_df = results.stats()

        if self._save_to is not None:
            results.save(self._save_to)

        # plot filtering report
        if have_filters:
            for filter in self._Filters:
                if self._save_to is not None or filter.report() is not None:
                    
                    # add report location if none was specified...
                    if filter.report() is None: 
                        filter.report(self._save_to)

                # save filter summary fig
                figs = filter.plot()
                self._Figures.extend(figs)

        # plot results
        if have_plotters:
            for plotter in self._Plotters:

                # generate plotter fig and save
                plotter.link(self._Results)
                fig = plotter.plot()
                self._Figures.append(fig)

                if self._save_to is not None:
                    filename = self._make_figure_filename(plotter)
                    plotter.save(filename)

    def _make_figure_filename(self, plotter):
        &#34;&#34;&#34;
        Increments a filename with a numeric counter...
        &#34;&#34;&#34;
        num = 1
        suffix = plotter.suffix()
        while True:
            filename = os.path.join(self._save_to, f&#34;{plotter.id()}_{num}.{suffix}&#34;)
            if not os.path.exists(filename):
                break
            num+=1
        return filename</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="qpcr.Pipes.Pipes.BasicPlus" href="#qpcr.Pipes.Pipes.BasicPlus">BasicPlus</a></li>
<li><a title="qpcr.Pipes.Pipes.Basic" href="#qpcr.Pipes.Pipes.Basic">Basic</a></li>
<li><a title="qpcr.Pipes.Pipes.Pipeline" href="#qpcr.Pipes.Pipes.Pipeline">Pipeline</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>qpcr.Pipes.Pipes._Qupid_Blueprint</li>
<li><a title="qpcr.Pipes.Pipes.ddCt" href="#qpcr.Pipes.Pipes.ddCt">ddCt</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="qpcr.Pipes.Pipes.Blueprint.Analyser"><code class="name flex">
<span>def <span class="ident">Analyser</span></span>(<span>self, Analyser: <a title="qpcr.Analyser" href="../index.html#qpcr.Analyser">Analyser</a> = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Links a <code><a title="qpcr.Analyser" href="../index.html#qpcr.Analyser">Analyser</a></code> object to the pipeline.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>Analyser</code></strong> :&ensp;<code><a title="qpcr.Analyser" href="../index.html#qpcr.Analyser">Analyser</a></code></dt>
<dd>A <code><a title="qpcr.Analyser" href="../index.html#qpcr.Analyser">Analyser</a></code> object</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Analyser(self, Analyser : qpcr.Analyser = None):
    &#34;&#34;&#34;
    Links a `qpcr.Analyser` object to the pipeline.

    Parameters
    ----------
    Analyser : qpcr.Analyser
        A `qpcr.Analyser` object
    &#34;&#34;&#34;
    if Analyser is not None:
        self._Analyser = Analyser
    return self._Analyser</code></pre>
</details>
</dd>
<dt id="qpcr.Pipes.Pipes.Blueprint.Normaliser"><code class="name flex">
<span>def <span class="ident">Normaliser</span></span>(<span>self, Normaliser: <a title="qpcr.Normaliser" href="../index.html#qpcr.Normaliser">Normaliser</a> = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Links a <code><a title="qpcr.Normaliser" href="../index.html#qpcr.Normaliser">Normaliser</a></code> object to the pipeline.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>Normaliser</code></strong> :&ensp;<code><a title="qpcr.Normaliser" href="../index.html#qpcr.Normaliser">Normaliser</a></code></dt>
<dd>A <code><a title="qpcr.Normaliser" href="../index.html#qpcr.Normaliser">Normaliser</a></code> object</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Normaliser(self, Normaliser : qpcr.Normaliser = None):
    &#34;&#34;&#34;
    Links a `qpcr.Normaliser` object to the pipeline.

    Parameters
    ----------
    Normaliser : qpcr.Normaliser
        A `qpcr.Normaliser` object
    &#34;&#34;&#34;
    if Normaliser is not None:
        self._Normaliser = Normaliser
    return self._Normaliser</code></pre>
</details>
</dd>
<dt id="qpcr.Pipes.Pipes.Blueprint.Reader"><code class="name flex">
<span>def <span class="ident">Reader</span></span>(<span>self, Reader: <a title="qpcr.SampleReader" href="../index.html#qpcr.SampleReader">SampleReader</a> = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Links a <code><a title="qpcr.SampleReader" href="../index.html#qpcr.SampleReader">SampleReader</a></code> object to the pipeline.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>Reader</code></strong> :&ensp;<code><a title="qpcr.SampleReader" href="../index.html#qpcr.SampleReader">SampleReader</a></code></dt>
<dd>A <code><a title="qpcr.SampleReader" href="../index.html#qpcr.SampleReader">SampleReader</a></code> object</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Reader(self, Reader : qpcr.SampleReader = None):
    &#34;&#34;&#34;
    Links a `qpcr.SampleReader` object to the pipeline.

    Parameters
    ----------
    Reader : qpcr.SampleReader
        A `qpcr.SampleReader` object
    &#34;&#34;&#34;
    if Reader is not None: 
        self._Reader = Reader
    return self._Reader</code></pre>
</details>
</dd>
<dt id="qpcr.Pipes.Pipes.Blueprint.prune"><code class="name flex">
<span>def <span class="ident">prune</span></span>(<span>self, assays=True, results=True, normalisers=True, figures=True, plotters=False, filters=False, cores=False, reader=False, analyser=False, normaliser=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Will clear the pipeline.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>assays</code></strong> :&ensp;<code>bool</code></dt>
<dd>Will clear any sample assays in the pipeline if True (default).</dd>
<dt><strong><code>results</code></strong> :&ensp;<code>bool</code></dt>
<dd>Will clear any computed results in the pipline if True (default).</dd>
<dt><strong><code>normalisers</code></strong> :&ensp;<code>bool</code></dt>
<dd>Will clear any normalisers in the pipline if True (default).</dd>
<dt><strong><code>figures</code></strong> :&ensp;<code>bool</code></dt>
<dd>Will clear any figures in the pipline if True (default).</dd>
<dt><strong><code>plotters</code></strong> :&ensp;<code>bool</code></dt>
<dd>Will clear any Plotters from the pipeline if True (default False).</dd>
<dt><strong><code>filters</code></strong> :&ensp;<code>bool</code></dt>
<dd>Will clear any Filters in the pipline if True (default False).</dd>
<dt><strong><code>cores</code></strong> :&ensp;<code>bool</code></dt>
<dd>Will clear Reader, Analyser, and Normaliser if True (default False).</dd>
<dt><strong><code>reader</code></strong> :&ensp;<code>bool</code></dt>
<dd>Will only clear the Reader if True (default False).</dd>
<dt><strong><code>analyser</code></strong> :&ensp;<code>bool</code></dt>
<dd>Will only clear the Analyser if True (default False).</dd>
<dt><strong><code>normaliser</code></strong> :&ensp;<code>bool</code></dt>
<dd>Will only clear the Normaliser if True (default False).
Note, that clearing <code>results</code> will also clear the <code>Normaliser</code>'s results,
but keep the Normaliser itself!</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prune(self, assays = True, results = True, normalisers = True, figures = True, plotters = False, filters = False, cores = False, reader = False, analyser = False, normaliser = False):
    &#34;&#34;&#34;
    Will clear the pipeline.

    Parameters
    ----------
    assays : bool
        Will clear any sample assays in the pipeline if True (default).
    
    results : bool
        Will clear any computed results in the pipline if True (default).
    
    normalisers : bool
        Will clear any normalisers in the pipline if True (default).
    figures : bool
        Will clear any figures in the pipline if True (default).
    plotters : bool
        Will clear any Plotters from the pipeline if True (default False).
    filters : bool
        Will clear any Filters in the pipline if True (default False).
    cores : bool
        Will clear Reader, Analyser, and Normaliser if True (default False).
    reader : bool
        Will only clear the Reader if True (default False).
    analyser : bool
        Will only clear the Analyser if True (default False).
    normaliser : bool
        Will only clear the Normaliser if True (default False).
        Note, that clearing `results` will also clear the `Normaliser`&#39;s results,
        but keep the Normaliser itself!
    &#34;&#34;&#34;
    super().prune(
                    assays = assays, 
                    results = results, 
                    normalisers = normalisers,
                    figures = figures, 
                    plotters = plotters, 
                    filters = filters
                )
    
    self._Normaliser.prune(
                            assays = assays, 
                            normalisers = normalisers, 
                            results = results
                        )
    if cores: 
        self._Reader = None
        self._Analyser = None
        self._Normaliser = None
    else:
        if reader:
            self._Reader = None
        if analyser:
            self._Analyser = None
        if normaliser:
            self._Normaliser = None</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="qpcr.Pipes.Pipes.BasicPlus" href="#qpcr.Pipes.Pipes.BasicPlus">BasicPlus</a></b></code>:
<ul class="hlist">
<li><code><a title="qpcr.Pipes.Pipes.BasicPlus.Figures" href="#qpcr.Pipes.Pipes.BasicPlus.Figures">Figures</a></code></li>
<li><code><a title="qpcr.Pipes.Pipes.BasicPlus.add_assays" href="#qpcr.Pipes.Pipes.Pipeline.add_assays">add_assays</a></code></li>
<li><code><a title="qpcr.Pipes.Pipes.BasicPlus.add_filters" href="#qpcr.Pipes.Pipes.BasicPlus.add_filters">add_filters</a></code></li>
<li><code><a title="qpcr.Pipes.Pipes.BasicPlus.add_normalisers" href="#qpcr.Pipes.Pipes.Pipeline.add_normalisers">add_normalisers</a></code></li>
<li><code><a title="qpcr.Pipes.Pipes.BasicPlus.add_plotters" href="#qpcr.Pipes.Pipes.BasicPlus.add_plotters">add_plotters</a></code></li>
<li><code><a title="qpcr.Pipes.Pipes.BasicPlus.assays" href="#qpcr.Pipes.Pipes.Pipeline.assays">assays</a></code></li>
<li><code><a title="qpcr.Pipes.Pipes.BasicPlus.get" href="#qpcr.Pipes.Pipes.Pipeline.get">get</a></code></li>
<li><code><a title="qpcr.Pipes.Pipes.BasicPlus.link" href="#qpcr.Pipes.Pipes.Pipeline.link">link</a></code></li>
<li><code><a title="qpcr.Pipes.Pipes.BasicPlus.names" href="#qpcr.Pipes.Pipes.Pipeline.names">names</a></code></li>
<li><code><a title="qpcr.Pipes.Pipes.BasicPlus.normalisers" href="#qpcr.Pipes.Pipes.Pipeline.normalisers">normalisers</a></code></li>
<li><code><a title="qpcr.Pipes.Pipes.BasicPlus.replicates" href="#qpcr.Pipes.Pipes.Pipeline.replicates">replicates</a></code></li>
<li><code><a title="qpcr.Pipes.Pipes.BasicPlus.run" href="#qpcr.Pipes.Pipes.Pipeline.run">run</a></code></li>
<li><code><a title="qpcr.Pipes.Pipes.BasicPlus.save_to" href="#qpcr.Pipes.Pipes.Pipeline.save_to">save_to</a></code></li>
<li><code><a title="qpcr.Pipes.Pipes.BasicPlus.softlink" href="#qpcr.Pipes.Pipes.Pipeline.softlink">softlink</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="qpcr.Pipes.Pipes.Pipeline"><code class="flex name class">
<span>class <span class="ident">Pipeline</span></span>
</code></dt>
<dd>
<div class="desc"><p>This is the basic template class for qpcr Pipelines.
It contains a set of basic preliminary methods
that ensure that elementary required inputs are provided.</p>
<h2 id="note">Note</h2>
<p>The simplest implementation of this <code><a title="qpcr.Pipes.Pipes.Pipeline" href="#qpcr.Pipes.Pipes.Pipeline">Pipeline</a></code> template is the <code><a title="qpcr.Pipes.Pipes.Basic" href="#qpcr.Pipes.Pipes.Basic">Basic</a></code> pipeline.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Pipeline:
    &#34;&#34;&#34;
    This is the basic template class for qpcr Pipelines. 
    It contains a set of basic preliminary methods
    that ensure that elementary required inputs are provided.

    Note
    ----
    The simplest implementation of this `Pipeline` template is the `Basic` pipeline.
    &#34;&#34;&#34;
    def __init__(self):
        # super().__init__()
        self._Normalisers = []
        self._Assays = []
        self._save_to = None
        self._df = None
        self._stats_df = None
        self._Results = None
        self._replicates = None
        self._names = None
        self._softlink = True

    def assays(self):
        &#34;&#34;&#34;
        Returns
        -------
        assays : list
            The linked `qpcr.Assay` objects for assays-of-interest.
        &#34;&#34;&#34;
        assays = self._Assays
        return assays
    
    def normalisers(self):
        &#34;&#34;&#34;
        Returns
        -------
        normalisers : list
            The linked `qpcr.Assay` objects for normaliser-assays.
        &#34;&#34;&#34;
        normalisers = self._Normalisers
        return normalisers

    def replicates(self, replicates:(int or tuple)):
        &#34;&#34;&#34;
        Set the replicates specifics to use for grouping.

        Parameters
        ----------
        replicates : int or tuple
            Can be an `integer` (equal group sizes, e.g. `3` for triplicates), 
            or a `tuple` (uneven group sizes, e.g. `(3,2,3)` if the second group is only a duplicate). 
        &#34;&#34;&#34;
        self._replicates = replicates

    def names(self, names:(list or dict)):
        &#34;&#34;&#34;
        Set names for replicates groups.

        Parameters
        ----------
        names : list or dict
            Either a `list` (new names without repetitions) or `dict` (key = old name, value = new name) specifying new group names. 
            Group names only need to be specified once, and are applied to all replicate entries.
        &#34;&#34;&#34;
        self._names = names


    def run(self, **kwargs):
        &#34;&#34;&#34;
        Will run the pipeline provided that at least minimal inputs have been provided (i.e. Assays and Normalisers, as well as replicate specifics have been provided).
        This is a wrapper, the actual functional core is defined in the method `self._run()`. 
        To implement your own pipeline, make sure to define your own `_run()`, redefine `run()`
        as you require.

        Parameters
        ----------
        **kwargs
            Any additional keyword arguments that will be passed to the actual `_run()` method.
        &#34;&#34;&#34;

        # vet if there are at least one normaliser and assay present
        if self._Normalisers == [] or self._Assays == []:
            aw.HardWarning(&#34;Pipeline:no_data&#34;)

        self._run(**kwargs)
    
    def save_to(self, directory:str):
        &#34;&#34;&#34;
        Set the location where to save result files

        Parameters
        ----------
        directory : str
            A directory to save the results to.
        &#34;&#34;&#34;
        self._save_to = directory
        # if the directory does not yet exist, we make it
        if not os.path.exists(self._save_to):
            os.mkdir(self._save_to)

    def get(self, kind=&#34;stats&#34;):
        &#34;&#34;&#34;
        Returns
        -------
        data 
            A pandas dataframe either in replicate version `kind=&#34;df&#34;`
            or in stats version `kind=&#34;stats&#34;` (default). Alternatively,
            a qpcr.Results object can be returned using `kind=&#34;obj&#34;`.
        &#34;&#34;&#34;
        if kind == &#34;stats&#34;:
            return self._stats_df
        elif kind == &#34;df&#34;:
            df = self._df
            if &#34;assay&#34; in df.columns: 
                df = df.drop(columns = [&#34;assay&#34;])
            return df
        elif kind == &#34;obj&#34;:
            return self._Results
    
    def link(self, assays:(list or str) = None, normalisers:(list or str) = None):
        &#34;&#34;&#34;
        Links new assays-of-interest / sample assays and/or normaliser assays 
        to the pipline, either replacing old ones or keeping them, 
        depending on `softlink()` settings.

        Parameters
        ----------
        assays : list or str
            A `list` of filepaths to raw datafiles of assays-of-interest, or a directory (`str`) where these are stored.
        normalisers : list or str
            A `list` of filepaths to raw datafiles of normaliser assays, or a directory (`str`) where these are stored.
        &#34;&#34;&#34;
        if self._softlink:
            self.prune()
        self.add_assays(assays)
        self.add_normalisers(normalisers)


    def prune(self, assays = True, results = True, normalisers = True):
        &#34;&#34;&#34;
        Will clear assays, results, and/or normalisers

        Parameters
        ----------
        assays : bool
            Will clear any sample assays in the pipeline if True (default).
        
        results : bool
            Will clear any computed results in the pipline if True (default).
        
        normalisers : bool
            Will clear any normalisers in the pipline if True (default).
        &#34;&#34;&#34;
        if assays: self._Assays = []
        if normalisers: self._Normalisers = []
        if results: 
            self._df = None
            self._stats_df = None
            self._Results = None

    def add_normalisers(self, normalisers):
        &#34;&#34;&#34;
        Adds normalisers (filepaths) (keeping any already present)
        
        Parameters
        ----------
        normalisers : list or str
            A `list` of filepaths to raw datafiles of normaliser assays, or a directory (`str`) where these are stored.
        &#34;&#34;&#34;
        normalisers = self._from_directory(normalisers)
        self._Normalisers.extend(normalisers)
    
    def add_assays(self, assays):
        &#34;&#34;&#34;
        Adds assays-of-interest / sample assays (filepaths) (keeping any already present)

        Parameters
        ----------
        assays : list or str
            A `list` of filepaths to raw datafiles of sample assays, or a directory (`str`) where these are stored.
        &#34;&#34;&#34;
        assays = self._from_directory(assays)
        self._Assays.extend(assays)

    def softlink(self, bool = None):
        &#34;&#34;&#34;
        If `softlink = True`, then `link_assays()` will 
        prune any previous assays. Otherwise, it will 
        add new ones and keep old ones.

        Parameters
        ----------
        bool
            Set to False to disable `softlinking` (default is True).
        &#34;&#34;&#34;
        if bool is None:
            return self._softlink
        else:
            self._softlink = bool

    def _from_directory(self, files):
        &#34;&#34;&#34;
        Checks if a directory was provided for assays / normalisers and returns a list of all contained files if so.
        Otherwise it just returns the list of files.
        This is used for add_assays and add_normalisers
        &#34;&#34;&#34;
        if isinstance(files, str):

            # if inputs are a directory
            if os.path.isdir(files):
            
                # get files from the directory
                datafiles = os.listdir(files)
            
                # if no files are found, raise error
                if len(datafiles) == 0:
                    aw.HardWarning(&#34;Pipeline:no_data_input&#34;, file = files, traceback = False)
            
                # combine paths with parent directory
                datafiles = [os.path.join(files,n) for n in datafiles]
                return datafiles

            # else check if inputs are a single file
            # then just put it into a list to be valid input for .extend()
            elif os.path.isfile(files):
                
                return [files]

            else: 
                aw.HardWarning(&#34;Pipeline:no_data_input&#34;, file = files, traceback = False)
        
        # else check if we got a list or tuple of files
        elif isinstance(files, (list or tuple)):
            return files
        
        # raise error for anything else...
        else: 
            aw.HardWarning(&#34;Pipeline:no_data_input&#34;, file = files, traceback = False)


    def _run(self, **kwargs):
        &#34;&#34;&#34;
        This is the actual function that each custom Pipeline has to define...
        &#34;&#34;&#34;
        print(&#34;self._run() is the actual function that each custom Pipeline has to define...&#34;)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="qpcr.Pipes.Pipes.Basic" href="#qpcr.Pipes.Pipes.Basic">Basic</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="qpcr.Pipes.Pipes.Pipeline.add_assays"><code class="name flex">
<span>def <span class="ident">add_assays</span></span>(<span>self, assays)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds assays-of-interest / sample assays (filepaths) (keeping any already present)</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>assays</code></strong> :&ensp;<code>list</code> or <code>str</code></dt>
<dd>A <code>list</code> of filepaths to raw datafiles of sample assays, or a directory (<code>str</code>) where these are stored.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_assays(self, assays):
    &#34;&#34;&#34;
    Adds assays-of-interest / sample assays (filepaths) (keeping any already present)

    Parameters
    ----------
    assays : list or str
        A `list` of filepaths to raw datafiles of sample assays, or a directory (`str`) where these are stored.
    &#34;&#34;&#34;
    assays = self._from_directory(assays)
    self._Assays.extend(assays)</code></pre>
</details>
</dd>
<dt id="qpcr.Pipes.Pipes.Pipeline.add_normalisers"><code class="name flex">
<span>def <span class="ident">add_normalisers</span></span>(<span>self, normalisers)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds normalisers (filepaths) (keeping any already present)</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>normalisers</code></strong> :&ensp;<code>list</code> or <code>str</code></dt>
<dd>A <code>list</code> of filepaths to raw datafiles of normaliser assays, or a directory (<code>str</code>) where these are stored.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_normalisers(self, normalisers):
    &#34;&#34;&#34;
    Adds normalisers (filepaths) (keeping any already present)
    
    Parameters
    ----------
    normalisers : list or str
        A `list` of filepaths to raw datafiles of normaliser assays, or a directory (`str`) where these are stored.
    &#34;&#34;&#34;
    normalisers = self._from_directory(normalisers)
    self._Normalisers.extend(normalisers)</code></pre>
</details>
</dd>
<dt id="qpcr.Pipes.Pipes.Pipeline.assays"><code class="name flex">
<span>def <span class="ident">assays</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>assays</code></strong> :&ensp;<code>list</code></dt>
<dd>The linked <code><a title="qpcr.Assay" href="../index.html#qpcr.Assay">Assay</a></code> objects for assays-of-interest.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assays(self):
    &#34;&#34;&#34;
    Returns
    -------
    assays : list
        The linked `qpcr.Assay` objects for assays-of-interest.
    &#34;&#34;&#34;
    assays = self._Assays
    return assays</code></pre>
</details>
</dd>
<dt id="qpcr.Pipes.Pipes.Pipeline.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, kind='stats')</span>
</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<dl>
<dt><code>data </code></dt>
<dd>A pandas dataframe either in replicate version <code>kind="df"</code>
or in stats version <code>kind="stats"</code> (default). Alternatively,
a qpcr.Results object can be returned using <code>kind="obj"</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(self, kind=&#34;stats&#34;):
    &#34;&#34;&#34;
    Returns
    -------
    data 
        A pandas dataframe either in replicate version `kind=&#34;df&#34;`
        or in stats version `kind=&#34;stats&#34;` (default). Alternatively,
        a qpcr.Results object can be returned using `kind=&#34;obj&#34;`.
    &#34;&#34;&#34;
    if kind == &#34;stats&#34;:
        return self._stats_df
    elif kind == &#34;df&#34;:
        df = self._df
        if &#34;assay&#34; in df.columns: 
            df = df.drop(columns = [&#34;assay&#34;])
        return df
    elif kind == &#34;obj&#34;:
        return self._Results</code></pre>
</details>
</dd>
<dt id="qpcr.Pipes.Pipes.Pipeline.link"><code class="name flex">
<span>def <span class="ident">link</span></span>(<span>self, assays: list = None, normalisers: list = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Links new assays-of-interest / sample assays and/or normaliser assays
to the pipline, either replacing old ones or keeping them,
depending on <code>softlink()</code> settings.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>assays</code></strong> :&ensp;<code>list</code> or <code>str</code></dt>
<dd>A <code>list</code> of filepaths to raw datafiles of assays-of-interest, or a directory (<code>str</code>) where these are stored.</dd>
<dt><strong><code>normalisers</code></strong> :&ensp;<code>list</code> or <code>str</code></dt>
<dd>A <code>list</code> of filepaths to raw datafiles of normaliser assays, or a directory (<code>str</code>) where these are stored.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def link(self, assays:(list or str) = None, normalisers:(list or str) = None):
    &#34;&#34;&#34;
    Links new assays-of-interest / sample assays and/or normaliser assays 
    to the pipline, either replacing old ones or keeping them, 
    depending on `softlink()` settings.

    Parameters
    ----------
    assays : list or str
        A `list` of filepaths to raw datafiles of assays-of-interest, or a directory (`str`) where these are stored.
    normalisers : list or str
        A `list` of filepaths to raw datafiles of normaliser assays, or a directory (`str`) where these are stored.
    &#34;&#34;&#34;
    if self._softlink:
        self.prune()
    self.add_assays(assays)
    self.add_normalisers(normalisers)</code></pre>
</details>
</dd>
<dt id="qpcr.Pipes.Pipes.Pipeline.names"><code class="name flex">
<span>def <span class="ident">names</span></span>(<span>self, names: list)</span>
</code></dt>
<dd>
<div class="desc"><p>Set names for replicates groups.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>names</code></strong> :&ensp;<code>list</code> or <code>dict</code></dt>
<dd>Either a <code>list</code> (new names without repetitions) or <code>dict</code> (key = old name, value = new name) specifying new group names.
Group names only need to be specified once, and are applied to all replicate entries.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def names(self, names:(list or dict)):
    &#34;&#34;&#34;
    Set names for replicates groups.

    Parameters
    ----------
    names : list or dict
        Either a `list` (new names without repetitions) or `dict` (key = old name, value = new name) specifying new group names. 
        Group names only need to be specified once, and are applied to all replicate entries.
    &#34;&#34;&#34;
    self._names = names</code></pre>
</details>
</dd>
<dt id="qpcr.Pipes.Pipes.Pipeline.normalisers"><code class="name flex">
<span>def <span class="ident">normalisers</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>normalisers</code></strong> :&ensp;<code>list</code></dt>
<dd>The linked <code><a title="qpcr.Assay" href="../index.html#qpcr.Assay">Assay</a></code> objects for normaliser-assays.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def normalisers(self):
    &#34;&#34;&#34;
    Returns
    -------
    normalisers : list
        The linked `qpcr.Assay` objects for normaliser-assays.
    &#34;&#34;&#34;
    normalisers = self._Normalisers
    return normalisers</code></pre>
</details>
</dd>
<dt id="qpcr.Pipes.Pipes.Pipeline.prune"><code class="name flex">
<span>def <span class="ident">prune</span></span>(<span>self, assays=True, results=True, normalisers=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Will clear assays, results, and/or normalisers</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>assays</code></strong> :&ensp;<code>bool</code></dt>
<dd>Will clear any sample assays in the pipeline if True (default).</dd>
<dt><strong><code>results</code></strong> :&ensp;<code>bool</code></dt>
<dd>Will clear any computed results in the pipline if True (default).</dd>
<dt><strong><code>normalisers</code></strong> :&ensp;<code>bool</code></dt>
<dd>Will clear any normalisers in the pipline if True (default).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prune(self, assays = True, results = True, normalisers = True):
    &#34;&#34;&#34;
    Will clear assays, results, and/or normalisers

    Parameters
    ----------
    assays : bool
        Will clear any sample assays in the pipeline if True (default).
    
    results : bool
        Will clear any computed results in the pipline if True (default).
    
    normalisers : bool
        Will clear any normalisers in the pipline if True (default).
    &#34;&#34;&#34;
    if assays: self._Assays = []
    if normalisers: self._Normalisers = []
    if results: 
        self._df = None
        self._stats_df = None
        self._Results = None</code></pre>
</details>
</dd>
<dt id="qpcr.Pipes.Pipes.Pipeline.replicates"><code class="name flex">
<span>def <span class="ident">replicates</span></span>(<span>self, replicates: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the replicates specifics to use for grouping.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>replicates</code></strong> :&ensp;<code>int</code> or <code>tuple</code></dt>
<dd>Can be an <code>integer</code> (equal group sizes, e.g. <code>3</code> for triplicates),
or a <code>tuple</code> (uneven group sizes, e.g. <code>(3,2,3)</code> if the second group is only a duplicate).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def replicates(self, replicates:(int or tuple)):
    &#34;&#34;&#34;
    Set the replicates specifics to use for grouping.

    Parameters
    ----------
    replicates : int or tuple
        Can be an `integer` (equal group sizes, e.g. `3` for triplicates), 
        or a `tuple` (uneven group sizes, e.g. `(3,2,3)` if the second group is only a duplicate). 
    &#34;&#34;&#34;
    self._replicates = replicates</code></pre>
</details>
</dd>
<dt id="qpcr.Pipes.Pipes.Pipeline.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Will run the pipeline provided that at least minimal inputs have been provided (i.e. Assays and Normalisers, as well as replicate specifics have been provided).
This is a wrapper, the actual functional core is defined in the method <code>self._run()</code>.
To implement your own pipeline, make sure to define your own <code>_run()</code>, redefine <code>run()</code>
as you require.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Any additional keyword arguments that will be passed to the actual <code>_run()</code> method.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self, **kwargs):
    &#34;&#34;&#34;
    Will run the pipeline provided that at least minimal inputs have been provided (i.e. Assays and Normalisers, as well as replicate specifics have been provided).
    This is a wrapper, the actual functional core is defined in the method `self._run()`. 
    To implement your own pipeline, make sure to define your own `_run()`, redefine `run()`
    as you require.

    Parameters
    ----------
    **kwargs
        Any additional keyword arguments that will be passed to the actual `_run()` method.
    &#34;&#34;&#34;

    # vet if there are at least one normaliser and assay present
    if self._Normalisers == [] or self._Assays == []:
        aw.HardWarning(&#34;Pipeline:no_data&#34;)

    self._run(**kwargs)</code></pre>
</details>
</dd>
<dt id="qpcr.Pipes.Pipes.Pipeline.save_to"><code class="name flex">
<span>def <span class="ident">save_to</span></span>(<span>self, directory: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the location where to save result files</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>directory</code></strong> :&ensp;<code>str</code></dt>
<dd>A directory to save the results to.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_to(self, directory:str):
    &#34;&#34;&#34;
    Set the location where to save result files

    Parameters
    ----------
    directory : str
        A directory to save the results to.
    &#34;&#34;&#34;
    self._save_to = directory
    # if the directory does not yet exist, we make it
    if not os.path.exists(self._save_to):
        os.mkdir(self._save_to)</code></pre>
</details>
</dd>
<dt id="qpcr.Pipes.Pipes.Pipeline.softlink"><code class="name flex">
<span>def <span class="ident">softlink</span></span>(<span>self, bool=None)</span>
</code></dt>
<dd>
<div class="desc"><p>If <code>softlink = True</code>, then <code>link_assays()</code> will
prune any previous assays. Otherwise, it will
add new ones and keep old ones.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>bool</code></strong></dt>
<dd>Set to False to disable <code>softlinking</code> (default is True).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def softlink(self, bool = None):
    &#34;&#34;&#34;
    If `softlink = True`, then `link_assays()` will 
    prune any previous assays. Otherwise, it will 
    add new ones and keep old ones.

    Parameters
    ----------
    bool
        Set to False to disable `softlinking` (default is True).
    &#34;&#34;&#34;
    if bool is None:
        return self._softlink
    else:
        self._softlink = bool</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="qpcr.Pipes.Pipes.ddCt"><code class="flex name class">
<span>class <span class="ident">ddCt</span></span>
</code></dt>
<dd>
<div class="desc"><p>Performs only Delta-Delta-Ct and requires <code><a title="qpcr.Assay" href="../index.html#qpcr.Assay">Assay</a></code> objects as inputs.
Hence, this pipeline does NOT read any files!</p>
<p>It follows the default workflow of the <code><a title="qpcr.Pipes.Pipes.BasicPlus" href="#qpcr.Pipes.Pipes.BasicPlus">BasicPlus</a></code>pipeline and is based on the <code>BluePrint</code>
pipeline to allow customisation.</p>
<h2 id="note">Note</h2>
<p>As the pipeline inherits from the <code><a title="qpcr.Pipes.Pipes.Blueprint" href="#qpcr.Pipes.Pipes.Blueprint">Blueprint</a></code> pipeline it does have a <code>Reader</code> method (which won't do anything though!).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ddCt(Blueprint):
    &#34;&#34;&#34;
    Performs only Delta-Delta-Ct and requires `qpcr.Assay` objects as inputs.
    Hence, this pipeline does NOT read any files!

    It follows the default workflow of the `BasicPlus`pipeline and is based on the `BluePrint`
    pipeline to allow customisation.

    Note
    ----
    As the pipeline inherits from the `Blueprint` pipeline it does have a `Reader` method (which won&#39;t do anything though!). 
    &#34;&#34;&#34;
    def __init__(self):
        super().__init__()
        
    def _setup_cores(self):
        &#34;&#34;&#34;
        Sets Analyser, and Normaliser to defaults, if no external ones were provided...
        &#34;&#34;&#34;
        if self.Analyser() is None: 
            self.Analyser(qpcr.Analyser())
        if self.Normaliser() is None:
            self.Normaliser(qpcr.Normaliser())
        
    def _run(self, **kwargs):
        # setup Analyser, and Normaliser (if none were provided)
        self._setup_cores()
        
        analyser = self.Analyser()
        normaliser = self.Normaliser()

        # check if we have plotters or filters
        have_plotters = len(self._Plotters) != 0 
        have_filters = len(self._Filters) != 0

        # analyse normalisers
        normalisers = [  i for i in self._Normalisers  ]

        if have_filters:
            for filter in self._Filters:
                normalisers = [  filter.pipe(i) for i in normalisers  ]
            
        normalisers = [  analyser.pipe(i) for i in normalisers  ]
       
        # analyse sample assays
        assays = [  i for i in self._Assays  ]

        if have_filters:
            for filter in self._Filters:
                assays = [  filter.pipe(i) for i in assays  ]
        
        assays = [  analyser.pipe(i) for i in assays  ]

        # now normalise
        normaliser.link( assays = assays, normalisers = normalisers )
        normaliser.normalise()

        # get and store results
        results = normaliser.get()
        self._Results = results
        self._df = results.get()
        self._stats_df = results.stats()

        if self._save_to is not None:
            results.save(self._save_to)

        # plot filtering report
        if have_filters:
            for filter in self._Filters:
                if self._save_to is not None or filter.report() is not None:
                    
                    # add report location if none was specified...
                    if filter.report() is None: 
                        filter.report(self._save_to)

                # save filter summary fig
                figs = filter.plot()
                self._Figures.extend(figs)

        # plot results
        if have_plotters:
            for plotter in self._Plotters:

                # generate plotter fig and save
                plotter.link(self._Results)
                fig = plotter.plot()
                self._Figures.append(fig)

                if self._save_to is not None:
                    filename = self._make_figure_filename(plotter)
                    plotter.save(filename)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="qpcr.Pipes.Pipes.Blueprint" href="#qpcr.Pipes.Pipes.Blueprint">Blueprint</a></li>
<li><a title="qpcr.Pipes.Pipes.BasicPlus" href="#qpcr.Pipes.Pipes.BasicPlus">BasicPlus</a></li>
<li><a title="qpcr.Pipes.Pipes.Basic" href="#qpcr.Pipes.Pipes.Basic">Basic</a></li>
<li><a title="qpcr.Pipes.Pipes.Pipeline" href="#qpcr.Pipes.Pipes.Pipeline">Pipeline</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="qpcr.Pipes.Pipes.Blueprint" href="#qpcr.Pipes.Pipes.Blueprint">Blueprint</a></b></code>:
<ul class="hlist">
<li><code><a title="qpcr.Pipes.Pipes.Blueprint.Analyser" href="#qpcr.Pipes.Pipes.Blueprint.Analyser">Analyser</a></code></li>
<li><code><a title="qpcr.Pipes.Pipes.Blueprint.Figures" href="#qpcr.Pipes.Pipes.BasicPlus.Figures">Figures</a></code></li>
<li><code><a title="qpcr.Pipes.Pipes.Blueprint.Normaliser" href="#qpcr.Pipes.Pipes.Blueprint.Normaliser">Normaliser</a></code></li>
<li><code><a title="qpcr.Pipes.Pipes.Blueprint.Reader" href="#qpcr.Pipes.Pipes.Blueprint.Reader">Reader</a></code></li>
<li><code><a title="qpcr.Pipes.Pipes.Blueprint.add_assays" href="#qpcr.Pipes.Pipes.Pipeline.add_assays">add_assays</a></code></li>
<li><code><a title="qpcr.Pipes.Pipes.Blueprint.add_filters" href="#qpcr.Pipes.Pipes.BasicPlus.add_filters">add_filters</a></code></li>
<li><code><a title="qpcr.Pipes.Pipes.Blueprint.add_normalisers" href="#qpcr.Pipes.Pipes.Pipeline.add_normalisers">add_normalisers</a></code></li>
<li><code><a title="qpcr.Pipes.Pipes.Blueprint.add_plotters" href="#qpcr.Pipes.Pipes.BasicPlus.add_plotters">add_plotters</a></code></li>
<li><code><a title="qpcr.Pipes.Pipes.Blueprint.assays" href="#qpcr.Pipes.Pipes.Pipeline.assays">assays</a></code></li>
<li><code><a title="qpcr.Pipes.Pipes.Blueprint.get" href="#qpcr.Pipes.Pipes.Pipeline.get">get</a></code></li>
<li><code><a title="qpcr.Pipes.Pipes.Blueprint.link" href="#qpcr.Pipes.Pipes.Pipeline.link">link</a></code></li>
<li><code><a title="qpcr.Pipes.Pipes.Blueprint.names" href="#qpcr.Pipes.Pipes.Pipeline.names">names</a></code></li>
<li><code><a title="qpcr.Pipes.Pipes.Blueprint.normalisers" href="#qpcr.Pipes.Pipes.Pipeline.normalisers">normalisers</a></code></li>
<li><code><a title="qpcr.Pipes.Pipes.Blueprint.prune" href="#qpcr.Pipes.Pipes.Blueprint.prune">prune</a></code></li>
<li><code><a title="qpcr.Pipes.Pipes.Blueprint.replicates" href="#qpcr.Pipes.Pipes.Pipeline.replicates">replicates</a></code></li>
<li><code><a title="qpcr.Pipes.Pipes.Blueprint.run" href="#qpcr.Pipes.Pipes.Pipeline.run">run</a></code></li>
<li><code><a title="qpcr.Pipes.Pipes.Blueprint.save_to" href="#qpcr.Pipes.Pipes.Pipeline.save_to">save_to</a></code></li>
<li><code><a title="qpcr.Pipes.Pipes.Blueprint.softlink" href="#qpcr.Pipes.Pipes.Pipeline.softlink">softlink</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">

<a href="https://github.com/NoahHenrikKleinschmidt/qpcr">
<img src="../qpcr_light.svg" width = "100%" >
</a>
<h1>Index</h1>

<div class="toc">
<ul>
<li><a href="#a-word-on-plotters">A Word on Plotters</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="qpcr.Pipes" href="index.html">qpcr.Pipes</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="qpcr.Pipes.Pipes.Basic" href="#qpcr.Pipes.Pipes.Basic">Basic</a></code></h4>
</li>
<li>
<h4><code><a title="qpcr.Pipes.Pipes.BasicPlus" href="#qpcr.Pipes.Pipes.BasicPlus">BasicPlus</a></code></h4>
<ul class="">
<li><code><a title="qpcr.Pipes.Pipes.BasicPlus.Figures" href="#qpcr.Pipes.Pipes.BasicPlus.Figures">Figures</a></code></li>
<li><code><a title="qpcr.Pipes.Pipes.BasicPlus.add_filters" href="#qpcr.Pipes.Pipes.BasicPlus.add_filters">add_filters</a></code></li>
<li><code><a title="qpcr.Pipes.Pipes.BasicPlus.add_plotters" href="#qpcr.Pipes.Pipes.BasicPlus.add_plotters">add_plotters</a></code></li>
<li><code><a title="qpcr.Pipes.Pipes.BasicPlus.prune" href="#qpcr.Pipes.Pipes.BasicPlus.prune">prune</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="qpcr.Pipes.Pipes.Blueprint" href="#qpcr.Pipes.Pipes.Blueprint">Blueprint</a></code></h4>
<ul class="">
<li><code><a title="qpcr.Pipes.Pipes.Blueprint.Analyser" href="#qpcr.Pipes.Pipes.Blueprint.Analyser">Analyser</a></code></li>
<li><code><a title="qpcr.Pipes.Pipes.Blueprint.Normaliser" href="#qpcr.Pipes.Pipes.Blueprint.Normaliser">Normaliser</a></code></li>
<li><code><a title="qpcr.Pipes.Pipes.Blueprint.Reader" href="#qpcr.Pipes.Pipes.Blueprint.Reader">Reader</a></code></li>
<li><code><a title="qpcr.Pipes.Pipes.Blueprint.prune" href="#qpcr.Pipes.Pipes.Blueprint.prune">prune</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="qpcr.Pipes.Pipes.Pipeline" href="#qpcr.Pipes.Pipes.Pipeline">Pipeline</a></code></h4>
<ul class="two-column">
<li><code><a title="qpcr.Pipes.Pipes.Pipeline.add_assays" href="#qpcr.Pipes.Pipes.Pipeline.add_assays">add_assays</a></code></li>
<li><code><a title="qpcr.Pipes.Pipes.Pipeline.add_normalisers" href="#qpcr.Pipes.Pipes.Pipeline.add_normalisers">add_normalisers</a></code></li>
<li><code><a title="qpcr.Pipes.Pipes.Pipeline.assays" href="#qpcr.Pipes.Pipes.Pipeline.assays">assays</a></code></li>
<li><code><a title="qpcr.Pipes.Pipes.Pipeline.get" href="#qpcr.Pipes.Pipes.Pipeline.get">get</a></code></li>
<li><code><a title="qpcr.Pipes.Pipes.Pipeline.link" href="#qpcr.Pipes.Pipes.Pipeline.link">link</a></code></li>
<li><code><a title="qpcr.Pipes.Pipes.Pipeline.names" href="#qpcr.Pipes.Pipes.Pipeline.names">names</a></code></li>
<li><code><a title="qpcr.Pipes.Pipes.Pipeline.normalisers" href="#qpcr.Pipes.Pipes.Pipeline.normalisers">normalisers</a></code></li>
<li><code><a title="qpcr.Pipes.Pipes.Pipeline.prune" href="#qpcr.Pipes.Pipes.Pipeline.prune">prune</a></code></li>
<li><code><a title="qpcr.Pipes.Pipes.Pipeline.replicates" href="#qpcr.Pipes.Pipes.Pipeline.replicates">replicates</a></code></li>
<li><code><a title="qpcr.Pipes.Pipes.Pipeline.run" href="#qpcr.Pipes.Pipes.Pipeline.run">run</a></code></li>
<li><code><a title="qpcr.Pipes.Pipes.Pipeline.save_to" href="#qpcr.Pipes.Pipes.Pipeline.save_to">save_to</a></code></li>
<li><code><a title="qpcr.Pipes.Pipes.Pipeline.softlink" href="#qpcr.Pipes.Pipes.Pipeline.softlink">softlink</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="qpcr.Pipes.Pipes.ddCt" href="#qpcr.Pipes.Pipes.ddCt">ddCt</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>