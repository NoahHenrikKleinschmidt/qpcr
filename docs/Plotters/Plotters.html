<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>qpcr.Plotters.Plotters API documentation</title>
<meta name="description" content="This module is designed for streamlined data visualisation of the qpcr generated results
It is designed to work directly with `qpcr.Results` objects â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>qpcr.Plotters.Plotters</code></h1>
</header>
<section id="section-intro">
<p>This module is designed for streamlined data visualisation of the qpcr generated results
It is designed to work directly with <code><a title="qpcr.Results" href="../index.html#qpcr.Results">Results</a></code> objects. </p>
<h2 id="static-vs-interactive-figures"><code>Static</code> vs <code>Interactive</code> Figures</h2>
<hr>
<p>The <code>Plotters</code> are designed to produce two kinds of figures each, either a <code>"static"</code> or
an <code>"interactive"</code> figure.
The type of figure a specific Plotter should produce has to be specified using the <code>mode</code> argument. </p>
<h3 id="static-figures">Static Figures</h3>
<p><em>Static</em>
figures are made using <code>matplotlib</code> and they will open through whatever backend your matplotlib configuration
as specified. Static figures are primarily designed for printing into labjournals and offer a greater flexibility with
style customizibility (you can use <code>seaborn</code> styles for instance, or the matplotlib <code>rcparams</code> to style your figures). </p>
<h3 id="interactive-figures">Interactive Figures</h3>
<p><em>Interactive</em>
figures are made using <code>plotly</code> and they will open in your browser. Interactive Figures are primarily designed
for cases where your figures contain a lot of data so having a static view on them might be insufficient. Interactive figures
offer <code>plotly</code>'s native features like zooming, cropping, size-adjustments and so forth. It comes at the price of less flexibility
with regard to styling. You can set plotly <code>templates</code>, but that's about it. However, also interactive figures are perfectly
adequate for your labjournal, and you may prefer using these for their dynamic figure size adjustments directly from your browser. </p>
<h3 id="plotting-kwargs">Plotting <code>kwargs</code></h3>
<p>Both Static and Interactive Figures support a variety of keyword arguments that allow you to customise many of their
characteristics and their underlying data handling. You can check which kwargs are passable to each type of figure in
the documentation of each Plotter.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This module is designed for streamlined data visualisation of the qpcr generated results
It is designed to work directly with `qpcr.Results` objects. 

## `Static` vs `Interactive` Figures
----

The `Plotters` are designed to produce two kinds of figures each, either a `&#34;static&#34;` or  an `&#34;interactive&#34;` figure. 
The type of figure a specific Plotter should produce has to be specified using the `mode` argument. 

### Static Figures
_Static_  figures are made using `matplotlib` and they will open through whatever backend your matplotlib configuration 
as specified. Static figures are primarily designed for printing into labjournals and offer a greater flexibility with 
style customizibility (you can use `seaborn` styles for instance, or the matplotlib `rcparams` to style your figures). 

### Interactive Figures
_Interactive_  figures are made using `plotly` and they will open in your browser. Interactive Figures are primarily designed
for cases where your figures contain a lot of data so having a static view on them might be insufficient. Interactive figures
offer `plotly`&#39;s native features like zooming, cropping, size-adjustments and so forth. It comes at the price of less flexibility
with regard to styling. You can set plotly `templates`, but that&#39;s about it. However, also interactive figures are perfectly 
adequate for your labjournal, and you may prefer using these for their dynamic figure size adjustments directly from your browser. 

### Plotting `kwargs` 
Both Static and Interactive Figures support a variety of keyword arguments that allow you to customise many of their 
characteristics and their underlying data handling. You can check which kwargs are passable to each type of figure in 
the documentation of each Plotter. 
&#34;&#34;&#34;

import qpcr.__init__ as qpcr
# import qpcr.Pipes
import qpcr._auxiliary.graphical as gx
import qpcr._auxiliary as aux 
import qpcr._auxiliary.defaults as defaults
import qpcr._auxiliary.warnings as wa
import pandas as pd 
import matplotlib.pyplot as plt
from matplotlib.lines import Line2D
import plotly.graph_objs as go
from plotly.subplots import make_subplots
import plotly
import seaborn as sns 
import numpy as np 

# setup default settings for charts

# FUTURE DROP HERE
# These are no longer refereced like this but directly from the defaults...
# we will remove them in a future version...

_default_static_PreviewBars = defaults.static_PreviewBars
_default_interactive_PreviewBars = defaults.interactive_PreviewBars

_default_static_PreviewDots = defaults.static_PreviewDots
_default_interactive_PreviewDots = defaults.interactive_PreviewDots

_default_static_ReplicateBoxPlot = defaults.static_ReplicateBoxPlot
_default_interactive_ReplicateBoxPlot = defaults.interactive_ReplicateBoxPlot

_default_static_FilterSummary = defaults.static_FilterSummary
_default_interactive_FilterSummary = defaults.interactive_FilterSummary


# get default colnames Id + Ct
raw_col_names = defaults.raw_col_names

# Concept: 
# Plotter: 
#       We define a superclass Plotter that will handle linking to data, 
#       linking to default parameters, and setting up default parameters.
#       It also provides a generic plot() method that will call on a FigureClass specific _plot() method...
#       Wether or not to use static or interactive plots is also handled by this class...
#
# Wrapper: 
#       The Wrapper is an equivalent to the Plotter superclass, but allows a facilitated user interface to 
#       several different plotters. It re-defines the public methods of the Plotter superclass and creates 
#       an instance of a specific Plotter and forwards data to that instance. 
#
# FigureClass:
#       A parent class for each type of figure. It contains two potential _plot() 
#       methods, one for interactive one for static plotting... Which one to use is decided based on the plotting mode...
#       Each FigureClass has therefore to link default parameters, then init Plotter (superclass), 
#       and define their own _static_plot() and _interactive_plot() methods! Any additionally required methods can be written as well...


class Plotter:
    &#34;&#34;&#34;
    A superclass that handles Data Linking and Parameter setup for FigureClasses
    (not for End-User usage)

    Parameters
    ----------
    mode : str
        The plotting mode. May be either &#34;static&#34; (matplotlib) or &#34;interactive&#34; (plotly).    
    &#34;&#34;&#34;
    def __init__(self, mode = None):
        self._default_params = None
        self._PARAMS = {} #: _PARAMS will store the plotting parameter kwargs from both _default_params and any additional user specified parameters
        self._Results = None
        self._data = None
        self._rep_data = None
        self._id = type(self).__name__
        self._MODE = &#34;interactive&#34; if mode is None else mode
        self._fig = None
        self._set_plot()

    def link(self, Results:(qpcr.Results or pd.DataFrame)):
        &#34;&#34;&#34;
        Links a Results object or pandas DataFrame of the same architecture
        as one handled by a Results object to the Plotter. 
        Note, that this will replace any previously linked data!

        Parameters
        ----------
        Results : qpcr.Results or pd.DataFrame
            A qpcr.Results Object or a pandas DataFrame of the same architecture.
        &#34;&#34;&#34;
        
        if aux.same_type(Results, qpcr.Results()):
            self._Results = Results
            self._data = self._Results.stats()
            self._rep_data = self._Results.get()
        elif isinstance(Results, pd.DataFrame):
            self._Results = None
            self._data = Results
        else:
            wa.HardWarning(&#34;Plotter:unknown_data&#34;, obj = Results)

    def plot(self, **kwargs):
        &#34;&#34;&#34;
        Generate Figure

        Parameters
        ----------
        **kwargs
            Any arbitrary keyword arguments to be passed to the plotting method
        
        Returns
        -------
        fig
            A figure object, either from matplotlib or plotly
        &#34;&#34;&#34;
        total_kwargs = self.update_params(kwargs)
        fig = self._plot(**total_kwargs)
        self._fig = fig
        return fig

    def id(self, id:str = None):
        &#34;&#34;&#34;
        Set a unique Id, by default the Classname will be used.

        Parameters
        ----------
        id : str
            A unique identifier for the Plotter object
        
        Returns
        -------
        id 
            The Plotter Id (if no id keyword was entered)
        &#34;&#34;&#34;
        if id is not None:
            self._id = id
        else:
            return self._id

    def get(self):
        &#34;&#34;&#34;
        Returns the DataFrame used for plotting

        Returns
        -------
        data
            A pandas DataFrame containing the data underlying the plot.
        &#34;&#34;&#34;
        return self._data

    def params(self, **params):
        &#34;&#34;&#34;
        Set default parameters for plotting (will be forwarded to **kwargs)
        Returns default parameters if no new parameters are added.

        Parameters
        ----------
        **params
            Any arbitrary keyword arguments to be passed on to the pre-set plotting kwargs.
            This will either set the default parameters (if none has been specified up to the function call)
            or will update the parameters. In case of keyword duplications any OLD key : value pairs will be 
            OVERWRITTEN by new ones. 
        
        Returns
        -------
        params : dict
            A dictionary of the new pre-set plotting parameters
        &#34;&#34;&#34;
        if params != {} and self._PARAMS == {}:
            self._PARAMS = params
        elif params != {}:
            self.update_params(params, store = True)
        return self._PARAMS

    def update_params(self, kwargs, supersede = True, store = False):
        &#34;&#34;&#34;
        Appends pre-set parameters to kwargs. 
        
        Parameters
        ----------
        kwargs : dict
            A dictionary of arbitrary keywords for plotting 
        supersede : bool 
            In case of key duplications: Old values will be replaced with new ones (if supersede = True, default), 
            or keep old ones (supersede = False).
        store : bool
            The newly set plotting parameter dictionary will be stored by the plotting object as new default (if store = True, default is False).
        
        Returns
        -------
        params : dict
            A dictionary of updated plotting parameters
        &#34;&#34;&#34;
        if supersede:
            kwargs = dict(self._PARAMS, **kwargs)
        else:
            kwargs = dict(kwargs, **self._PARAMS)
        
        if store:
            self._PARAMS = kwargs

        return kwargs

    def save(self, filename, **kwargs):
        &#34;&#34;&#34;
        Saves the figure to a file. 
        Figures are either saved using `plt.savefig` or `plotly.offline.plot`.

        Parameters
        ----------
        filename : str 
            A filename to save the figure to.
        
        **kwargs
            Any arbitrary keyword arguments for the respective figure saving method. 
        &#34;&#34;&#34;
        if self._fig is None:
            wa.SoftWarning(&#34;Plotter:no_fig_yet&#34;)
        else:
            if self._MODE == &#34;static&#34;:
                self._fig.savefig(filename, bbox_inches = &#39;tight&#39;, **kwargs)
            elif self._MODE == &#34;interactive&#34;:
                plotly.offline.plot(self._fig, filename=filename, **kwargs)

    def suffix(self):
        &#34;&#34;&#34;
        Returns
        ------- 
        suffix : str
            The appropriate file suffix for save (html for &#34;interactive&#34; or jpg for &#34;static&#34; figures)
        &#34;&#34;&#34;
        suffix = &#34;jpg&#34; if self._MODE == &#34;static&#34; else &#34;html&#34;
        return suffix

    def _setup_default_params(self, static:dict, interactive:dict):
        &#34;&#34;&#34;
        Setup and set default parameters for a FigureClass
        &#34;&#34;&#34;
        self._static_default = static
        self._interactive_default = interactive

    def _set_plot(self):
        &#34;&#34;&#34;
        Sets self._plot either interactive or static depending on MODe
        &#34;&#34;&#34;
        self._plot  = self._static_plot if self._MODE == &#34;static&#34; else self._interactive_plot
        prev_default = self._default_params
        self._default_params = self._static_default if self._MODE == &#34;static&#34; else self._interactive_default

        if self.params() == {} or self.params() == prev_default:
            self.params(**self._default_params)
        else:
            self.update_params(self._default_params, store = True, supersede = False)

    def _static_plot(self, **kwargs):
        &#34;&#34;&#34;
        The plot function that will handle static plotting (will be redefined for each FigureClass)
        &#34;&#34;&#34;
        print(&#34;The plot function that will handle static plotting...&#34;)
        print(&#34;Surprised to see this?, \nPerhaps your desired plotting methods are not named properly. Make sure to name your method _static_plot()!&#34;)

    def _interactive_plot(self, **kwargs):
        &#34;&#34;&#34;
        The plot function that will handle interactive plotting (will be redefined for each FigureClass)
        &#34;&#34;&#34;
        print(&#34;The plot function that will handle interactive plotting...&#34;)
        print(&#34;Surprised to see this?, \nPerhaps your desired plotting methods are not named properly. Make sure to name your method _interactive_plot()!&#34;)

    def _prep_properties(self, kwargs):
        &#34;&#34;&#34;
        Setup ncols, nrows, subplot titles (headers), x, y, and sterr, columns for figure...
        &#34;&#34;&#34;
        self._setup_default_plot_cols()
        data = self.get()

        # setup reference column and figure subplots
        ref_col = aux.from_kwargs(&#34;key&#34;, &#34;assay&#34;, kwargs, rm=True)
        ncols, nrows = aux.from_kwargs(&#34;subplots&#34;, 
                                        gx.make_layout(data, ref_col), 
                                        kwargs, rm=True
                                       )

        # transposing currently not supported...
        # if aux.from_kwargs(&#34;transpose&#34;, False, kwargs, rm = True):
        #     ncols, nrows = nrows, ncols

        headers = aux.sorted_set(data[ref_col])

        x = aux.from_kwargs(&#34;x&#34;, self._default_x, kwargs, rm = True)
        y = aux.from_kwargs(&#34;y&#34;, self._default_y, kwargs, rm = True)
        sterr = aux.from_kwargs(&#34;sterr&#34;, self._default_sterr, kwargs, rm = True)
        
        # the query to be used if group or group_name is ref_col
        query = &#34;{ref_col} == &#39;{q}&#39;&#34; if isinstance(headers[0], str) else &#34;{ref_col} == {q}&#34;

        return ref_col,ncols,nrows, headers, x, y, sterr, query

    def _setup_default_plot_cols(self):
        &#34;&#34;&#34;
        Sets default columns for x and y in barcharts,
        default x
        - &#34;group_name&#34; column if present 
        - &#34;group&#34; Otherwise
        default y
        - &#34;mean&#34;
        default sterr
        - &#34;stdev&#34;
        &#34;&#34;&#34;
        columns = self._data.columns
        self._default_x = &#34;group_name&#34; if &#34;group_name&#34; in columns else &#34;group&#34;
        self._default_y = &#34;mean&#34;
        self._default_sterr = &#34;stdev&#34;

    def _add_subplot_label(self, idx, subplot, start_character):
        &#34;&#34;&#34;
        Adds A B C ... to upper left corner of a subplot...
        It will start labelling at any arbitrary start_character
        &#34;&#34;&#34;
        subplot_label = chr(ord(start_character)+idx)
        subplot.annotate(
                    xy = (-0.1,1.03), 
                    text = subplot_label, 
                    xycoords = &#34;axes fraction&#34;,
                    weight = &#34;bold&#34;, fontsize = 12
                )

# The Wrapper essentially defines public methods from Plotter but 
# replaces self with self._Plotter instead...
class Wrapper:
    &#34;&#34;&#34;
    A superclass that allows to make wrappers for multiple Plotters 
    (not for End-User usage).

    Parameters
    ----------
    kind : str
        The kind of Plotter to call. This can be any of the wrapped 
        Plotters, e.g. `kind = &#34;GroupBars&#34;`.   
    mode : str
        The plotting mode. May be either &#34;static&#34; (matplotlib) or &#34;interactive&#34; (plotly). 

    &#34;&#34;&#34;
    def __init__(self, kind : str, mode : str):

        self._Plotter = None
        self._id = type(self).__name__

        # Application of this would work as:
        # plotters = {
        #                 &#34;some_Plotter&#34; : some_Plotter, 
        #         }
            
        # self._Plotter = plotters[ kind ]
        # self._Plotter = self._Plotter( mode = mode )
    
    def plotter(self):
        &#34;&#34;&#34;
        Returns
        -------
        plotter
            The currently used core Plotter
        &#34;&#34;&#34;
        plotter = self._Plotter
        return plotter


    def link(self, Results:(qpcr.Results or pd.DataFrame)):
        &#34;&#34;&#34;
        Links a Results object or pandas DataFrame of the same architecture
        as one handled by a Results object to the Plotter. 
        Note, that this will replace any previously linked data!

        Parameters
        ----------
        Results : qpcr.Results or pd.DataFrame
            A qpcr.Results Object or a pandas DataFrame of the same architecture.
        &#34;&#34;&#34;
        plotter = self._Plotter
        plotter.link( Results )


    def plot(self, **kwargs):
        &#34;&#34;&#34;
        Generate Figure

        Parameters
        ----------
        **kwargs
            Any arbitrary keyword arguments to be passed to the plotting method
        
        Returns
        -------
        fig
            A figure object, either from matplotlib or plotly
        &#34;&#34;&#34;
        fig = self._Plotter.plot( **kwargs )
        return fig 

    def id(self, id:str = None):
        &#34;&#34;&#34;
        Set a unique Id, by default the Classname will be used.

        Parameters
        ----------
        id : str
            A unique identifier for the Plotter object
        
        Returns
        -------
        id 
            The Plotter Id (if no id keyword was entered)
        &#34;&#34;&#34;
        if id is not None:
            self._id = id
        else:
            return self._id

    def get(self):
        &#34;&#34;&#34;
        Returns the DataFrame used for plotting

        Returns
        -------
        data
            A pandas DataFrame containing the data underlying the plot.
        &#34;&#34;&#34;
        return self._Plotter.get()

    def params(self, **params):
        &#34;&#34;&#34;
        Set default parameters for plotting (will be forwarded to **kwargs)
        Returns default parameters if no new parameters are added.

        Parameters
        ----------
        **params
            Any arbitrary keyword arguments to be passed on to the pre-set plotting kwargs.
            This will either set the default parameters (if none has been specified up to the function call)
            or will update the parameters. In case of keyword duplications any OLD key : value pairs will be 
            OVERWRITTEN by new ones. 
        
        Returns
        -------
        params : dict
            A dictionary of the new pre-set plotting parameters
        &#34;&#34;&#34;
        params = self._Plotter.params( **params )
        return params

    def update_params(self, kwargs, supersede = True, store = False):
        &#34;&#34;&#34;
        Appends pre-set parameters to kwargs. 
        
        Parameters
        ----------
        kwargs : dict
            A dictionary of arbitrary keywords for plotting 
        supersede : bool 
            In case of key duplications: Old values will be replaced with new ones (if supersede = True, default), 
            or keep old ones (supersede = False).
        store : bool
            The newly set plotting parameter dictionary will be stored by the plotting object as new default (if store = True, default is False).
        
        Returns
        -------
        params : dict
            A dictionary of updated plotting parameters
        &#34;&#34;&#34;
        params = self._Plotter.update_params( kwargs, supersede = supersede, store = store )
        return params

    def save(self, filename, **kwargs):
        &#34;&#34;&#34;
        Saves the figure to a file. 
        Figures are either saved using `plt.savefig` or `plotly.offline.plot`.

        Parameters
        ----------
        filename : str 
            A filename to save the figure to.
        
        **kwargs
            Any arbitrary keyword arguments for the respective figure saving method. 
        &#34;&#34;&#34;
        self._Plotter.save( filename = filename, **kwargs )
    
    def suffix(self):
        &#34;&#34;&#34;
        Returns
        ------- 
        suffix : str
            The appropriate file suffix for save (html for &#34;interactive&#34; or jpg for &#34;static&#34; figures)
        &#34;&#34;&#34;
        suffix = self._Plotter.suffix()
        return suffix

    def id(self, id:str = None):
        &#34;&#34;&#34;
        Set a unique Id, by default the Classname will be used.

        Parameters
        ----------
        id : str
            A unique identifier for the Plotter object
        
        Returns
        -------
        id 
            The Plotter Id (if no id keyword was entered)
        &#34;&#34;&#34;
        if id is not None:
            self._id = id
        else:
            return self._id


class PreviewResults(Wrapper):
    &#34;&#34;&#34;
    Generate a Preview of all results from all Assays in subplots.

    This is a wrapper for the Plotters: 

    - `AssayBars` ( which was previously `PreviewResults`, and is now the default setting )
    - `GroupBars`
    - `AssayDots`
    - `GroupDots` 

    Parameters
    ----------
    mode : str
        The plotting mode. May be either &#34;static&#34; (matplotlib) or &#34;interactive&#34; (plotly).

    kind : str
        The kind of Plotter to call. This can be any of the four wrapped 
        Plotters, e.g. `kind = &#34;GroupBars&#34;`.
    &#34;&#34;&#34;
    def __init__(self, mode : str, kind : str = &#34;AssayBars&#34; ):

        super().__init__( kind = kind, mode = mode )
        
        plotters = {
                        &#34;AssayBars&#34; : AssayBars,
                        &#34;GroupBars&#34; : GroupBars,
                        &#34;AssayDots&#34; : AssayDots,
                        &#34;GroupDots&#34; : GroupDots,  
                }
        
        self._Plotter = plotters[ kind ]
        self._Plotter = self._Plotter( mode = mode )


class AssayBars(Plotter):
    &#34;&#34;&#34;
    Generate a Preview of all results from all Assays in subplots as Bar Charts.
    Each assay will be shown in a separate subplot.

    Parameters
    ----------
    mode : str
        The plotting mode. May be either &#34;static&#34; (matplotlib) or &#34;interactive&#34; (plotly).


    Plotting Kwargs
    ----
    
    #### `&#34;static&#34;` Kwargs
    Static AssayBars figures accept the following kwargs:
    
    |   Argument  |  Description    |  Example    |
    | ---- | ---- | ---- |
    |  show : `bool`    |  Whether or not to show the figure    |  `show = True` (default)   |
    |   figsize : `tuple`   |  The figure size    | `figsize = (10, 4)`     |
    | title : `str`   |  The overall figure title   | `title = &#34;Today&#39;s results&#34;    |
    | xlabel : `str`| The x-axis label of each subplot | `xlabel = &#34;Conditions&#34;` |
    | ylabel : `str`| The y-axis label of each subplot | `ylabel = &#34;Mean $\Delta\Delta Ct$&#34;` |
    | rot : `float` | The rotation of x-axis labels | `rot = 0.3` |
    |    headers : `list` |  A list of titles for each subplot in the preview figure    | `headers = [&#34;transcript A&#34;, &#34;transcript B&#34;]`     |
    |  label_subplots  : `bool`   |   Add each subplot with A, B, C ... (if True, default)   | `label_subplots = True` (default)     |
    | labeltype : `str`| The starting character for subplot labelling. By default an `&#34;A&#34;`. | `labeltype = &#34;a&#34;` |
    |   frame   : `bool` |  Show left and top spines of subplots (if True)    | `frame = False` (default)     |
    |   color : `str or list`   | The fillcolor for the individual bars   | `color = &#34;yellow&#34;`     |
    |  style : `str`   | A `seaborn` style to set. Check out available styles [here](https://www.python-graph-gallery.com/104-seaborn-themes).     | `style = &#34;darkgrid&#34;`    |
    |   edgecolor : `str or list`   | The edgecolor for the individual bars   | `edgecolor = &#34;black&#34;`     |
    |   edgewidth : `float`   |  The width of the edge of individual bars  | `edgewidth = 0.5`     |
    |  ecolor : `str`    |   The color of errorbars   |  `ecolor = &#34;orange&#34;`    |
    |  **kwargs    | Any additional kwargs that can be passed to the `matplotlib`-backend pandas `.plot.bar()` API.     |      |

    &lt;br&gt;&lt;/br&gt;
    #### `&#34;interactive&#34;` Kwargs
    Interactive AssayBars figures accept the following kwargs:

    |   Argument  |  Description    |  Example    |
    | ---- | ---- | ---- |
    |  show : `bool`    |  Whether or not to show the figure    |  `show = True` (default)   |
    | title : `str`   |  The overall figure title   | `title = &#34;Today&#39;s results&#34;`    |
    | xlabel : `str`   |  The x axis label   | `xlabel = &#34;My super qPCR samples&#34;`    |
    | ylabel : `str`   |  The y axis label   | `ylabel = &#34;Mean of ddCt&#34;`    |
    |  height : `int`   |   Height of the figure   | `height = 50`    |
    |  width : `int`   |   Width of the figure   | `width = 50`    |
    |  padding : `float or tuple`   |   Padding between subplots. This can be a single float (interpreted as horizontal padding), or a tuple of (horizontal, vertical) paddings.   | `padding = 0.2`    |
    |  template : `str`   | The `plotly` template to use. Check out available templates [here](https://plotly.com/python/templates/).     | `template = &#34;plotly_dark&#34;`    |
    |    headers : `list` |  A list of titles for each subplot in the preview figure    | `headers = [&#34;transcript A&#34;, &#34;transcript B&#34;]`     |
    | legend_title : `str`    | The title to be displayed above the legend   |  `legend_title = &#34;my assays&#34;`   |
    |  hoverinfo : `str`   | The type of hoverinfo to display. By default just `&#34;y&#34;`. Learn more about plotly hoverinfo [here](https://plotly.com/python/hover-text-and-formatting/). Please, note that `hovertemplate` is not currently supported.  | `hoverinfo = &#34;name+y&#34;`    |
    |  **kwargs    | Any additional kwargs that can be passed to `plotly`&#39;s`graphs_objs.Bar()`.     |      |

    &#34;&#34;&#34;
    def __init__(self, mode:str):
        self._setup_default_params(
                                    static = defaults.static_PreviewBars, 
                                    interactive = defaults.interactive_PreviewBars
                                )
        # __init__ is going to require default_params to be already set!
        super().__init__(mode)

    def _static_plot(self, **kwargs):
        &#34;&#34;&#34;
        The static Preview Results Figure
        &#34;&#34;&#34;
        kwargs = self.update_params(kwargs)
        data = self.get()

        ref_col, ncols, nrows, headings, x, y, sterr, query = self._prep_properties(kwargs)       

        title = aux.from_kwargs(&#34;title&#34;, &#34;Results Preview&#34;, kwargs, rm = True)
        headers = aux.from_kwargs(&#34;headers&#34;, None, kwargs, rm = True)
        label_subplots = aux.from_kwargs(&#34;label_subplots&#34;, True, kwargs, rm = True)
        start_character = aux.from_kwargs(&#34;labeltype&#34;, &#34;A&#34;, kwargs, rm = True)
        show_spines = aux.from_kwargs(&#34;frame&#34;, True, kwargs, rm = True)
        show = aux.from_kwargs(&#34;show&#34;, True, kwargs, rm = True)
        rot = aux.from_kwargs(&#34;rot&#34;, None, kwargs, rm = True)

        palette = gx.generate_palette(kwargs)

        # set a seaborn style
        style = aux.from_kwargs(&#34;style&#34;, &#34;ticks&#34;, kwargs, rm = True)
        sns.set_style( style )

        edgecolor = aux.from_kwargs(&#34;edgecolor&#34;, &#34;white&#34;, kwargs, rm = True)
        edgewidth = aux.from_kwargs(&#34;edgewidth&#34;, None, kwargs, rm = True)

        if edgewidth is None: 
            edgewidth = aux.from_kwargs(&#34;linewidth&#34;, 1, kwargs, rm = True) 
        else: 
            aux.from_kwargs(&#34;linewidth&#34;, None, kwargs, rm = True )

        figsize = aux.from_kwargs(&#34;figsize&#34;, None, kwargs, rm = True)
        fig, axs = plt.subplots(nrows = nrows, ncols = ncols, figsize = figsize)
        fig.suptitle( title )

        # setup Coords
        Coords = gx.AxesCoords(fig, axs, (nrows, ncols))
        idx = 0
        for assay in headings: 
            try: 
                q = query.format(ref_col = ref_col, q = assay)
                tmp_df = data.query(q)
                tmp_df = tmp_df.sort_values(&#34;group&#34;)


                # now plot a new bar chart 
                subplot = Coords.subplot()

                tmp_df.plot.bar(
                                x = x, y = y, 
                                ax = subplot,
                                edgecolor = edgecolor,
                                linewidth = edgewidth,
                                color = palette,
                                **kwargs
                            )

                subplot.errorbar(
                                x = tmp_df[x], y = tmp_df[y], 
                                yerr = tmp_df[sterr], 
                                fmt = &#34;.&#34;, markersize = 0, capsize = 3, 
                                ecolor = aux.from_kwargs(&#34;ecolor&#34;, &#34;black&#34;, kwargs),
                            )
            
                subplot.set(
                            title = assay if headers is None else headers[idx],
                            xlabel = aux.from_kwargs(&#34;xlabel&#34;, None, kwargs),
                            ylabel = aux.from_kwargs(&#34;ylabel&#34;, &#34;$\Delta\Delta$Ct&#34;, kwargs),        
                        )

                if rot is not None: 
                    align = &#34;center&#34; if rot == 0 else &#34;left&#34;
                    plt.setp( subplot.xaxis.get_majorticklabels(), rotation = -rot, ha=align, rotation_mode=&#34;anchor&#34;) 

                if not show_spines:
                    subplot.spines[&#34;right&#34;].set_visible(False)
                    subplot.spines[&#34;top&#34;].set_visible(False)
                    subplot.spines[&#34;left&#34;].set_linewidth(1.05)
                    subplot.spines[&#34;bottom&#34;].set_linewidth(1.05)

                # add ABCD... label to subplot
                if label_subplots:
                    self._add_subplot_label(idx, subplot, start_character)         

                Coords.increment()
                idx += 1
            except Exception as e:
                raise e 
                break
        
        plt.tight_layout()

        
        if show:
            plt.show()

        # print(&#34;&lt;&lt;&lt; Static Check &gt;&gt;&gt;&#34;)

        return fig 

    # def _add_subplot_label(self, idx, subplot, start_character):
    #     &#34;&#34;&#34;
    #     Adds A B C ... to upper left corner of a subplot...
    #     It will start labelling at any arbitrary start_character
    #     &#34;&#34;&#34;
    #     subplot_label = chr(ord(start_character)+idx)
    #     subplot.annotate(
    #                 xy = (-0.1,1.03), 
    #                 text = subplot_label, 
    #                 xycoords = &#34;axes fraction&#34;,
    #                 weight = &#34;bold&#34;, fontsize = 12
    #             )

    def _interactive_plot(self, **kwargs):
        &#34;&#34;&#34;
        The interactive Preview Results Figure
        &#34;&#34;&#34;

        kwargs = self.update_params(kwargs)
        data = self.get()

        try: 
            # setup figure framework variables that have to be removed from 
            ref_col, ncols, nrows, headings, x, y, sterr, query = self._prep_properties(kwargs)
            headers = aux.from_kwargs(&#34;headers&#34;, headings, kwargs, rm = True)
            show = aux.from_kwargs(&#34;show&#34;, True, kwargs, rm = True)
            padding = aux.from_kwargs(&#34;padding&#34;, 0.1, kwargs, rm = True)

            if isinstance(padding, (list, tuple)):
                hpad, vpad = padding
            else: 
                hpad, vpad = padding, None

            speclist = gx.make_speclist(nrows, ncols, &#34;xy&#34;)
            fig = make_subplots(
                                    rows = nrows, cols = ncols, 
                                    specs = speclist, 
                                    subplot_titles = headers,
                                    horizontal_spacing = hpad,
                                    vertical_spacing = vpad
                            )


            Coords = gx.AxesCoords(fig, [], (ncols, nrows))

            fig.update_layout(
                        title = aux.from_kwargs(&#34;title&#34;, &#34;Results Preview&#34;, kwargs, rm = True), 
                        height = aux.from_kwargs(&#34;height&#34;, None, kwargs, rm = True), 
                        width = aux.from_kwargs(&#34;width&#34;, None, kwargs, rm = True),
                        margin = {&#34;autoexpand&#34;: True, &#34;pad&#34; : 0, &#34;b&#34;: 1, &#34;t&#34;: 50}, 
                        autosize = True, 
                        template = aux.from_kwargs(&#34;template&#34;, &#34;plotly_white&#34;, kwargs, rm = True),
                        legend = {&#34;title&#34; : aux.from_kwargs(&#34;legend_title&#34;, ref_col, kwargs, rm = True),
                        },
                    )

            # set default axes labels
            xlabel = aux.from_kwargs(&#34;xlabel&#34;, &#34;&#34;, kwargs, rm = True) 
            fig.update_xaxes(title_text = xlabel)
            
            ylabel = aux.from_kwargs(&#34;ylabel&#34;, &#34;DeltaDeltaCt&#34;, kwargs, rm = True) 
            fig.update_yaxes(title_text = ylabel)

            idx = 0
            for assay in headings:
                row, col = Coords.get()
                tmp_df = data.query(query.format(ref_col = ref_col, q = assay))
                tmp_df = tmp_df.sort_values(&#34;group&#34;)

                # now plot a new bar chart 
                fig.add_trace(

                    go.Bar(
                        name = assay,
                        y = tmp_df[y], x = tmp_df[x], 
                        error_y=dict(type=&#39;data&#39;, array = tmp_df[sterr]),
                        hoverinfo = aux.from_kwargs(&#34;hoverinfo&#34;, &#34;y&#34;, kwargs, rm = True), 
                        **kwargs
                    ), 

                    row, col
                )
                Coords.increment()

                idx += 1

            if show:
                fig.show()

            # print(&#34;&lt;&lt;&lt; Interactive Check &gt;&gt;&gt;&#34;)
            return fig 
        except Exception as e: 
            raise e 


class ReplicateBoxPlot(Plotter):
    &#34;&#34;&#34;
    Generate a boxplot figure summary for the input sample replicates.
    

    Note
    ------
    This used to be the core of making filter summary figures. However, this has now
    been replaced by a dedicated `FilterSummary` figure class. Hence, support for linking
    `qpcr.Filters` directly to this figure class will be dropped in a future release!

    Parameters
    ----------
    Filter : qpcr.Filters.Filter
        A qpcr.Filters.Filter object. The Filter can also be set using the `filter()` method.

    mode : str
        The plotting mode (either `&#34;interactive&#34;` or `&#34;static&#34;`).

    Plotting Kwargs
    ----
    
    #### `&#34;static&#34;` Kwargs
    Static ReplicateBoxPlot figures accept the following kwargs:
    
    |   Argument  |  Description    |  Example    |
    | ---- | ---- | ---- |
    |  show : `bool`    |  Whether or not to show the figure    |  `show = True` (default)   |
    |   figsize : `tuple`   |  The figure size    | `figsize = (10, 4)`     |
    |   subplots : `tuple`   |  A tuple specifying the number of colums and rows (in that order) for the figure    | `subplots = (2, 3)`     |
    | title : `str`   |  The overall figure title   | `title = &#34;My assays&#34;    |
    |  style : `str`   | A `seaborn` style to set. Check out available styles [here](https://www.python-graph-gallery.com/104-seaborn-themes).     | `style = &#34;darkgrid&#34;`    |
    |   color : `str or list`   | The fillcolor for the boxes.   | `color = &#34;yellow&#34;`     |
    |  **kwargs    | Any additional kwargs that can be passed to the `seaborn`&#39;s `boxplot()`.     |      |

    &lt;br&gt;&lt;/br&gt;
    #### `&#34;interactive&#34;` Kwargs
    Interactive ReplicateBoxPlot figures accept the following kwargs:

    |   Argument  |  Description    |  Example    |
    | ---- | ---- | ---- |
    |  show : `bool`    |  Whether or not to show the figure    |  `show = True` (default)   |
    | title : `str`   |  The overall figure title   | `title = &#34;My run&#34;`    |
    | ylabel : `str`   |  The y-axis title   | `ylabel = &#34;Raw Ct value&#34;`    |
    |  height : `int`   |   Height of the figure   | `height = 50`    |
    |  width : `int`   |   Width of the figure   | `width = 50`    |
    |  template : `str`   | The `plotly` template to use. Check out available templates [here](https://plotly.com/python/templates/).     | `template = &#34;plotly_dark&#34;`    |
    |  **kwargs    | Any additional kwargs that can be passed to `plotly`&#39;s`graphs_objs.Box()`.     |      |

    &#34;&#34;&#34;
    def __init__(self, Filter = None, mode=&#34;interactive&#34;):
        self._setup_default_params(
                                    static = defaults.static_ReplicateBoxPlot, 
                                    interactive = defaults.interactive_ReplicateBoxPlot
                                )
        # __init__ is going to require default_params to be already set!
        super().__init__(mode=mode)
        self._data = None
        if Filter is not None: 
            wa.SoftWarning(&#34;Versions:Deprecation&#34;, old = &#34;ReplicateBoxPlot for use with Filters&#34;, new = &#34;FilterSummary&#34; )
        self._Filter = Filter
        self._filter_stats = None
    
    # FUTURE DROP HERE
    def filter(self, Filter):
        &#34;&#34;&#34;
        Links a Filter object for which a report figure shall be generated

        Note
        -------
        Support for linking Filters to use this Figure class to visualse Filter Summaries will be 
        dropped in a future release! Use the dedicated `FilterSummary` figure class instead!

        Parameters
        ----------
        Filter : qpcr.Filters.Filter
            A qpcr.Filters.Filter object.

        &#34;&#34;&#34;
        wa.SoftWarning(&#34;Versions:Deprecation&#34;, old = &#34;ReplicateBoxPlot for use with Filters&#34;, new = &#34;FilterSummary&#34; )
        self._Filter = Filter

    def clear(self):
        &#34;&#34;&#34;
        Will clear the currently stored Assay data
        &#34;&#34;&#34;
        self._data = None

    def link(self, Assay:qpcr.Assay):
        &#34;&#34;&#34;
        Links an Assay object to the BoxPlotter.
        This will simply add the Ct column to the current overall data!
        Hence, repeated linking of Assay objects will add data and NOT replace any existing.

        Parameters
        ----------
        Assay : qpcr.Assay
            A qpcr.Assay object.
        &#34;&#34;&#34;
        if aux.same_type(Assay, qpcr.Assay()):
            self._Results = Assay
            data = self._Results.get( copy = True )
        else:
            wa.HardWarning(&#34;Plotter:unknown_data&#34;, obj = Assay)

        # add itentifier column
        data[&#34;assay&#34;] = [self._Results.id() for i in range(len(data))]

        if self._data is None: 
            self._data = data
        else:
            self._data = pd.concat([self._data, data], ignore_index=True)
        

    def _interactive_plot(self, **kwargs):
        &#34;&#34;&#34;
        Generates an interactive Boxplot summary of the input Ct values
        &#34;&#34;&#34;
        kwargs = self.update_params(kwargs)

        show = aux.from_kwargs(&#34;show&#34;, True, kwargs, rm = True)
        template = aux.from_kwargs(&#34;template&#34;, None, kwargs, rm=True)
        title = aux.from_kwargs(&#34;title&#34;, None, kwargs, rm=True)

        data = self._data
    
        groups = aux.sorted_set(data[&#34;group&#34;])
        group_names = aux.sorted_set(data[&#34;group_name&#34;])

        fig = go.Figure()

        fig.update_layout(
                            boxmode=&#34;group&#34;, 
                            height = aux.from_kwargs(&#34;height&#34;, None, kwargs, rm = True), 
                            width = aux.from_kwargs(&#34;width&#34;, None, kwargs, rm = True),
                            template = template, 
                            title = title,
                        )

        # add default ylabel
        ylabel = aux.from_kwargs(&#34;ylabel&#34;, &#34;Ct&#34;, kwargs, rm = True) 
        fig.update_yaxes(title_text = ylabel)

        fig.update_xaxes(showgrid=True)

        for group, name in zip(groups, group_names):
            tmp_df = data.query(f&#34;group == {group}&#34;)
            
            
            fig.add_trace(
                            go.Box(
                                x = tmp_df[&#34;assay&#34;],
                                y = tmp_df[&#34;Ct&#34;],
                                name = name,
                                hoverinfo = &#34;y+name&#34;,
                                **kwargs,
                            ),
                        )

        if show:
            fig.show()

        return fig 


    def _static_plot(self, **kwargs):
        &#34;&#34;&#34;
        Generates a static Boxplot summary of the input Ct values
        &#34;&#34;&#34;
        kwargs = self.update_params(kwargs)
        data = self._data
        
        # set a seaborn style
        style = aux.from_kwargs(&#34;style&#34;, &#34;ticks&#34;, kwargs, rm = True)
        sns.set_style( style )

        show = aux.from_kwargs(&#34;show&#34;, True, kwargs, rm = True)
        figsize = aux.from_kwargs(&#34;figsize&#34;, (7,5), kwargs, rm=True)
        title = aux.from_kwargs(&#34;title&#34;, None, kwargs, rm=True)
        palette = gx.generate_palette(kwargs)
        show_spines = aux.from_kwargs(&#34;frame&#34;, True, kwargs, rm = True)
        ncols, nrows = aux.from_kwargs(&#34;subplots&#34;, gx.make_layout(data, &#34;assay&#34;), kwargs, rm=True)

        fig, axs = plt.subplots(nrows = nrows, ncols = ncols, figsize=figsize)
        
        # possibly nrows and ncols should be switched...
        Coords = gx.AxesCoords(fig, axs, (nrows, ncols))
        
        for assay in aux.sorted_set(data[&#34;assay&#34;]):
            
            try: 
                ax = Coords.subplot()
            except: 
                print(&#34;We ran out of axes ... &#34;)
                break
            tmp = data.query(f&#34;assay == &#39;{assay}&#39;&#34;)

            sns.boxplot(
                        data=tmp, 
                        x = &#34;assay&#34;, y = &#34;Ct&#34;, hue=&#34;group_name&#34;, 
                        palette = palette, 
                        ax = ax, 
                        **kwargs
                    )

            ax.legend(bbox_to_anchor=(1,1), loc = None).remove()
            ax.set(title=assay, xlabel = &#34;&#34;, xticklabels = [],)
            
            if not show_spines:
                sns.despine()

            Coords.increment()

        # add one single legend to the last plot
        ax.legend(bbox_to_anchor=(1,1), loc = None)

        fig.suptitle(title)
        plt.tight_layout()

        if show:
            fig.show()

        return fig 


class FilterSummary(Plotter):
    &#34;&#34;&#34;
    Generates a summary figure of the replicate
    Ct values for each assay before and after filtering.

    Parameters
    ----------
    mode : str
        The plotting mode. May be either &#34;static&#34; (matplotlib) or &#34;interactive&#34; (plotly).


    
    #### `&#34;static&#34;` Kwargs
    Static FilterSummary figures accept the following kwargs:
    
    |   Argument  |  Description    |  Example    |
    | ---- | ---- | ---- |
    |  show : `bool`    |  Whether or not to show the figure    |  `show = True` (default)   |
    |   figsize : `tuple`   |  The figure size    | `figsize = (10, 4)`     |
    |   subplots : `tuple`   |  A tuple specifying the number of colums and rows (in that order) for the figure    | `subplots = (2, 3)`     |
    | title : `str`   |  The overall figure title   | `title = &#34;Today&#39;s run&#34;    |
    | xlabel : `str`| The x-axis label of each subplot | `xlabel = &#34;Conditions&#34;` |
    | ylabel : `str`| The y-axis label of each subplot | `ylabel = &#34;My Ct values&#34;` |
    | rot : `float` | The rotation of x-axis labels | `rot = 0.3` |
    |   frame   : `bool` |  Show left and top spines of subplots (if True)    | `frame = False` (default)     |
    |  style : `str`   | A `seaborn` style to set. Check out available styles [here](https://www.python-graph-gallery.com/104-seaborn-themes).     | `style = &#34;darkgrid&#34;`    |
    |   color : `str or list`   | The color for the boxes.   | `color = [&#34;yellow&#34;, &#34;green&#34;]`     |
    |  **kwargs    | Any additional kwargs that can be passed to the `seaborn`&#39;s `boxplot()`.     |      |
  
    &lt;br&gt;&lt;/br&gt;
    #### `&#34;interactive&#34;` Kwargs
    Interactive FilterSummary figures accept the following kwargs:

    |   Argument  |  Description    |  Example    |
    | ---- | ---- | ---- |
    |  show : `bool`    |  Whether or not to show the figure    |  `show = True` (default)   |
    | title : `str`   |  The overall figure title   | `title = &#34;Today&#39;s run&#34;`    |
    | ylabel : `str`   |  The y axis label   | `ylabel = &#34;Raw Ct values&#34;`    |
    |  height : `int`   |   Height of the figure   | `height = 50`    |
    |  width : `int`   |   Width of the figure   | `width = 50`    |
    |  padding : `float or tuple`   |   Padding between subplots. This can be a single float (interpreted as horizontal padding), or a tuple of (horizontal, vertical) paddings.   | `padding = 0.2`    |
    |  colors : `list`   |   List of two colors for _before_ and _after_ filtering boxes. | `colors = [&#34;red&#34;, &#34;green&#34;]`    |
    |  template : `str`   | The `plotly` template to use. Check out available templates [here](https://plotly.com/python/templates/).     | `template = &#34;plotly_dark&#34;`    |
    |  headers : `list` |  A list of titles for each subplot in the preview figure    | `headers = [&#34;transcript A&#34;, &#34;transcript B&#34;]`     |
    |  hoverinfo : `str`   | The type of hoverinfo to display. By default `&#34;y+x+name&#34;`. Learn more about plotly hoverinfo [here](https://plotly.com/python/hover-text-and-formatting/). Please, note that `hovertemplate` is not currently supported.  | `hoverinfo = &#34;name+y&#34;`    |
    |  **kwargs    | Any additional kwargs that can be passed to `plotly`&#39;s`graphs_objs.Box()`.     |      |


    &#34;&#34;&#34;
    def __init__(self, mode):
        self._setup_default_params(
                                    static = defaults.static_FilterSummary,
                                    interactive = defaults.interactive_FilterSummary
                                )
        super().__init__( mode = mode)
        self._before = qpcr.Results()
        self._after = qpcr.Results()

    def clear(self):
        &#34;&#34;&#34;
        Clears the pre- and post-filtering Ct value records.
        &#34;&#34;&#34;
        self._before = qpcr.Results()
        self._after = qpcr.Results()

    def add_before(self, assay : qpcr.Assay ):
        &#34;&#34;&#34;
        Add a pre-filtered set of Ct values
        from an `qpcr.Assay` object. 

        Parameters
        ----------
        assay : qpcr.Assay
            An `qpcr.Assay` object
        &#34;&#34;&#34;
        # setup groups and stuff information 
        if self._before.is_empty():
            self._before.adopt_names( assay )
            self._after.adopt_names( assay )

        self._before.add_Ct( assay )
    
    def add_after(self, assay : qpcr.Assay ):
        &#34;&#34;&#34;
        Add a post-filtered set of Ct values
        from an `qpcr.Assay` object. 

        Parameters
        ----------
        assay : qpcr.Assay
            An `qpcr.Assay` object
        &#34;&#34;&#34;
        self._after.add_Ct( assay )


    def _interactive_plot(self, **kwargs):
        &#34;&#34;&#34;
        Generates an interactive Filter Summary Figure
        &#34;&#34;&#34;
        kwargs = self.update_params(kwargs)

        show = aux.from_kwargs(&#34;show&#34;, True, kwargs, rm = True)
        template = aux.from_kwargs(&#34;template&#34;, None, kwargs, rm=True)
        title = aux.from_kwargs(&#34;title&#34;, None, kwargs, rm=True)
        padding = aux.from_kwargs(&#34;padding&#34;, 0.1, kwargs, rm = True)
        
        # setup color scheme
        colors = aux.from_kwargs(&#34;colors&#34;, [&#34;blue&#34;, &#34;crimson&#34;], kwargs, rm = True)
        before_color, after_color = colors

        if isinstance(padding, (list, tuple)):
            hpad, vpad = padding
        else: 
            hpad, vpad = padding, None

        # get the data
        before = self._before.get()
        after = self._after.get()

        # get the number of assays to visualse
        assays = [ i for i in before.columns if i not in [ &#34;group&#34;, &#34;group_name&#34;, raw_col_names[0]] ]
        headers = aux.from_kwargs(&#34;headers&#34;, assays, kwargs, rm = True)

        # each assay will be on its own plot,
        ncols, nrows = gx.make_layout_from_list( assays )
        
        speclist = gx.make_speclist(nrows, ncols, &#34;xy&#34;)
        fig = make_subplots(
                                rows = nrows, cols = ncols, 
                                specs = speclist, 
                                subplot_titles = headers,
                                horizontal_spacing = hpad,
                                vertical_spacing = vpad,
                                # sharex = True
                        )
        
        fig.update_layout(
                            boxmode=&#34;group&#34;, 
                            height = aux.from_kwargs(&#34;height&#34;, None, kwargs, rm = True), 
                            width = aux.from_kwargs(&#34;width&#34;, None, kwargs, rm = True),
                            template = template, 
                            title = title,
                        )

        # add default ylabel
        ylabel = aux.from_kwargs(&#34;ylabel&#34;, &#34;Ct&#34;, kwargs, rm = True) 
        fig.update_yaxes(title_text = ylabel)
        
        Coords = gx.AxesCoords(fig, [], (ncols, nrows))

        show_legend = True
        # now iterate over each assay and make a BoxPlot
        for assay in assays : 
            
            # get before and after filter datasets for each assay
            pre_Cts = before[ [&#34;group&#34;, &#34;group_name&#34;, assay] ]
            post_Cts = after[ [&#34;group&#34;, &#34;group_name&#34;, assay] ]
            
            row, col = Coords.get()

            # pre-filter boxes 
            fig.add_trace(
                            go.Box(
                                x = pre_Cts[&#34;group_name&#34;],
                                y = pre_Cts[ assay ],
                                name = &#34;Before&#34;,
                                hoverinfo = &#34;y+x+name&#34;,
                                marker_color = before_color,
                                legendgroup=&#39;group1&#39;,
                                showlegend = show_legend,
                                **kwargs,
                            ),
                            row, col
                        )
            # post-filter boxes
            fig.add_trace(
                            go.Box(
                                x = post_Cts[&#34;group_name&#34;],
                                y = post_Cts[ assay ],
                                name = &#34;After&#34;,
                                hoverinfo = &#34;y+x+name&#34;,
                                marker_color = after_color,
                                legendgroup=&#39;group2&#39;,
                                showlegend = show_legend,
                                **kwargs,
                            ),
                            row, col
                        )

            Coords.increment()

            # set show_legend to False after the first assay,
            # to avoid repetitive legends...
            show_legend = False

        fig.update_layout( showlegend = True )
        if show:
            fig.show()

        return fig 


    def _static_plot(self, **kwargs):
        &#34;&#34;&#34;
        Generates a static Filter Summary Fig
        &#34;&#34;&#34;
        kwargs = self.update_params(kwargs)

        show = aux.from_kwargs(&#34;show&#34;, True, kwargs, rm = True)
        figsize = aux.from_kwargs(&#34;figsize&#34;, (7,5), kwargs, rm=True)
        title = aux.from_kwargs(&#34;title&#34;, None, kwargs, rm=True)
        ylabel = aux.from_kwargs(&#34;ylabel&#34;, &#34;Ct&#34;, kwargs, rm = True)
        xlabel = aux.from_kwargs(&#34;xlabel&#34;, &#34;&#34;, kwargs, rm = True)
        rot = aux.from_kwargs(&#34;rot&#34;,None, kwargs, rm = True)
        show_spines = aux.from_kwargs(&#34;frame&#34;, True, kwargs, rm = True)
        palette = gx.generate_palette(kwargs)

        # set a seaborn style
        style = aux.from_kwargs(&#34;style&#34;, &#34;ticks&#34;, kwargs, rm = True)
        sns.set_style( style )

        # get the data
        before = self._before.get()
        after = self._after.get()

        # get the number of assays to visualse
        assays = [ i for i in before.columns if i not in [ &#34;group&#34;, &#34;group_name&#34;, raw_col_names[0]] ]
        headers = aux.from_kwargs(&#34;headers&#34;, assays, kwargs, rm = True)

        # each assay will be on its own plot
        ncols, nrows = gx.make_layout_from_list( assays )

        ncols, nrows = aux.from_kwargs(&#34;subplots&#34;, (ncols, nrows), kwargs, rm=True)


        fig, axs = plt.subplots(nrows = nrows, ncols = ncols, figsize=figsize)
        
        # possibly nrows and ncols should be switched...
        Coords = gx.AxesCoords(fig, axs, (nrows, ncols))

        # set a kind column for grouping in the boxplots
        before[ &#34;kind&#34; ] = &#34;before&#34; 
        after[ &#34;kind&#34; ] = &#34;after&#34;

        show_legend = True
        for assay, header in zip( assays, headers ): 

            # get before and after filter datasets for each assay
            pre_Cts = before[ [&#34;group&#34;, &#34;group_name&#34;, &#34;kind&#34;, assay] ]
            post_Cts = after[ [&#34;group&#34;, &#34;group_name&#34;, &#34;kind&#34;, assay] ]

            # assemble data to one dataframe
            df = pd.concat( (pre_Cts, post_Cts) )

            # get the new subplot
            try: 
                ax = Coords.subplot()
            except: 
                print(&#34;We ran out of axes ... &#34;)
                break

            # main box plot
            sns.boxplot(
                        data = df, 
                        x = &#34;group_name&#34;,
                        y = assay,
                        hue = &#34;kind&#34;,
                        palette = palette, 
                        ax = ax,
                        **kwargs
                    )
            
            # format the subplot
            ax.set(title = header, ylabel = ylabel, xlabel = xlabel)
            if rot is not None and rot != 0 :
                plt.setp( ax.xaxis.get_majorticklabels(), rotation = -rot, ha=&#34;left&#34;, rotation_mode=&#34;anchor&#34;) 
            if not show_legend: 
                ax.legend().remove()
            else:
                ax.legend( bbox_to_anchor=(1,1), loc = None, frameon = False )
            show_legend = False

            Coords.increment()

        if not show_spines: 
            sns.despine()

        fig.suptitle(title)

        plt.tight_layout()
        if show: 
            plt.show()

        return fig


class AssayDots(Plotter):
    &#34;&#34;&#34;
    Generate a Preview of all results from all Assays in subplots, plotting individual values
    in a Dot Plot rather than Bar Plot. Each assay will be shown in a separate subplot.

    Parameters
    ----------
    mode : str
        The plotting mode. May be either &#34;static&#34; (matplotlib) or &#34;interactive&#34; (plotly).


    Plotting Kwargs
    ----
    
    #### `&#34;static&#34;` Kwargs
    Static AssayDots figures accept the following kwargs:
    
    |   Argument  |  Description    |  Example    |
    | ---- | ---- | ---- |
    |  show : `bool`    |  Whether or not to show the figure    |  `show = True` (default)   |
    |   figsize : `tuple`   |  The figure size    | `figsize = (10, 4)`     |
    | title : `str`   |  The overall figure title   | `title = &#34;Today&#39;s results&#34;    |
    | xlabel : `str`| The x-axis label of each subplot | `xlabel = &#34;Conditions&#34;` |
    | ylabel : `str`| The y-axis label of each subplot | `ylabel = &#34;Mean $\Delta\Delta Ct$&#34;` |
    | rot : `float` | The rotation of x-axis labels | `rot = 0.3` |
    |    headers : `list` |  A list of titles for each subplot in the preview figure    | `headers = [&#34;transcript A&#34;, &#34;transcript B&#34;]`     |
    |  label_subplots  : `bool`   |   Add each subplot with A, B, C ... (if True, default)   | `label_subplots = True` (default)     |
    | labeltype : `str`| The starting character for subplot labelling. By default an `&#34;A&#34;`. | `labeltype = &#34;a&#34;` |
    |   frame   : `bool` |  Show left and top spines of subplots (if True)    | `frame = False` (default)     |
    |   violin   : `bool` |  Show symmetric kde of the dots of each group (if True).   | `violin = False`    |
    |   color : `str or list`   | The fillcolor for the individual dots from replicate groups   | `color = &#34;yellow&#34;`     |
    |  style : `str`   | A `seaborn` style to set. Check out available styles [here](https://www.python-graph-gallery.com/104-seaborn-themes).     | `style = &#34;darkgrid&#34;`    |
    |  **kwargs    | Any additional kwargs that can be passed to the `seaborn`&#39;s `stripplot`.     |      |

    &lt;br&gt;&lt;/br&gt;
    #### `&#34;interactive&#34;` Kwargs
    Interactive AssayDots figures accept the following kwargs:

    |   Argument  |  Description    |  Example    |
    | ---- | ---- | ---- |
    |  show : `bool`    |  Whether or not to show the figure    |  `show = True` (default)   |
    | title : `str`   |  The overall figure title   | `title = &#34;Today&#39;s results&#34;`    |
    | xlabel : `str`   |  The x axis label   | `xlabel = &#34;My super qPCR samples&#34;`    |
    | ylabel : `str`   |  The y axis label   | `ylabel = &#34;Mean of ddCt&#34;`    |
    |  height : `int`   |   Height of the figure   | `height = 50`    |
    |  width : `int`   |   Width of the figure   | `width = 50`    |
    |  padding : `float or tuple`   |   Padding between subplots. This can be a single float (interpreted as horizontal padding), or a tuple of (horizontal, vertical) paddings.   | `padding = 0.2`    |
    |  template : `str`   | The `plotly` template to use. Check out available templates [here](https://plotly.com/python/templates/).     | `template = &#34;plotly_dark&#34;`    |
    |    headers : `list` |  A list of titles for each subplot in the preview figure    | `headers = [&#34;transcript A&#34;, &#34;transcript B&#34;]`     |
    |   violin   : `bool` |  Show symmetric kde of the dots of each group (if True).   | `violin = False`    |
    |  hoverinfo : `str`   | The type of hoverinfo to display. By default just `&#34;y&#34;`. Learn more about plotly hoverinfo [here](https://plotly.com/python/hover-text-and-formatting/). Please, note that `hovertemplate` is not currently supported.  | `hoverinfo = &#34;name+y&#34;`    |
    |  **kwargs    | Any additional kwargs that can be passed to `plotly`&#39;s`graphs_objs.Violin()`.     |      |

    &#34;&#34;&#34;
    def __init__(self, mode:str):
        self._setup_default_params(
                                    static = defaults.static_PreviewDots, 
                                    interactive = defaults.interactive_PreviewDots
                                )
        # __init__ is going to require default_params to be already set!
        super().__init__(mode)

    def _static_plot(self, **kwargs):
        &#34;&#34;&#34;
        The static Preview Results Figure
        &#34;&#34;&#34;

        kwargs = self.update_params(kwargs)
        data = self._rep_data

        # get assays to plot
        assays = [ i for i in data.columns if i not in [ &#34;group&#34;, &#34;group_name&#34;, raw_col_names[0] ] ]

        # generate subplot layout
        ncols, nrows = gx.make_layout_from_list( assays )

        # get kwargs incompatible with the main plotting method
        title = aux.from_kwargs(&#34;title&#34;, None, kwargs, rm = True)
        headers = aux.from_kwargs(&#34;headers&#34;, assays, kwargs, rm = True)
        label_subplots = aux.from_kwargs(&#34;label_subplots&#34;, True, kwargs, rm = True)
        start_character = aux.from_kwargs(&#34;labeltype&#34;, &#34;A&#34;, kwargs, rm = True)
        show_spines = aux.from_kwargs(&#34;frame&#34;, True, kwargs, rm = True)
        show = aux.from_kwargs(&#34;show&#34;, True, kwargs, rm = True)
        show_violins = aux.from_kwargs(&#34;violin&#34;, True, kwargs, rm = True)
        rot = aux.from_kwargs(&#34;rot&#34;, None, kwargs, rm = True)
        alpha = aux.from_kwargs(&#34;alpha&#34;, 1, kwargs, rm = True)
        xlabel = aux.from_kwargs(&#34;xlabel&#34;, None, kwargs, rm = True)
        ylabel = aux.from_kwargs(&#34;ylabel&#34;, None, kwargs, rm = True)

        # generate a custom color palette in case color kwarg is provided
        palette = gx.generate_palette(kwargs)

        # set a seaborn style
        style = aux.from_kwargs(&#34;style&#34;, &#34;dark&#34;, kwargs, rm = True)
        sns.set_style( style )

        # make figure
        figsize = aux.from_kwargs(&#34;figsize&#34;, None, kwargs, rm = True)
        fig, axs = plt.subplots(nrows = nrows, ncols = ncols, figsize = figsize)
        fig.suptitle( title )

        # setup Coords
        Coords = gx.AxesCoords(fig, axs, (nrows, ncols))
        idx = 0
        for assay in assays: 

            try: 
                tmp_df = data[ [&#34;group&#34;, &#34;group_name&#34;, assay] ]
                tmp_df = tmp_df.sort_values(&#34;group&#34;)

                # now plot a new violin chart 
                subplot = Coords.subplot()

                if show_violins:
                    sns.violinplot(
                                    x = tmp_df[&#34;group_name&#34;],
                                    y = tmp_df[ assay ],
                                    color = None,
                                    inner = None, 
                                    palette = palette,
                                    ax = subplot,

                                )
                    for i in subplot.collections:
                        i.set_alpha( alpha * 0.3 )

                sns.stripplot(
                                x = tmp_df[&#34;group_name&#34;],
                                y = tmp_df[ assay ],
                                palette = palette,
                                alpha = alpha,
                                ax = subplot,
                                **kwargs
                            )
            
                subplot.set(
                            title = assay if headers is None else headers[idx],
                            xlabel = xlabel,
                            ylabel = ylabel,        
                        )

                # adjust xtick rotation   
                if rot is not None: 
                    align = &#34;center&#34; if rot == 0 else &#34;left&#34;
                    plt.setp( subplot.xaxis.get_majorticklabels(), rotation = -rot, ha=align, rotation_mode=&#34;anchor&#34;) 

                if not show_spines:
                    subplot.spines[&#34;right&#34;].set_visible(False)
                    subplot.spines[&#34;top&#34;].set_visible(False)
                    subplot.spines[&#34;left&#34;].set_linewidth(1.05)
                    subplot.spines[&#34;bottom&#34;].set_linewidth(1.05)

                # add ABCD... label to subplot
                if label_subplots:
                    self._add_subplot_label(idx, subplot, start_character)         

                Coords.increment()
                idx += 1
            except Exception as e:
                raise e 
                break
        
        plt.tight_layout()

        if show:
            plt.show()

        # print(&#34;&lt;&lt;&lt; Static Check &gt;&gt;&gt;&#34;)

        return fig 

    def _add_subplot_label(self, idx, subplot, start_character):
        &#34;&#34;&#34;
        Adds A B C ... to upper left corner of a subplot...
        It will start labelling at any arbitrary start_character
        &#34;&#34;&#34;
        subplot_label = chr(ord(start_character)+idx)
        subplot.annotate(
                            xy = (-0.1,1.03), 
                            text = subplot_label, 
                            xycoords = &#34;axes fraction&#34;,
                            weight = &#34;bold&#34;, fontsize = 12
                        )

    def _interactive_plot(self, **kwargs):
        &#34;&#34;&#34;
        The interactive Preview Results Figure
        &#34;&#34;&#34;

        kwargs = self.update_params(kwargs)
        data = self._rep_data

        # get assays to plot
        assays = [ i for i in data.columns if i not in [ &#34;group&#34;, &#34;group_name&#34;, raw_col_names[0] ] ]
        
        # get the info of groups present in the data
        # for later use as xtick labels
        group_names = data[ [&#34;group&#34;, &#34;group_name&#34;] ]
        group_names = group_names.sort_values( &#34;group&#34; )
        group_names = aux.sorted_set( group_names[ &#34;group_name&#34;] )
        ticks = np.arange( len(group_names) )

        # make subplot layout
        ncols, nrows = gx.make_layout_from_list( assays )

        try: 
            # get incompaltible kwargs 
            headers = aux.from_kwargs(&#34;headers&#34;, assays, kwargs, rm = True)
            show = aux.from_kwargs(&#34;show&#34;, True, kwargs, rm = True)
            show_violins = aux.from_kwargs(&#34;violin&#34;, True, kwargs, rm = True)

            # setup padding
            padding = aux.from_kwargs(&#34;padding&#34;, 0.1, kwargs, rm = True)
            if isinstance(padding, (list, tuple)):
                hpad, vpad = padding
            else: 
                hpad, vpad = padding, None

            # make figure
            speclist = gx.make_speclist(nrows, ncols, &#34;xy&#34;)
            fig = make_subplots(
                                    rows = nrows, cols = ncols, 
                                    specs = speclist, 
                                    subplot_titles = headers,
                                    horizontal_spacing = hpad,
                                    vertical_spacing = vpad
                            )

            # setup subplot coords handling
            Coords = gx.AxesCoords(fig, [], (ncols, nrows))

            # setup figure
            fig.update_layout(
                                title = aux.from_kwargs(&#34;title&#34;, &#34;Results Preview&#34;, kwargs, rm = True), 
                                height = aux.from_kwargs(&#34;height&#34;, None, kwargs, rm = True), 
                                width = aux.from_kwargs(&#34;width&#34;, None, kwargs, rm = True),
                                margin = {&#34;autoexpand&#34;: True, &#34;pad&#34; : 0, &#34;b&#34;: 1, &#34;t&#34;: 50}, 
                                autosize = True, 
                                template = aux.from_kwargs(&#34;template&#34;, &#34;plotly_white&#34;, kwargs, rm = True),
                                # legend = {  &#34;title&#34; : aux.from_kwargs(&#34;legend_title&#34;, &#34;Assay&#34;, kwargs, rm = True),  },
                                showlegend = False
                            )

            # set default axes labels
            xlabel = aux.from_kwargs(&#34;xlabel&#34;, &#34;&#34;, kwargs, rm = True) 
            fig.update_xaxes(title_text = xlabel)
            
            ylabel = aux.from_kwargs(&#34;ylabel&#34;, &#34;&#34;, kwargs, rm = True) 
            fig.update_yaxes(title_text = ylabel)

            idx = 0
            for assay, header in zip( assays, headers ):
                
                row, col = Coords.get()

                tmp_df = data[ [&#34;group&#34;, &#34;group_name&#34;, assay] ]
                tmp_df = tmp_df.sort_values(&#34;group&#34;)

                # now plot a new violin chart 
                fig.add_trace(

                    go.Violin(
                                    name = header,
                                    y = tmp_df[ assay ], x = tmp_df[ &#34;group&#34; ], 
                                    points = &#34;all&#34;,
                                    pointpos = 0,
                                    hoverinfo = aux.from_kwargs(&#34;hoverinfo&#34;, &#34;y&#34;, kwargs, rm = True), 
                                    **kwargs
                            ), 
                                    row, col
                        )

                # remove violins if not desired (leaving only dot plot)
                if not show_violins: 
                    fig.update_traces(
                                        fillcolor=&#34;rgba(0,0,0,0)&#34;, 
                                        line_width = 0, 
                                        selector=dict(type=&#39;violin&#39;),
                                    )


                # update x axis to categorical group names
                fig.update_layout(
                                    { 
                                        f&#34;xaxis{idx+1}&#34; : dict(
                                                                tickmode = &#39;array&#39;,
                                                                tickvals = ticks,
                                                                ticktext = group_names,
                                                        )         
                                    }
                                )

                Coords.increment()

                idx += 1

            if show:
                fig.show()

            # print(&#34;&lt;&lt;&lt; Interactive Check &gt;&gt;&gt;&#34;)
            return fig 
        except Exception as e: 
            raise e 


class GroupBars(Plotter):
    &#34;&#34;&#34;
    Generates a Bar plot figure with a separate subplot for each group. 

    Parameters
    ----------
    mode : str
        The plotting mode. May be either &#34;static&#34; (matplotlib) or &#34;interactive&#34; (plotly).

    Plotting Kwargs
    ----
    
    #### `&#34;static&#34;` Kwargs
    Static GroupBars figures accept the following kwargs:
    
    |   Argument  |  Description    |  Example    |
    | ---- | ---- | ---- |
    |  show : `bool`    |  Whether or not to show the figure    |  `show = True` (default)   |
    |   figsize : `tuple`   |  The figure size    | `figsize = (10, 4)`     |
    | title : `str`   |  The overall figure title   | `title = &#34;Today&#39;s results&#34;    |
    | xlabel : `str`| The x-axis label of each subplot | `xlabel = &#34;Conditions&#34;` |
    | ylabel : `str`| The y-axis label of each subplot | `ylabel = &#34;Mean $\Delta\Delta Ct$&#34;` |
    | rot : `float` | The rotation of x-axis labels | `rot = 0.3` |
    |    headers : `list` |  A list of titles for each subplot in the preview figure    | `headers = [&#34;transcript A&#34;, &#34;transcript B&#34;]`     |
    |  label_subplots  : `bool`   |   Add each subplot with A, B, C ... (if True, default)   | `label_subplots = True` (default)     |
    | labeltype : `str`| The starting character for subplot labelling. By default an `&#34;A&#34;`. | `labeltype = &#34;a&#34;` |
    |   frame   : `bool` |  Show left and top spines of subplots (if True)    | `frame = False` (default)     |
    |   color : `str or list`   | The fillcolor for the individual bars   | `color = &#34;yellow&#34;`     |
    |  style : `str`   | A `seaborn` style to set. Check out available styles [here](https://www.python-graph-gallery.com/104-seaborn-themes).     | `style = &#34;darkgrid&#34;`    |
    |   edgecolor : `str or list`   | The edgecolor for the individual bars   | `edgecolor = &#34;black&#34;`     |
    |   edgewidth : `float`   |  The width of the edge of individual bars  | `edgewidth = 0.5`     |
    |  ecolor : `str`    |   The color of errorbars   |  `ecolor = &#34;orange&#34;`    |
    |  **kwargs    | Any additional kwargs that can be passed to the `matplotlib`-backend pandas `.plot.bar()` API.     |      |

    &lt;br&gt;&lt;/br&gt;
    #### `&#34;interactive&#34;` Kwargs
    Interactive GroupBars figures accept the following kwargs:

    |   Argument  |  Description    |  Example    |
    | ---- | ---- | ---- |
    |  show : `bool`    |  Whether or not to show the figure    |  `show = True` (default)   |
    | title : `str`   |  The overall figure title   | `title = &#34;Today&#39;s results&#34;`    |
    | xlabel : `str`   |  The x axis label   | `xlabel = &#34;My super qPCR samples&#34;`    |
    | ylabel : `str`   |  The y axis label   | `ylabel = &#34;Mean of ddCt&#34;`    |
    |  height : `int`   |   Height of the figure   | `height = 50`    |
    |  width : `int`   |   Width of the figure   | `width = 50`    |
    |  padding : `float or tuple`   |   Padding between subplots. This can be a single float (interpreted as horizontal padding), or a tuple of (horizontal, vertical) paddings.   | `padding = 0.2`    |
    |  template : `str`   | The `plotly` template to use. Check out available templates [here](https://plotly.com/python/templates/).     | `template = &#34;plotly_dark&#34;`    |
    |    headers : `list` |  A list of titles for each subplot in the preview figure    | `headers = [&#34;transcript A&#34;, &#34;transcript B&#34;]`     |
    | legend_title : `str`    | The title to be displayed above the legend   |  `legend_title = &#34;my assays&#34;`   |
    |  hoverinfo : `str`   | The type of hoverinfo to display. By default just `&#34;y&#34;`. Learn more about plotly hoverinfo [here](https://plotly.com/python/hover-text-and-formatting/). Please, note that `hovertemplate` is not currently supported.  | `hoverinfo = &#34;name+y&#34;`    |
    |  **kwargs    | Any additional kwargs that can be passed to `plotly`&#39;s`graphs_objs.Bar()`.     |      |

    &#34;&#34;&#34;
    def __init__(self, mode : str):
        self._setup_default_params(
                                    static = defaults.static_PreviewBars, 
                                    interactive = defaults.interactive_PreviewBars
                                )
        super().__init__( mode = mode )
    
    
    def _static_plot(self, **kwargs):
        &#34;&#34;&#34;
        Generate a static figure
        &#34;&#34;&#34;

        kwargs = self.update_params(kwargs)
        data = self.get()
        groups = data[&#34;group&#34;].unique()
        names = data[&#34;group_name&#34;].unique()

        ref_col, ncols, nrows, headings, x, y, sterr, query = self._prep_properties(kwargs)
        x = &#34;assay&#34; 

        title = aux.from_kwargs(&#34;title&#34;, &#34;Results Preview&#34;, kwargs, rm = True)
        headers = aux.from_kwargs(&#34;headers&#34;, names, kwargs, rm = True)
        label_subplots = aux.from_kwargs(&#34;label_subplots&#34;, True, kwargs, rm = True)
        start_character = aux.from_kwargs(&#34;labeltype&#34;, &#34;A&#34;, kwargs, rm = True)
        show_spines = aux.from_kwargs(&#34;frame&#34;, True, kwargs, rm = True)
        show = aux.from_kwargs(&#34;show&#34;, True, kwargs, rm = True)
        rot = aux.from_kwargs(&#34;rot&#34;, None, kwargs, rm = True)

        palette = gx.generate_palette(kwargs)

        xlabel = aux.from_kwargs(&#34;xlabel&#34;, None, kwargs, rm = True)
        ylabel = aux.from_kwargs(&#34;ylabel&#34;, &#34;$\Delta\Delta$Ct&#34;, kwargs, rm = True)
        # set a seaborn style
        style = aux.from_kwargs(&#34;style&#34;, &#34;ticks&#34;, kwargs, rm = True)
        sns.set_style( style )

        edgecolor = aux.from_kwargs(&#34;edgecolor&#34;, &#34;white&#34;, kwargs, rm = True)
        edgewidth = aux.from_kwargs(&#34;linewidth&#34;, 1, kwargs, rm = True)
        edgewidth = aux.from_kwargs(&#34;edgewidth&#34;, edgewidth, kwargs, rm = True)
        figsize = aux.from_kwargs(&#34;figsize&#34;, None, kwargs, rm = True)

        groups = data[&#34;group&#34;].unique()
        nrows, ncols = gx.make_layout_from_list( groups )
        
        fig, axs = plt.subplots( ncols, nrows, figsize = figsize )
        fig.suptitle( title )

        coords = gx.AxesCoords( fig, axs, (ncols, nrows) )

        idx = 0 
        for group, name in zip(groups, headers): 

            ax = coords.subplot()
            
            tmp_df = data.query( f&#34;group == {group}&#34; )
            tmp_df = tmp_df.sort_values( x )

            tmp_df.plot.bar(
                        x = x, 
                        y = y,
                        # yerr = &#34;stdev&#34;,
                        color = palette,
                        edgecolor = edgecolor,
                        linewidth = edgewidth,
                        ax = ax,
                        **kwargs
                    )

            ax.errorbar(
                            x = tmp_df[x], y = tmp_df[y], 
                            yerr = tmp_df[sterr], 
                            fmt = &#34;.&#34;, markersize = 0, capsize = 3, 
                            ecolor = aux.from_kwargs(&#34;ecolor&#34;, &#34;black&#34;, kwargs),
                    )
            
            ax.set(
                            title = name,
                            xlabel = xlabel,
                            ylabel = ylabel,        
                )

            if rot is not None: 
                align = &#34;center&#34; if rot == 0 else &#34;left&#34;
                plt.setp( ax.xaxis.get_majorticklabels(), rotation = -rot, ha=align, rotation_mode=&#34;anchor&#34;) 


            if not show_spines:
                ax.spines[&#34;right&#34;].set_visible(False)
                ax.spines[&#34;top&#34;].set_visible(False)
                ax.spines[&#34;left&#34;].set_linewidth(1.05)
                ax.spines[&#34;bottom&#34;].set_linewidth(1.05)

                # add ABCD... label to subplot
                if label_subplots:
                    self._add_subplot_label(idx, ax, start_character)         

            coords.increment()
            idx += 1

        plt.tight_layout()

        if show:
            plt.show()
        
        return fig 


    def _interactive_plot(self, **kwargs):
        &#34;&#34;&#34;
        The interactive Preview Results Figure
        &#34;&#34;&#34;

        kwargs = self.update_params(kwargs)
        data = self.get()
        groups = data[&#34;group&#34;].unique()
        names = data[&#34;group_name&#34;].unique()

        try: 
            # setup figure framework variables that have to be removed from 
            ref_col, ncols, nrows, headings, x, y, sterr, query = self._prep_properties(kwargs)
            x = &#34;assay&#34;
            headers = aux.from_kwargs(&#34;headers&#34;, names, kwargs, rm = True)
            show = aux.from_kwargs(&#34;show&#34;, True, kwargs, rm = True)
            padding = aux.from_kwargs(&#34;padding&#34;, 0.1, kwargs, rm = True)

            if isinstance(padding, (list, tuple)):
                hpad, vpad = padding
            else: 
                hpad, vpad = padding, None

            # make new ncols and nrows based on the groups list
            nrows, ncols = gx.make_layout_from_list(groups)

            speclist = gx.make_speclist(nrows, ncols, &#34;xy&#34;)
            fig = make_subplots(
                                    rows = nrows, cols = ncols, 
                                    specs = speclist, 
                                    subplot_titles = headers,
                                    horizontal_spacing = hpad,
                                    vertical_spacing = vpad
                            )


            Coords = gx.AxesCoords(fig, [], (ncols, nrows))

            fig.update_layout(
                        title = aux.from_kwargs(&#34;title&#34;, &#34;Results Preview&#34;, kwargs, rm = True), 
                        height = aux.from_kwargs(&#34;height&#34;, None, kwargs, rm = True), 
                        width = aux.from_kwargs(&#34;width&#34;, None, kwargs, rm = True),
                        margin = {&#34;autoexpand&#34;: True, &#34;pad&#34; : 0, &#34;b&#34;: 1, &#34;t&#34;: 50}, 
                        autosize = True, 
                        template = aux.from_kwargs(&#34;template&#34;, &#34;plotly_white&#34;, kwargs, rm = True),
                        legend = {&#34;title&#34; : aux.from_kwargs(&#34;legend_title&#34;, &#34;group name&#34;, kwargs, rm = True),
                        },
                    )

            # set default axes labels
            xlabel = aux.from_kwargs(&#34;xlabel&#34;, &#34;&#34;, kwargs, rm = True) 
            fig.update_xaxes(title_text = xlabel)
            
            ylabel = aux.from_kwargs(&#34;ylabel&#34;, &#34;DeltaDeltaCt&#34;, kwargs, rm = True) 
            fig.update_yaxes(title_text = ylabel)

            idx = 0
            for group, name in zip( groups, names ):
                row, col = Coords.get()
                tmp_df = data.query(f&#34;group == {group}&#34;)
                tmp_df = tmp_df.sort_values( x )

                # now plot a new bar chart 
                fig.add_trace(

                    go.Bar(
                        name = name,
                        y = tmp_df[y], x = tmp_df[x], 
                        error_y=dict(type=&#39;data&#39;, array = tmp_df[sterr]),
                        hoverinfo = aux.from_kwargs(&#34;hoverinfo&#34;, &#34;y&#34;, kwargs, rm = True), 
                        **kwargs
                    ), 

                    row, col
                )
                Coords.increment()

                idx += 1

            if show:
                fig.show()

            # print(&#34;&lt;&lt;&lt; Interactive Check &gt;&gt;&gt;&#34;)
            return fig 
        except Exception as e: 
            raise e 





class GroupDots(Plotter):
    &#34;&#34;&#34;
    Generate a Preview of all results from all Assays in subplots, plotting individual values
    in a Dot Plot rather than Bar Plot.

    Parameters
    ----------
    mode : str
        The plotting mode. May be either &#34;static&#34; (matplotlib) or &#34;interactive&#34; (plotly).


    Plotting Kwargs
    ----
    
    #### `&#34;static&#34;` Kwargs
    Static GroupDots figures accept the following kwargs:
    
    |   Argument  |  Description    |  Example    |
    | ---- | ---- | ---- |
    |  show : `bool`    |  Whether or not to show the figure    |  `show = True` (default)   |
    |   figsize : `tuple`   |  The figure size    | `figsize = (10, 4)`     |
    | title : `str`   |  The overall figure title   | `title = &#34;Today&#39;s results&#34;    |
    | xlabel : `str`| The x-axis label of each subplot | `xlabel = &#34;Conditions&#34;` |
    | ylabel : `str`| The y-axis label of each subplot | `ylabel = &#34;Mean $\Delta\Delta Ct$&#34;` |
    | rot : `float` | The rotation of x-axis labels | `rot = 0.3` |
    |    headers : `list` |  A list of titles for each subplot in the preview figure    | `headers = [&#34;transcript A&#34;, &#34;transcript B&#34;]`     |
    |  label_subplots  : `bool`   |   Add each subplot with A, B, C ... (if True, default)   | `label_subplots = True` (default)     |
    | labeltype : `str`| The starting character for subplot labelling. By default an `&#34;A&#34;`. | `labeltype = &#34;a&#34;` |
    |   frame   : `bool` |  Show left and top spines of subplots (if True)    | `frame = False` (default)     |
    |   violin   : `bool` |  Show symmetric kde of the dots of each group (if True).   | `violin = False`    |
    |   color : `str or list`   | The fillcolor for the individual dots from replicate groups   | `color = &#34;yellow&#34;`     |
    |  style : `str`   | A `seaborn` style to set. Check out available styles [here](https://www.python-graph-gallery.com/104-seaborn-themes).     | `style = &#34;darkgrid&#34;`    |
    |  **kwargs    | Any additional kwargs that can be passed to the `seaborn`&#39;s `stripplot()`.     |      |

    &lt;br&gt;&lt;/br&gt;
    #### `&#34;interactive&#34;` Kwargs
    Interactive GroupDots figures accept the following kwargs:

    |   Argument  |  Description    |  Example    |
    | ---- | ---- | ---- |
    |  show : `bool`    |  Whether or not to show the figure    |  `show = True` (default)   |
    | title : `str`   |  The overall figure title   | `title = &#34;Today&#39;s results&#34;`    |
    | xlabel : `str`   |  The x axis label   | `xlabel = &#34;My super qPCR samples&#34;`    |
    | ylabel : `str`   |  The y axis label   | `ylabel = &#34;Mean of ddCt&#34;`    |
    |  height : `int`   |   Height of the figure   | `height = 50`    |
    |  width : `int`   |   Width of the figure   | `width = 50`    |
    |  padding : `float or tuple`   |   Padding between subplots. This can be a single float (interpreted as horizontal padding), or a tuple of (horizontal, vertical) paddings.   | `padding = 0.2`    |
    |  template : `str`   | The `plotly` template to use. Check out available templates [here](https://plotly.com/python/templates/).     | `template = &#34;plotly_dark&#34;`    |
    |    headers : `list` |  A list of titles for each subplot in the preview figure    | `headers = [&#34;transcript A&#34;, &#34;transcript B&#34;]`     |
    |   violin   : `bool` |  Show symmetric kde of the dots of each group (if True).   | `violin = False`    |
    |  hoverinfo : `str`   | The type of hoverinfo to display. By default just `&#34;y&#34;`. Learn more about plotly hoverinfo [here](https://plotly.com/python/hover-text-and-formatting/). Please, note that `hovertemplate` is not currently supported.  | `hoverinfo = &#34;name+y&#34;`    |
    |  **kwargs    | Any additional kwargs that can be passed to `plotly`&#39;s`graphs_objs.Violin()`.     |      |

    &#34;&#34;&#34;
    def __init__(self, mode:str):
        self._setup_default_params(
                                    static = defaults.static_PreviewDots, 
                                    interactive = defaults.interactive_PreviewDots
                                )
        # __init__ is going to require default_params to be already set!
        super().__init__(mode)

    def _static_plot(self, **kwargs):
        &#34;&#34;&#34;
        The static Preview Results Figure
        &#34;&#34;&#34;

        kwargs = self.update_params(kwargs)
        data = self._rep_data

        # get assays to plot
        assays = [ i for i in data.columns if i not in [ &#34;group&#34;, &#34;group_name&#34;, raw_col_names[0] ] ]
        assays = sorted( assays )

        # get the groups
        groups = data[&#34;group&#34;].unique()
        names = data[&#34;group_name&#34;].unique()
        
        # generate subplot layout
        ncols, nrows = gx.make_layout_from_list( groups )

        # get kwargs incompatible with the main plotting method
        title = aux.from_kwargs(&#34;title&#34;, None, kwargs, rm = True)
        headers = aux.from_kwargs(&#34;headers&#34;, names, kwargs, rm = True)
        label_subplots = aux.from_kwargs(&#34;label_subplots&#34;, True, kwargs, rm = True)
        start_character = aux.from_kwargs(&#34;labeltype&#34;, &#34;A&#34;, kwargs, rm = True)
        show_spines = aux.from_kwargs(&#34;frame&#34;, True, kwargs, rm = True)
        show = aux.from_kwargs(&#34;show&#34;, True, kwargs, rm = True)
        show_violins = aux.from_kwargs(&#34;violin&#34;, True, kwargs, rm = True)
        rot = aux.from_kwargs(&#34;rot&#34;, None, kwargs, rm = True)
        alpha = aux.from_kwargs(&#34;alpha&#34;, 1, kwargs, rm = True)
        xlabel = aux.from_kwargs(&#34;xlabel&#34;, None, kwargs, rm = True)
        ylabel = aux.from_kwargs(&#34;ylabel&#34;, None, kwargs, rm = True)

        # generate a custom color palette in case color kwarg is provided
        palette = gx.generate_palette(kwargs)

        # set a seaborn style
        style = aux.from_kwargs(&#34;style&#34;, &#34;dark&#34;, kwargs, rm = True)
        sns.set_style( style )

        # make figure
        figsize = aux.from_kwargs(&#34;figsize&#34;, None, kwargs, rm = True)
        fig, axs = plt.subplots(nrows = nrows, ncols = ncols, figsize = figsize)
        fig.suptitle( title )

        # setup Coords
        Coords = gx.AxesCoords(fig, axs, (nrows, ncols))
        idx = 0
        for group, name in zip( groups, headers ): 

            try:
                
                # prepare a vertical bigtable format dataframe 
                tmp_df = self._prepare_df(data, assays, group)
                
                # now plot a new violin chart 
                subplot = Coords.subplot()

                if show_violins:
                    sns.violinplot(
                                    x = tmp_df[ &#34;assay&#34; ],
                                    y = tmp_df[ &#34;value&#34; ],
                                    color = None,
                                    inner = None, 
                                    palette = palette,
                                    ax = subplot,

                                )
                    for i in subplot.collections:
                        i.set_alpha( alpha * 0.3 )

                sns.stripplot(
                                x = tmp_df[ &#34;assay&#34; ],
                                y = tmp_df[ &#34;value&#34; ],
                                palette = palette,
                                alpha = alpha,
                                ax = subplot,
                                **kwargs
                            )
            
                subplot.set(
                            title = name,
                            xlabel = xlabel,
                            ylabel = ylabel,        
                        )

                # adjust xtick rotation   
                if rot is not None: 
                    align = &#34;center&#34; if rot == 0 else &#34;left&#34;
                    plt.setp( subplot.xaxis.get_majorticklabels(), rotation = -rot, ha=align, rotation_mode=&#34;anchor&#34;) 

                if not show_spines:
                    subplot.spines[&#34;right&#34;].set_visible(False)
                    subplot.spines[&#34;top&#34;].set_visible(False)
                    subplot.spines[&#34;left&#34;].set_linewidth(1.05)
                    subplot.spines[&#34;bottom&#34;].set_linewidth(1.05)

                # add ABCD... label to subplot
                if label_subplots:
                    self._add_subplot_label(idx, subplot, start_character)         

                Coords.increment()
                idx += 1
            except Exception as e:
                raise e 
                break
        
        plt.tight_layout()

        if show:
            plt.show()

        # print(&#34;&lt;&lt;&lt; Static Check &gt;&gt;&gt;&#34;)

        return fig 

    def _prepare_df(self, data, assays, group):
        &#34;&#34;&#34;
        Concatenates the different assay colums into a single 
        set of two columns, one for all &#34;value&#34;s and one for 
        the &#34;assay&#34; identifiers. 
        &#34;&#34;&#34;
        # get a group subset 
        group_df = data.query( f&#34;group == {group}&#34; )

        # concatenate all separate assay columns into a set of 
        # &#39;value&#39; and &#39;assay&#39; columns.

        # setup the _assays concatenated dataframe   
        _assays = group_df[ [ &#34;group&#34;, assays[0] ] ]
        _assays = _assays.rename( columns = { assays[0] : &#34;value&#34; } )
        _assays[&#34;assay&#34;] = [ assays[0] for i in _assays[&#34;group&#34;] ]

        # now iteratively add all remaining assays
        for assay in assays[1:]:
            tmp_df = group_df[ [ &#34;group&#34;, assay ] ]
            tmp_df = tmp_df.rename( columns = { assay : &#34;value&#34; } )
            tmp_df[&#34;assay&#34;] = [ assay for i in tmp_df[&#34;group&#34;] ]
            _assays = pd.concat( [_assays, tmp_df], ignore_index = True)
                
        # remove the group col, and sort
        tmp_df = _assays.drop( columns = [&#34;group&#34;] )
        tmp_df = tmp_df.sort_values( &#34;assay&#34; )

        return tmp_df

    def _add_subplot_label(self, idx, subplot, start_character):
        &#34;&#34;&#34;
        Adds A B C ... to upper left corner of a subplot...
        It will start labelling at any arbitrary start_character
        &#34;&#34;&#34;
        subplot_label = chr(ord(start_character)+idx)
        subplot.annotate(
                            xy = (-0.1,1.03), 
                            text = subplot_label, 
                            xycoords = &#34;axes fraction&#34;,
                            weight = &#34;bold&#34;, fontsize = 12
                        )

    def _interactive_plot(self, **kwargs):
        &#34;&#34;&#34;
        The interactive Preview Results Figure
        &#34;&#34;&#34;

        kwargs = self.update_params(kwargs)
        data = self._rep_data

        # get assays to plot
        assays = [ i for i in data.columns if i not in [ &#34;group&#34;, &#34;group_name&#34;, raw_col_names[0] ] ]
        assays = sorted( assays )

        # get the groups
        groups = data[&#34;group&#34;].unique()
        names = data[&#34;group_name&#34;].unique()
        ticks = np.arange( len(assays) )

        # make subplot layout
        ncols, nrows = gx.make_layout_from_list( groups )

        try: 
            # get incompaltible kwargs 
            headers = aux.from_kwargs(&#34;headers&#34;, names, kwargs, rm = True)
            show = aux.from_kwargs(&#34;show&#34;, True, kwargs, rm = True)
            show_violins = aux.from_kwargs(&#34;violin&#34;, True, kwargs, rm = True)

            # setup padding
            padding = aux.from_kwargs(&#34;padding&#34;, 0.1, kwargs, rm = True)
            if isinstance(padding, (list, tuple)):
                hpad, vpad = padding
            else: 
                hpad, vpad = padding, None

            # make figure
            speclist = gx.make_speclist(nrows, ncols, &#34;xy&#34;)
            fig = make_subplots(
                                    rows = nrows, cols = ncols, 
                                    specs = speclist, 
                                    subplot_titles = headers,
                                    horizontal_spacing = hpad,
                                    vertical_spacing = vpad
                            )

            # setup subplot coords handling
            Coords = gx.AxesCoords(fig, [], (ncols, nrows))

            # setup figure
            fig.update_layout(
                                title = aux.from_kwargs(&#34;title&#34;, &#34;Results Preview&#34;, kwargs, rm = True), 
                                height = aux.from_kwargs(&#34;height&#34;, None, kwargs, rm = True), 
                                width = aux.from_kwargs(&#34;width&#34;, None, kwargs, rm = True),
                                margin = {&#34;autoexpand&#34;: True, &#34;pad&#34; : 0, &#34;b&#34;: 1, &#34;t&#34;: 50}, 
                                autosize = True, 
                                template = aux.from_kwargs(&#34;template&#34;, &#34;plotly_white&#34;, kwargs, rm = True),
                                # legend = {  &#34;title&#34; : aux.from_kwargs(&#34;legend_title&#34;, &#34;Assay&#34;, kwargs, rm = True),  },
                                showlegend = False
                            )

            # set default axes labels
            xlabel = aux.from_kwargs(&#34;xlabel&#34;, &#34;&#34;, kwargs, rm = True) 
            fig.update_xaxes(title_text = xlabel)
            
            ylabel = aux.from_kwargs(&#34;ylabel&#34;, &#34;&#34;, kwargs, rm = True) 
            fig.update_yaxes(title_text = ylabel)

            idx = 0
            for group, name in zip( groups, headers ):
                
                # prepare a vertical bigtable format dataframe 
                tmp_df = self._prepare_df(data, assays, group)

                row, col = Coords.get()

                # now plot a new violin chart 
                fig.add_trace(

                    go.Violin(
                                    name = name,
                                    x = tmp_df[ &#34;assay&#34; ], 
                                    y = tmp_df[ &#34;value&#34; ], 
                                    points = &#34;all&#34;,
                                    pointpos = 0,
                                    hoverinfo = aux.from_kwargs(&#34;hoverinfo&#34;, &#34;y&#34;, kwargs, rm = True), 
                                    **kwargs
                            ), 
                                    row, col
                        )

                # remove violins if not desired (leaving only dot plot)
                if not show_violins: 
                    fig.update_traces(
                                        fillcolor=&#34;rgba(0,0,0,0)&#34;, 
                                        line_width = 0, 
                                        selector=dict(type=&#39;violin&#39;),
                                    )


                # update x axis to categorical group names
                fig.update_layout(
                                    { 
                                        f&#34;xaxis{idx+1}&#34; : dict(
                                                                tickmode = &#39;array&#39;,
                                                                tickvals = ticks,
                                                                ticktext = assays,
                                                        )         
                                    }
                                )

                Coords.increment()

                idx += 1

            if show:
                fig.show()

            # print(&#34;&lt;&lt;&lt; Interactive Check &gt;&gt;&gt;&#34;)
            return fig 
        except Exception as e: 
            raise e 


class EfficiencyLines(Plotter):
    &#34;&#34;&#34;
    Generates a Figure for the linear regressions used for Assay efficiency 
    calculations. This FigureClass specifically works with the `qpcr.Calibrator` 
    class. 

    Parameters
    ----------
    mode : str
        The plotting mode. May be either &#34;static&#34; (matplotlib) or &#34;interactive&#34; (plotly).
    
    Plotting Kwargs
    ----

    #### `&#34;static&#34;` Kwargs
    Static EfficiencyLines figures accept the following kwargs:
    
    |   Argument  |  Description    |  Example    |
    | ---- | ---- | ---- |
    |  show : `bool`    |  Whether or not to show the figure    |  `show = True` (default)   |
    |   figsize : `tuple`   |  The figure size    | `figsize = (10, 4)`     |
    | title : `str`   |  The overall figure title   | `title = &#34;Today&#39;s efficiencies&#34;    |
    | xlabel : `str`| The x-axis label of each subplot | `xlabel = &#34;Log Dilution&#34;` |
    | ylabel : `str`| The y-axis label of each subplot | `ylabel = &#34;My Ct Values&#34;` |
    | rot : `float` | The rotation of x-axis labels | `rot = 0.3` |
    |    headers : `list` |  A list of titles for each subplot in the preview figure    | `headers = [&#34;transcript A&#34;, &#34;transcript B&#34;]`     |
    |  label_subplots  : `bool`   |   Add each subplot with A, B, C ... (if True, default)   | `label_subplots = True` (default)     |
    | labeltype : `str`| The starting character for subplot labelling. By default an `&#34;A&#34;`. | `labeltype = &#34;a&#34;` |
    |   frame   : `bool` |  Show left and top spines of subplots (if True)    | `frame = False` (default)     |
    |   color : `str or list`   | The fillcolor for the individual bars   | `color = &#34;yellow&#34;`     |
    |  style : `str`   | A `seaborn` style to set. Check out available styles [here](https://www.python-graph-gallery.com/104-seaborn-themes).     | `style = &#34;darkgrid&#34;`    |
    |   edgecolor : `str or list`   | The edgecolor for the individual dots for the datapoints.   | `edgecolor = &#34;black&#34;`     |
    |   edgewidth : `float`   |  The width of the edge of individual dots.  | `edgewidth = 0.5`     |
    |   linecolor : `str or list`   | The color for regression line.   | `linecolor = &#34;crimson&#34;`     |
    |   linewidth : `float`   |  The width of the regression line.  | `edgewidth = 0.5`     |
    |  **kwargs    | Any additional kwargs that can be passed to `seaborn`&#39;s `scatterplot` and `lineplot` (both!).     |      |

    &lt;br&gt;&lt;/br&gt;
    #### `&#34;interactive&#34;` Kwargs
    Interactive EfficiencyLines figures accept the following kwargs:

    |   Argument  |  Description    |  Example    |
    | ---- | ---- | ---- |
    |  show : `bool`    |  Whether or not to show the figure    |  `show = True` (default)   |
    | title : `str`   |  The overall figure title   | `title = &#34;Today&#39;s efficiencies&#34;`    |
    | xlabel : `str`   |  The x axis label   | `xlabel = &#34;Log Dilution&#34;`    |
    | ylabel : `str`   |  The y axis label   | `ylabel = My super Ct values&#34;`    |
    |  height : `int`   |   Height of the figure   | `height = 50`    |
    |  width : `int`   |   Width of the figure   | `width = 50`    |
    |  padding : `float or tuple`   |   Padding between subplots. This can be a single float (interpreted as horizontal padding), or a tuple of (horizontal, vertical) paddings.   | `padding = 0.2`    |
    |  template : `str`   | The `plotly` template to use. Check out available templates [here](https://plotly.com/python/templates/).     | `template = &#34;plotly_dark&#34;`    |
    |    headers : `list` |  A list of titles for each subplot in the preview figure    | `headers = [&#34;transcript A&#34;, &#34;transcript B&#34;]`     |
    |  hoverinfo : `str`   | The type of hoverinfo to display. By default just `&#34;y+x&#34;`. Learn more about plotly hoverinfo [here](https://plotly.com/python/hover-text-and-formatting/). Please, note that `hovertemplate` is not currently supported.  | `hoverinfo = &#34;name+y&#34;`    |
    |  **kwargs    | Any additional kwargs that can be passed to `plotly`&#39;s`graphs_objs.Scatter()`.     |      |


    &#34;&#34;&#34;
    def __init__(self, mode : str ):
        self._setup_default_params(
                                    static = defaults.static_EfficiencyLines, 
                                    interactive = defaults.interactive_EfficiencyLines
                                )
        super().__init__( mode = mode )
        self._Calibrator = None

    def link( self, calibrator : qpcr.Calibrator ):
        &#34;&#34;&#34;
        Links a `qpcr.Calibrator` object to source data from.

        Note
        -----
        Only a `qpcr.Calibrator` that has actually *de novo*
        computed efficiencies will have data to plot, and only for 
        the newly computed effiencies! 

        Parameters
        ----------
        calibrator : qpcr.Calibrator
            A `qpcr.Calibrator` object that has computed new efficiencies.
        &#34;&#34;&#34;
        self._Calibrator = calibrator
    
    def _static_plot(self, **kwargs):
        &#34;&#34;&#34;
        Generates a static Effiency Regression Figure
        &#34;&#34;&#34;
        kwargs = self.update_params(kwargs)
        data = self._Calibrator._computed_values
        headers = list(  data.keys()  )

        title = aux.from_kwargs(&#34;title&#34;, None, kwargs, rm = True)
        headers = aux.from_kwargs(&#34;headers&#34;, headers, kwargs, rm = True)
        label_subplots = aux.from_kwargs(&#34;label_subplots&#34;, True, kwargs, rm = True)
        start_character = aux.from_kwargs(&#34;labeltype&#34;, &#34;A&#34;, kwargs, rm = True)
        show_spines = aux.from_kwargs(&#34;frame&#34;, True, kwargs, rm = True)
        show = aux.from_kwargs(&#34;show&#34;, True, kwargs, rm = True)
        rot = aux.from_kwargs(&#34;rot&#34;, None, kwargs, rm = True)

        palette = gx.generate_palette(kwargs)

        xlabel = aux.from_kwargs(&#34;xlabel&#34;, None, kwargs, rm = True)
        ylabel = aux.from_kwargs(&#34;ylabel&#34;, None, kwargs, rm = True)

        # set a seaborn style
        style = aux.from_kwargs(&#34;style&#34;, &#34;ticks&#34;, kwargs, rm = True)
        sns.set_style( style )

        edgecolor = aux.from_kwargs(&#34;edgecolor&#34;, &#34;white&#34;, kwargs, rm = True)
        edgewidth = aux.from_kwargs(&#34;edgewidth&#34;, None, kwargs, rm = True)

        linecolor = aux.from_kwargs(&#34;linecolor&#34;, &#34;black&#34;, kwargs, rm = True)
        linewidth = aux.from_kwargs(&#34;linewidth&#34;, 1, kwargs, rm = True)

        ncols, nrows = gx.make_layout_from_list( headers )

        fig, axs = plt.subplots( nrows = nrows, ncols = ncols)
        fig.suptitle( title )
        Coords = gx.AxesCoords( fig, axs, subplots = (nrows, ncols) )

        idx = 0 
        for id, obj in data.items(): 
            
            ax = Coords.subplot()

            # get data to plot              
            dilutions, cts = obj.values()
            eff = obj.efficiency()
            model = obj.model()
            Rsquare = model.rvalue ** 2

            # plot the regression line
            yvals = model.slope * dilutions + model.intercept
            sns.lineplot(
                                x = dilutions,
                                y = yvals,
                                color = linecolor,
                                linewidth = linewidth,
                                ax = ax,
                                **kwargs
                    )

            # plot the original data
            sns.scatterplot(
                                x = dilutions,
                                y = cts,
                                palette = palette, 
                                edgecolor = edgecolor,
                                linewidth = edgewidth,
                                ax = ax,
                                **kwargs
                            )

            # add additional info to a legend
            ax.legend( handles = [
                                    # R^2 Value
                                    Line2D(  [0], [0], 
                                            color = &#34;black&#34;, 
                                            visible = False, 
                                            label = f&#34;$R^2$ \t = {Rsquare:.4f}&#34;
                                        ),
                                    # Efficiency Value
                                    Line2D(  [0], [0], 
                                            color = &#34;black&#34;, 
                                            visible = False, 
                                            label = f&#34;$eff.$\t= {eff:.4f}&#34;
                                        )
                                ], 
                                loc = &#34;upper right&#34;,
                                frameon = False 
                    )

            # some formatting...
            ax.set(
                    title = id, 
                    xlabel = xlabel,
                    ylabel = ylabel,
                )

            if rot is not None: 
                align = &#34;center&#34; if rot == 0 else &#34;left&#34;
                plt.setp( ax.xaxis.get_majorticklabels(), rotation = -rot, ha=align, rotation_mode=&#34;anchor&#34;) 

            # add ABCD... label to subplot
            if label_subplots:
                self._add_subplot_label(idx, ax, start_character)         

            if not show_spines:
                sns.despine()
            
            idx += 1
            Coords.increment()

        plt.tight_layout()
        if show: 
            plt.show()

        return fig 

    def _interactive_plot(self, **kwargs):
        &#34;&#34;&#34;
        Generates an interactive EfficiencyLines figure
        &#34;&#34;&#34;
        kwargs = self.update_params(kwargs)
        data = self._Calibrator._computed_values
        headers = list(  data.keys()  )

        title = aux.from_kwargs(&#34;title&#34;, None, kwargs, rm = True)
        headers = aux.from_kwargs(&#34;headers&#34;, headers, kwargs, rm = True)
        show = aux.from_kwargs(&#34;show&#34;, True, kwargs, rm = True)
        padding = aux.from_kwargs(&#34;padding&#34;, 0.1, kwargs, rm = True)

        if isinstance(padding, (list, tuple)):
            hpad, vpad = padding
        else: 
            hpad, vpad = padding, None

        # make new ncols and nrows based on the headers list
        nrows, ncols = gx.make_layout_from_list(headers)

        speclist = gx.make_speclist(nrows, ncols, &#34;xy&#34;)
        fig = make_subplots(
                                rows = nrows, cols = ncols, 
                                specs = speclist, 
                                subplot_titles = headers,
                                horizontal_spacing = hpad,
                                vertical_spacing = vpad
                        )


        Coords = gx.AxesCoords(fig, [], (ncols, nrows))

        fig.update_layout(
                    title = title, 
                    height = aux.from_kwargs(&#34;height&#34;, None, kwargs, rm = True), 
                    width = aux.from_kwargs(&#34;width&#34;, None, kwargs, rm = True),
                    margin = {&#34;autoexpand&#34;: True, &#34;pad&#34; : 0, &#34;b&#34;: 1, &#34;t&#34;: 50}, 
                    autosize = True, 
                    template = aux.from_kwargs(&#34;template&#34;, &#34;plotly_white&#34;, kwargs, rm = True),
                    # legend = {&#34;title&#34; : aux.from_kwargs(&#34;legend_title&#34;, &#34;Assay&#34;, kwargs, rm = True), },
                )

        # set default axes labels
        xlabel = aux.from_kwargs(&#34;xlabel&#34;, None, kwargs, rm = True) 
        fig.update_xaxes(title_text = xlabel)
        
        ylabel = aux.from_kwargs(&#34;ylabel&#34;, None, kwargs, rm = True) 
        fig.update_yaxes(title_text = ylabel)

        Coords = gx.AxesCoords(fig, [], (ncols, nrows))

        # iterate over the data...
        idx = 0 
        for id, obj in data.items():

            row, col = Coords.get()

            # get data to plot              
            dilutions, cts = obj.values()
            eff = obj.efficiency()
            model = obj.model()
            Rsquare = model.rvalue ** 2

            # plot the original data
            fig.add_trace(
                            go.Scatter(
                                name = id,
                                x = dilutions,
                                y = cts,  
                                mode = &#34;markers&#34;,
                                showlegend = False,
                                hoverinfo = aux.from_kwargs(&#34;hoverinfo&#34;, &#34;y+x&#34;, kwargs, rm = True), 
                                **kwargs
                            ), 
                            row, col
                        )
            
            # plot the regression line
            yvals = model.slope * dilutions + model.intercept

            fig.add_trace(
                            go.Scatter(
                                name = id,
                                x = dilutions,
                                y = yvals,  
                                mode = &#34;lines&#34;,
                                showlegend = False,
                                **kwargs
                            ), 
                            row, col
                        )


            # add infos as annotations (because custom legends don&#39;t work here)
            # NOTE: The xref x{idx} is a pretty nice lifehack to essentially 
            #       emulate the ax behaviour from matplotib.subplots... 
            xref = &#34;x&#34; if idx == 0 else f&#34;x{idx+1}&#34;
            yref = &#34;y&#34; if idx == 0 else f&#34;y{idx+1}&#34;
            info_text = f&#34;R^2 = {Rsquare:.4f}&lt;br&gt;eff. = {eff:.4f}&#34;

            fig.add_annotation(
                            dict(
                                    x = 0, 
                                    y = np.max( cts ), 
                                    xref = xref, 
                                    yref = yref, 
                                    text = info_text, 
                                    showarrow = False
                                )
                            )

            Coords.increment()
            idx += 1

        if show: 
            fig.show()

        return fig 



# if __name__ == &#39;__main__&#39;:

    # files = [&#34;Example Data/28S.csv&#34;, &#34;Example Data/28S_again.csv&#34;, &#34;Example Data/actin.csv&#34;,
    # &#34;Example Data/actin2.csv&#34;,
    # &#34;Example Data/actin3.csv&#34;,
    # &#34;Example Data/HNRNPL_nmd.csv&#34;, &#34;Example Data/HNRNPL_prot.csv&#34;]
    # groupnames = [&#34;wt-&#34;, &#34;wt+&#34;, &#34;ko-&#34;, &#34;ko+&#34;]

    # # setup figures
    # a = PreviewResults(mode = &#34;static&#34;)
    # b = PreviewResults(mode = &#34;interactive&#34;)

    # a.params(
    #       frame = True, labeltype = &#34;a&#34;, show = False
    # )
    # b.params(
    #     show = False, template = &#34;plotly&#34;  
    # )

    # # predefined pipeline use
    # pipe = qpcr.Pipes.Basic()
    # pipe.link(files)
    # pipe.add_normalisers(files[:2])
    # pipe.replicates(6)
    # pipe.names(groupnames)


    # print()
    # print(&#34;==== Multiple (ALL) Samples ====&#34;)
    # pipe.run()
    # result = pipe.get(kind = &#34;obj&#34;)
    # try:
    #     a.link(result)
    #     a.plot(color = &#34;green&#34;)
    # except: 
    #     print(&#34;Static Failed!&#34;)

    # try:
    #     b.link(result)
    #     b.plot()
    # except: print(&#34;Interactive Failed!&#34;)

    # print()
    # print(&#34;==== Multiple (7) Samples ====&#34;)
    # pipe.link(files[:7])
    # pipe.run()
    # result = pipe.get(kind = &#34;obj&#34;)
    # try:
    #     a.link(result)
    #     a.plot(show = False)
    # except: 
    #     print(&#34;Static Failed!&#34;)

    # try:
    #     b.link(result)
    #     b.plot(template = &#34;plotly&#34;)
    # except: print(&#34;Interactive Failed!&#34;)

    # print()
    # print(&#34;==== Multiple (6) Samples ====&#34;)
    # pipe.link(files[:6])
    # pipe.run()
    # result = pipe.get(kind = &#34;obj&#34;)
    # try:
    #     a.link(result)
    #     a.plot()
    # except: 
    #     print(&#34;Static Failed!&#34;)

    # try:
    #     b.link(result)
    #     b.plot()
    # except: print(&#34;Interactive Failed!&#34;)

    # print()
    # print(&#34;==== Multiple (4) Samples ====&#34;)
    # pipe.link(files[:4])
    # pipe.run()
    # result = pipe.get(kind = &#34;obj&#34;)
    # try:
    #     a.link(result)
    #     a.plot()
    # except: 
    #     print(&#34;Static Failed!&#34;)

    # try:
    #     b.link(result)
    #     b.plot()
    # except: print(&#34;Interactive Failed!&#34;)

    # print()
    # print(&#34;==== Multiple (3) Samples ====&#34;)
    # pipe.link(files[:3])
    # pipe.run()
    # result = pipe.get(kind = &#34;obj&#34;)
    # try:
    #     a.link(result)
    #     a.plot()
    # except Exception as e: 
    #     print(e)
    #     print(&#34;Static Failed!&#34;)

    # try:
    #     b.link(result)
    #     b.plot()
    # except Exception as e: 
    #     print(&#34;Interactive Failed!&#34;)
    #     raise e

    # print()
    # print(&#34;==== Multiple (2) Samples ====&#34;)
    # pipe.link(files[:2])
    # pipe.run()
    # result = pipe.get(kind = &#34;obj&#34;)
    # try:
    #     a.link(result)
    #     a.plot(show = False)
    # except Exception as e: 
    #     print(e)
    #     print(&#34;Static Failed!&#34;)

    # try:
    #     b.link(result)
    #     b.plot(show = False)
    # except Exception as e: 
    #     print(&#34;Interactive Failed!&#34;)
    #     raise e


    # print()
    # print(&#34;==== One (1) Sample ====&#34;)
    # pipe.link([files[0]])
    # pipe.run()
    # result = pipe.get(kind = &#34;obj&#34;)
    # try:
    #     a.link(result)
    #     a.plot()
    # except: 
    #     print(&#34;Static Failed!&#34;)

    # try:
    #     b.link(result)
    #     b.plot()
    # except: print(&#34;Interactive Failed!&#34;)
    # exit(0)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="qpcr.Plotters.Plotters.AssayBars"><code class="flex name class">
<span>class <span class="ident">AssayBars</span></span>
<span>(</span><span>mode:Â str)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a Preview of all results from all Assays in subplots as Bar Charts.
Each assay will be shown in a separate subplot.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>mode</code></strong> :&ensp;<code>str</code></dt>
<dd>The plotting mode. May be either "static" (matplotlib) or "interactive" (plotly).</dd>
</dl>
<h2 id="plotting-kwargs">Plotting Kwargs</h2>
<h4 id="static-kwargs"><code>"static"</code> Kwargs</h4>
<p>Static AssayBars figures accept the following kwargs:</p>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Description</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td>show : <code>bool</code></td>
<td>Whether or not to show the figure</td>
<td><code>show = True</code> (default)</td>
</tr>
<tr>
<td>figsize : <code>tuple</code></td>
<td>The figure size</td>
<td><code>figsize = (10, 4)</code></td>
</tr>
<tr>
<td>title : <code>str</code></td>
<td>The overall figure title</td>
<td>`title = "Today's results"</td>
</tr>
<tr>
<td>xlabel : <code>str</code></td>
<td>The x-axis label of each subplot</td>
<td><code>xlabel = "Conditions"</code></td>
</tr>
<tr>
<td>ylabel : <code>str</code></td>
<td>The y-axis label of each subplot</td>
<td><code>ylabel = "Mean $\Delta\Delta Ct$"</code></td>
</tr>
<tr>
<td>rot : <code>float</code></td>
<td>The rotation of x-axis labels</td>
<td><code>rot = 0.3</code></td>
</tr>
<tr>
<td>headers : <code>list</code></td>
<td>A list of titles for each subplot in the preview figure</td>
<td><code>headers = ["transcript A", "transcript B"]</code></td>
</tr>
<tr>
<td>label_subplots
: <code>bool</code></td>
<td>Add each subplot with A, B, C &hellip; (if True, default)</td>
<td><code>label_subplots = True</code> (default)</td>
</tr>
<tr>
<td>labeltype : <code>str</code></td>
<td>The starting character for subplot labelling. By default an <code>"A"</code>.</td>
<td><code>labeltype = "a"</code></td>
</tr>
<tr>
<td>frame
: <code>bool</code></td>
<td>Show left and top spines of subplots (if True)</td>
<td><code>frame = False</code> (default)</td>
</tr>
<tr>
<td>color : <code>str or list</code></td>
<td>The fillcolor for the individual bars</td>
<td><code>color = "yellow"</code></td>
</tr>
<tr>
<td>style : <code>str</code></td>
<td>A <code>seaborn</code> style to set. Check out available styles <a href="https://www.python-graph-gallery.com/104-seaborn-themes">here</a>.</td>
<td><code>style = "darkgrid"</code></td>
</tr>
<tr>
<td>edgecolor : <code>str or list</code></td>
<td>The edgecolor for the individual bars</td>
<td><code>edgecolor = "black"</code></td>
</tr>
<tr>
<td>edgewidth : <code>float</code></td>
<td>The width of the edge of individual bars</td>
<td><code>edgewidth = 0.5</code></td>
</tr>
<tr>
<td>ecolor : <code>str</code></td>
<td>The color of errorbars</td>
<td><code>ecolor = "orange"</code></td>
</tr>
<tr>
<td>**kwargs</td>
<td>Any additional kwargs that can be passed to the <code>matplotlib</code>-backend pandas <code>.plot.bar()</code> API.</td>
<td></td>
</tr>
</tbody>
</table>
<p><br></br></p>
<h4 id="interactive-kwargs"><code>"interactive"</code> Kwargs</h4>
<p>Interactive AssayBars figures accept the following kwargs:</p>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Description</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td>show : <code>bool</code></td>
<td>Whether or not to show the figure</td>
<td><code>show = True</code> (default)</td>
</tr>
<tr>
<td>title : <code>str</code></td>
<td>The overall figure title</td>
<td><code>title = "Today's results"</code></td>
</tr>
<tr>
<td>xlabel : <code>str</code></td>
<td>The x axis label</td>
<td><code>xlabel = "My super qPCR samples"</code></td>
</tr>
<tr>
<td>ylabel : <code>str</code></td>
<td>The y axis label</td>
<td><code>ylabel = "Mean of ddCt"</code></td>
</tr>
<tr>
<td>height : <code>int</code></td>
<td>Height of the figure</td>
<td><code>height = 50</code></td>
</tr>
<tr>
<td>width : <code>int</code></td>
<td>Width of the figure</td>
<td><code>width = 50</code></td>
</tr>
<tr>
<td>padding : <code>float or tuple</code></td>
<td>Padding between subplots. This can be a single float (interpreted as horizontal padding), or a tuple of (horizontal, vertical) paddings.</td>
<td><code>padding = 0.2</code></td>
</tr>
<tr>
<td>template : <code>str</code></td>
<td>The <code>plotly</code> template to use. Check out available templates <a href="https://plotly.com/python/templates/">here</a>.</td>
<td><code>template = "plotly_dark"</code></td>
</tr>
<tr>
<td>headers : <code>list</code></td>
<td>A list of titles for each subplot in the preview figure</td>
<td><code>headers = ["transcript A", "transcript B"]</code></td>
</tr>
<tr>
<td>legend_title : <code>str</code></td>
<td>The title to be displayed above the legend</td>
<td><code>legend_title = "my assays"</code></td>
</tr>
<tr>
<td>hoverinfo : <code>str</code></td>
<td>The type of hoverinfo to display. By default just <code>"y"</code>. Learn more about plotly hoverinfo <a href="https://plotly.com/python/hover-text-and-formatting/">here</a>. Please, note that <code>hovertemplate</code> is not currently supported.</td>
<td><code>hoverinfo = "name+y"</code></td>
</tr>
<tr>
<td>**kwargs</td>
<td>Any additional kwargs that can be passed to <code>plotly</code>'s<code>graphs_objs.Bar()</code>.</td>
<td></td>
</tr>
</tbody>
</table></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AssayBars(Plotter):
    &#34;&#34;&#34;
    Generate a Preview of all results from all Assays in subplots as Bar Charts.
    Each assay will be shown in a separate subplot.

    Parameters
    ----------
    mode : str
        The plotting mode. May be either &#34;static&#34; (matplotlib) or &#34;interactive&#34; (plotly).


    Plotting Kwargs
    ----
    
    #### `&#34;static&#34;` Kwargs
    Static AssayBars figures accept the following kwargs:
    
    |   Argument  |  Description    |  Example    |
    | ---- | ---- | ---- |
    |  show : `bool`    |  Whether or not to show the figure    |  `show = True` (default)   |
    |   figsize : `tuple`   |  The figure size    | `figsize = (10, 4)`     |
    | title : `str`   |  The overall figure title   | `title = &#34;Today&#39;s results&#34;    |
    | xlabel : `str`| The x-axis label of each subplot | `xlabel = &#34;Conditions&#34;` |
    | ylabel : `str`| The y-axis label of each subplot | `ylabel = &#34;Mean $\Delta\Delta Ct$&#34;` |
    | rot : `float` | The rotation of x-axis labels | `rot = 0.3` |
    |    headers : `list` |  A list of titles for each subplot in the preview figure    | `headers = [&#34;transcript A&#34;, &#34;transcript B&#34;]`     |
    |  label_subplots  : `bool`   |   Add each subplot with A, B, C ... (if True, default)   | `label_subplots = True` (default)     |
    | labeltype : `str`| The starting character for subplot labelling. By default an `&#34;A&#34;`. | `labeltype = &#34;a&#34;` |
    |   frame   : `bool` |  Show left and top spines of subplots (if True)    | `frame = False` (default)     |
    |   color : `str or list`   | The fillcolor for the individual bars   | `color = &#34;yellow&#34;`     |
    |  style : `str`   | A `seaborn` style to set. Check out available styles [here](https://www.python-graph-gallery.com/104-seaborn-themes).     | `style = &#34;darkgrid&#34;`    |
    |   edgecolor : `str or list`   | The edgecolor for the individual bars   | `edgecolor = &#34;black&#34;`     |
    |   edgewidth : `float`   |  The width of the edge of individual bars  | `edgewidth = 0.5`     |
    |  ecolor : `str`    |   The color of errorbars   |  `ecolor = &#34;orange&#34;`    |
    |  **kwargs    | Any additional kwargs that can be passed to the `matplotlib`-backend pandas `.plot.bar()` API.     |      |

    &lt;br&gt;&lt;/br&gt;
    #### `&#34;interactive&#34;` Kwargs
    Interactive AssayBars figures accept the following kwargs:

    |   Argument  |  Description    |  Example    |
    | ---- | ---- | ---- |
    |  show : `bool`    |  Whether or not to show the figure    |  `show = True` (default)   |
    | title : `str`   |  The overall figure title   | `title = &#34;Today&#39;s results&#34;`    |
    | xlabel : `str`   |  The x axis label   | `xlabel = &#34;My super qPCR samples&#34;`    |
    | ylabel : `str`   |  The y axis label   | `ylabel = &#34;Mean of ddCt&#34;`    |
    |  height : `int`   |   Height of the figure   | `height = 50`    |
    |  width : `int`   |   Width of the figure   | `width = 50`    |
    |  padding : `float or tuple`   |   Padding between subplots. This can be a single float (interpreted as horizontal padding), or a tuple of (horizontal, vertical) paddings.   | `padding = 0.2`    |
    |  template : `str`   | The `plotly` template to use. Check out available templates [here](https://plotly.com/python/templates/).     | `template = &#34;plotly_dark&#34;`    |
    |    headers : `list` |  A list of titles for each subplot in the preview figure    | `headers = [&#34;transcript A&#34;, &#34;transcript B&#34;]`     |
    | legend_title : `str`    | The title to be displayed above the legend   |  `legend_title = &#34;my assays&#34;`   |
    |  hoverinfo : `str`   | The type of hoverinfo to display. By default just `&#34;y&#34;`. Learn more about plotly hoverinfo [here](https://plotly.com/python/hover-text-and-formatting/). Please, note that `hovertemplate` is not currently supported.  | `hoverinfo = &#34;name+y&#34;`    |
    |  **kwargs    | Any additional kwargs that can be passed to `plotly`&#39;s`graphs_objs.Bar()`.     |      |

    &#34;&#34;&#34;
    def __init__(self, mode:str):
        self._setup_default_params(
                                    static = defaults.static_PreviewBars, 
                                    interactive = defaults.interactive_PreviewBars
                                )
        # __init__ is going to require default_params to be already set!
        super().__init__(mode)

    def _static_plot(self, **kwargs):
        &#34;&#34;&#34;
        The static Preview Results Figure
        &#34;&#34;&#34;
        kwargs = self.update_params(kwargs)
        data = self.get()

        ref_col, ncols, nrows, headings, x, y, sterr, query = self._prep_properties(kwargs)       

        title = aux.from_kwargs(&#34;title&#34;, &#34;Results Preview&#34;, kwargs, rm = True)
        headers = aux.from_kwargs(&#34;headers&#34;, None, kwargs, rm = True)
        label_subplots = aux.from_kwargs(&#34;label_subplots&#34;, True, kwargs, rm = True)
        start_character = aux.from_kwargs(&#34;labeltype&#34;, &#34;A&#34;, kwargs, rm = True)
        show_spines = aux.from_kwargs(&#34;frame&#34;, True, kwargs, rm = True)
        show = aux.from_kwargs(&#34;show&#34;, True, kwargs, rm = True)
        rot = aux.from_kwargs(&#34;rot&#34;, None, kwargs, rm = True)

        palette = gx.generate_palette(kwargs)

        # set a seaborn style
        style = aux.from_kwargs(&#34;style&#34;, &#34;ticks&#34;, kwargs, rm = True)
        sns.set_style( style )

        edgecolor = aux.from_kwargs(&#34;edgecolor&#34;, &#34;white&#34;, kwargs, rm = True)
        edgewidth = aux.from_kwargs(&#34;edgewidth&#34;, None, kwargs, rm = True)

        if edgewidth is None: 
            edgewidth = aux.from_kwargs(&#34;linewidth&#34;, 1, kwargs, rm = True) 
        else: 
            aux.from_kwargs(&#34;linewidth&#34;, None, kwargs, rm = True )

        figsize = aux.from_kwargs(&#34;figsize&#34;, None, kwargs, rm = True)
        fig, axs = plt.subplots(nrows = nrows, ncols = ncols, figsize = figsize)
        fig.suptitle( title )

        # setup Coords
        Coords = gx.AxesCoords(fig, axs, (nrows, ncols))
        idx = 0
        for assay in headings: 
            try: 
                q = query.format(ref_col = ref_col, q = assay)
                tmp_df = data.query(q)
                tmp_df = tmp_df.sort_values(&#34;group&#34;)


                # now plot a new bar chart 
                subplot = Coords.subplot()

                tmp_df.plot.bar(
                                x = x, y = y, 
                                ax = subplot,
                                edgecolor = edgecolor,
                                linewidth = edgewidth,
                                color = palette,
                                **kwargs
                            )

                subplot.errorbar(
                                x = tmp_df[x], y = tmp_df[y], 
                                yerr = tmp_df[sterr], 
                                fmt = &#34;.&#34;, markersize = 0, capsize = 3, 
                                ecolor = aux.from_kwargs(&#34;ecolor&#34;, &#34;black&#34;, kwargs),
                            )
            
                subplot.set(
                            title = assay if headers is None else headers[idx],
                            xlabel = aux.from_kwargs(&#34;xlabel&#34;, None, kwargs),
                            ylabel = aux.from_kwargs(&#34;ylabel&#34;, &#34;$\Delta\Delta$Ct&#34;, kwargs),        
                        )

                if rot is not None: 
                    align = &#34;center&#34; if rot == 0 else &#34;left&#34;
                    plt.setp( subplot.xaxis.get_majorticklabels(), rotation = -rot, ha=align, rotation_mode=&#34;anchor&#34;) 

                if not show_spines:
                    subplot.spines[&#34;right&#34;].set_visible(False)
                    subplot.spines[&#34;top&#34;].set_visible(False)
                    subplot.spines[&#34;left&#34;].set_linewidth(1.05)
                    subplot.spines[&#34;bottom&#34;].set_linewidth(1.05)

                # add ABCD... label to subplot
                if label_subplots:
                    self._add_subplot_label(idx, subplot, start_character)         

                Coords.increment()
                idx += 1
            except Exception as e:
                raise e 
                break
        
        plt.tight_layout()

        
        if show:
            plt.show()

        # print(&#34;&lt;&lt;&lt; Static Check &gt;&gt;&gt;&#34;)

        return fig 

    # def _add_subplot_label(self, idx, subplot, start_character):
    #     &#34;&#34;&#34;
    #     Adds A B C ... to upper left corner of a subplot...
    #     It will start labelling at any arbitrary start_character
    #     &#34;&#34;&#34;
    #     subplot_label = chr(ord(start_character)+idx)
    #     subplot.annotate(
    #                 xy = (-0.1,1.03), 
    #                 text = subplot_label, 
    #                 xycoords = &#34;axes fraction&#34;,
    #                 weight = &#34;bold&#34;, fontsize = 12
    #             )

    def _interactive_plot(self, **kwargs):
        &#34;&#34;&#34;
        The interactive Preview Results Figure
        &#34;&#34;&#34;

        kwargs = self.update_params(kwargs)
        data = self.get()

        try: 
            # setup figure framework variables that have to be removed from 
            ref_col, ncols, nrows, headings, x, y, sterr, query = self._prep_properties(kwargs)
            headers = aux.from_kwargs(&#34;headers&#34;, headings, kwargs, rm = True)
            show = aux.from_kwargs(&#34;show&#34;, True, kwargs, rm = True)
            padding = aux.from_kwargs(&#34;padding&#34;, 0.1, kwargs, rm = True)

            if isinstance(padding, (list, tuple)):
                hpad, vpad = padding
            else: 
                hpad, vpad = padding, None

            speclist = gx.make_speclist(nrows, ncols, &#34;xy&#34;)
            fig = make_subplots(
                                    rows = nrows, cols = ncols, 
                                    specs = speclist, 
                                    subplot_titles = headers,
                                    horizontal_spacing = hpad,
                                    vertical_spacing = vpad
                            )


            Coords = gx.AxesCoords(fig, [], (ncols, nrows))

            fig.update_layout(
                        title = aux.from_kwargs(&#34;title&#34;, &#34;Results Preview&#34;, kwargs, rm = True), 
                        height = aux.from_kwargs(&#34;height&#34;, None, kwargs, rm = True), 
                        width = aux.from_kwargs(&#34;width&#34;, None, kwargs, rm = True),
                        margin = {&#34;autoexpand&#34;: True, &#34;pad&#34; : 0, &#34;b&#34;: 1, &#34;t&#34;: 50}, 
                        autosize = True, 
                        template = aux.from_kwargs(&#34;template&#34;, &#34;plotly_white&#34;, kwargs, rm = True),
                        legend = {&#34;title&#34; : aux.from_kwargs(&#34;legend_title&#34;, ref_col, kwargs, rm = True),
                        },
                    )

            # set default axes labels
            xlabel = aux.from_kwargs(&#34;xlabel&#34;, &#34;&#34;, kwargs, rm = True) 
            fig.update_xaxes(title_text = xlabel)
            
            ylabel = aux.from_kwargs(&#34;ylabel&#34;, &#34;DeltaDeltaCt&#34;, kwargs, rm = True) 
            fig.update_yaxes(title_text = ylabel)

            idx = 0
            for assay in headings:
                row, col = Coords.get()
                tmp_df = data.query(query.format(ref_col = ref_col, q = assay))
                tmp_df = tmp_df.sort_values(&#34;group&#34;)

                # now plot a new bar chart 
                fig.add_trace(

                    go.Bar(
                        name = assay,
                        y = tmp_df[y], x = tmp_df[x], 
                        error_y=dict(type=&#39;data&#39;, array = tmp_df[sterr]),
                        hoverinfo = aux.from_kwargs(&#34;hoverinfo&#34;, &#34;y&#34;, kwargs, rm = True), 
                        **kwargs
                    ), 

                    row, col
                )
                Coords.increment()

                idx += 1

            if show:
                fig.show()

            # print(&#34;&lt;&lt;&lt; Interactive Check &gt;&gt;&gt;&#34;)
            return fig 
        except Exception as e: 
            raise e </code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="qpcr.Plotters.Plotters.Plotter" href="#qpcr.Plotters.Plotters.Plotter">Plotter</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="qpcr.Plotters.Plotters.Plotter" href="#qpcr.Plotters.Plotters.Plotter">Plotter</a></b></code>:
<ul class="hlist">
<li><code><a title="qpcr.Plotters.Plotters.Plotter.get" href="#qpcr.Plotters.Plotters.Plotter.get">get</a></code></li>
<li><code><a title="qpcr.Plotters.Plotters.Plotter.id" href="#qpcr.Plotters.Plotters.Plotter.id">id</a></code></li>
<li><code><a title="qpcr.Plotters.Plotters.Plotter.link" href="#qpcr.Plotters.Plotters.Plotter.link">link</a></code></li>
<li><code><a title="qpcr.Plotters.Plotters.Plotter.params" href="#qpcr.Plotters.Plotters.Plotter.params">params</a></code></li>
<li><code><a title="qpcr.Plotters.Plotters.Plotter.plot" href="#qpcr.Plotters.Plotters.Plotter.plot">plot</a></code></li>
<li><code><a title="qpcr.Plotters.Plotters.Plotter.save" href="#qpcr.Plotters.Plotters.Plotter.save">save</a></code></li>
<li><code><a title="qpcr.Plotters.Plotters.Plotter.suffix" href="#qpcr.Plotters.Plotters.Plotter.suffix">suffix</a></code></li>
<li><code><a title="qpcr.Plotters.Plotters.Plotter.update_params" href="#qpcr.Plotters.Plotters.Plotter.update_params">update_params</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="qpcr.Plotters.Plotters.AssayDots"><code class="flex name class">
<span>class <span class="ident">AssayDots</span></span>
<span>(</span><span>mode:Â str)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a Preview of all results from all Assays in subplots, plotting individual values
in a Dot Plot rather than Bar Plot. Each assay will be shown in a separate subplot.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>mode</code></strong> :&ensp;<code>str</code></dt>
<dd>The plotting mode. May be either "static" (matplotlib) or "interactive" (plotly).</dd>
</dl>
<h2 id="plotting-kwargs">Plotting Kwargs</h2>
<h4 id="static-kwargs"><code>"static"</code> Kwargs</h4>
<p>Static AssayDots figures accept the following kwargs:</p>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Description</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td>show : <code>bool</code></td>
<td>Whether or not to show the figure</td>
<td><code>show = True</code> (default)</td>
</tr>
<tr>
<td>figsize : <code>tuple</code></td>
<td>The figure size</td>
<td><code>figsize = (10, 4)</code></td>
</tr>
<tr>
<td>title : <code>str</code></td>
<td>The overall figure title</td>
<td>`title = "Today's results"</td>
</tr>
<tr>
<td>xlabel : <code>str</code></td>
<td>The x-axis label of each subplot</td>
<td><code>xlabel = "Conditions"</code></td>
</tr>
<tr>
<td>ylabel : <code>str</code></td>
<td>The y-axis label of each subplot</td>
<td><code>ylabel = "Mean $\Delta\Delta Ct$"</code></td>
</tr>
<tr>
<td>rot : <code>float</code></td>
<td>The rotation of x-axis labels</td>
<td><code>rot = 0.3</code></td>
</tr>
<tr>
<td>headers : <code>list</code></td>
<td>A list of titles for each subplot in the preview figure</td>
<td><code>headers = ["transcript A", "transcript B"]</code></td>
</tr>
<tr>
<td>label_subplots
: <code>bool</code></td>
<td>Add each subplot with A, B, C &hellip; (if True, default)</td>
<td><code>label_subplots = True</code> (default)</td>
</tr>
<tr>
<td>labeltype : <code>str</code></td>
<td>The starting character for subplot labelling. By default an <code>"A"</code>.</td>
<td><code>labeltype = "a"</code></td>
</tr>
<tr>
<td>frame
: <code>bool</code></td>
<td>Show left and top spines of subplots (if True)</td>
<td><code>frame = False</code> (default)</td>
</tr>
<tr>
<td>violin
: <code>bool</code></td>
<td>Show symmetric kde of the dots of each group (if True).</td>
<td><code>violin = False</code></td>
</tr>
<tr>
<td>color : <code>str or list</code></td>
<td>The fillcolor for the individual dots from replicate groups</td>
<td><code>color = "yellow"</code></td>
</tr>
<tr>
<td>style : <code>str</code></td>
<td>A <code>seaborn</code> style to set. Check out available styles <a href="https://www.python-graph-gallery.com/104-seaborn-themes">here</a>.</td>
<td><code>style = "darkgrid"</code></td>
</tr>
<tr>
<td>**kwargs</td>
<td>Any additional kwargs that can be passed to the <code>seaborn</code>'s <code>stripplot</code>.</td>
<td></td>
</tr>
</tbody>
</table>
<p><br></br></p>
<h4 id="interactive-kwargs"><code>"interactive"</code> Kwargs</h4>
<p>Interactive AssayDots figures accept the following kwargs:</p>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Description</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td>show : <code>bool</code></td>
<td>Whether or not to show the figure</td>
<td><code>show = True</code> (default)</td>
</tr>
<tr>
<td>title : <code>str</code></td>
<td>The overall figure title</td>
<td><code>title = "Today's results"</code></td>
</tr>
<tr>
<td>xlabel : <code>str</code></td>
<td>The x axis label</td>
<td><code>xlabel = "My super qPCR samples"</code></td>
</tr>
<tr>
<td>ylabel : <code>str</code></td>
<td>The y axis label</td>
<td><code>ylabel = "Mean of ddCt"</code></td>
</tr>
<tr>
<td>height : <code>int</code></td>
<td>Height of the figure</td>
<td><code>height = 50</code></td>
</tr>
<tr>
<td>width : <code>int</code></td>
<td>Width of the figure</td>
<td><code>width = 50</code></td>
</tr>
<tr>
<td>padding : <code>float or tuple</code></td>
<td>Padding between subplots. This can be a single float (interpreted as horizontal padding), or a tuple of (horizontal, vertical) paddings.</td>
<td><code>padding = 0.2</code></td>
</tr>
<tr>
<td>template : <code>str</code></td>
<td>The <code>plotly</code> template to use. Check out available templates <a href="https://plotly.com/python/templates/">here</a>.</td>
<td><code>template = "plotly_dark"</code></td>
</tr>
<tr>
<td>headers : <code>list</code></td>
<td>A list of titles for each subplot in the preview figure</td>
<td><code>headers = ["transcript A", "transcript B"]</code></td>
</tr>
<tr>
<td>violin
: <code>bool</code></td>
<td>Show symmetric kde of the dots of each group (if True).</td>
<td><code>violin = False</code></td>
</tr>
<tr>
<td>hoverinfo : <code>str</code></td>
<td>The type of hoverinfo to display. By default just <code>"y"</code>. Learn more about plotly hoverinfo <a href="https://plotly.com/python/hover-text-and-formatting/">here</a>. Please, note that <code>hovertemplate</code> is not currently supported.</td>
<td><code>hoverinfo = "name+y"</code></td>
</tr>
<tr>
<td>**kwargs</td>
<td>Any additional kwargs that can be passed to <code>plotly</code>'s<code>graphs_objs.Violin()</code>.</td>
<td></td>
</tr>
</tbody>
</table></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AssayDots(Plotter):
    &#34;&#34;&#34;
    Generate a Preview of all results from all Assays in subplots, plotting individual values
    in a Dot Plot rather than Bar Plot. Each assay will be shown in a separate subplot.

    Parameters
    ----------
    mode : str
        The plotting mode. May be either &#34;static&#34; (matplotlib) or &#34;interactive&#34; (plotly).


    Plotting Kwargs
    ----
    
    #### `&#34;static&#34;` Kwargs
    Static AssayDots figures accept the following kwargs:
    
    |   Argument  |  Description    |  Example    |
    | ---- | ---- | ---- |
    |  show : `bool`    |  Whether or not to show the figure    |  `show = True` (default)   |
    |   figsize : `tuple`   |  The figure size    | `figsize = (10, 4)`     |
    | title : `str`   |  The overall figure title   | `title = &#34;Today&#39;s results&#34;    |
    | xlabel : `str`| The x-axis label of each subplot | `xlabel = &#34;Conditions&#34;` |
    | ylabel : `str`| The y-axis label of each subplot | `ylabel = &#34;Mean $\Delta\Delta Ct$&#34;` |
    | rot : `float` | The rotation of x-axis labels | `rot = 0.3` |
    |    headers : `list` |  A list of titles for each subplot in the preview figure    | `headers = [&#34;transcript A&#34;, &#34;transcript B&#34;]`     |
    |  label_subplots  : `bool`   |   Add each subplot with A, B, C ... (if True, default)   | `label_subplots = True` (default)     |
    | labeltype : `str`| The starting character for subplot labelling. By default an `&#34;A&#34;`. | `labeltype = &#34;a&#34;` |
    |   frame   : `bool` |  Show left and top spines of subplots (if True)    | `frame = False` (default)     |
    |   violin   : `bool` |  Show symmetric kde of the dots of each group (if True).   | `violin = False`    |
    |   color : `str or list`   | The fillcolor for the individual dots from replicate groups   | `color = &#34;yellow&#34;`     |
    |  style : `str`   | A `seaborn` style to set. Check out available styles [here](https://www.python-graph-gallery.com/104-seaborn-themes).     | `style = &#34;darkgrid&#34;`    |
    |  **kwargs    | Any additional kwargs that can be passed to the `seaborn`&#39;s `stripplot`.     |      |

    &lt;br&gt;&lt;/br&gt;
    #### `&#34;interactive&#34;` Kwargs
    Interactive AssayDots figures accept the following kwargs:

    |   Argument  |  Description    |  Example    |
    | ---- | ---- | ---- |
    |  show : `bool`    |  Whether or not to show the figure    |  `show = True` (default)   |
    | title : `str`   |  The overall figure title   | `title = &#34;Today&#39;s results&#34;`    |
    | xlabel : `str`   |  The x axis label   | `xlabel = &#34;My super qPCR samples&#34;`    |
    | ylabel : `str`   |  The y axis label   | `ylabel = &#34;Mean of ddCt&#34;`    |
    |  height : `int`   |   Height of the figure   | `height = 50`    |
    |  width : `int`   |   Width of the figure   | `width = 50`    |
    |  padding : `float or tuple`   |   Padding between subplots. This can be a single float (interpreted as horizontal padding), or a tuple of (horizontal, vertical) paddings.   | `padding = 0.2`    |
    |  template : `str`   | The `plotly` template to use. Check out available templates [here](https://plotly.com/python/templates/).     | `template = &#34;plotly_dark&#34;`    |
    |    headers : `list` |  A list of titles for each subplot in the preview figure    | `headers = [&#34;transcript A&#34;, &#34;transcript B&#34;]`     |
    |   violin   : `bool` |  Show symmetric kde of the dots of each group (if True).   | `violin = False`    |
    |  hoverinfo : `str`   | The type of hoverinfo to display. By default just `&#34;y&#34;`. Learn more about plotly hoverinfo [here](https://plotly.com/python/hover-text-and-formatting/). Please, note that `hovertemplate` is not currently supported.  | `hoverinfo = &#34;name+y&#34;`    |
    |  **kwargs    | Any additional kwargs that can be passed to `plotly`&#39;s`graphs_objs.Violin()`.     |      |

    &#34;&#34;&#34;
    def __init__(self, mode:str):
        self._setup_default_params(
                                    static = defaults.static_PreviewDots, 
                                    interactive = defaults.interactive_PreviewDots
                                )
        # __init__ is going to require default_params to be already set!
        super().__init__(mode)

    def _static_plot(self, **kwargs):
        &#34;&#34;&#34;
        The static Preview Results Figure
        &#34;&#34;&#34;

        kwargs = self.update_params(kwargs)
        data = self._rep_data

        # get assays to plot
        assays = [ i for i in data.columns if i not in [ &#34;group&#34;, &#34;group_name&#34;, raw_col_names[0] ] ]

        # generate subplot layout
        ncols, nrows = gx.make_layout_from_list( assays )

        # get kwargs incompatible with the main plotting method
        title = aux.from_kwargs(&#34;title&#34;, None, kwargs, rm = True)
        headers = aux.from_kwargs(&#34;headers&#34;, assays, kwargs, rm = True)
        label_subplots = aux.from_kwargs(&#34;label_subplots&#34;, True, kwargs, rm = True)
        start_character = aux.from_kwargs(&#34;labeltype&#34;, &#34;A&#34;, kwargs, rm = True)
        show_spines = aux.from_kwargs(&#34;frame&#34;, True, kwargs, rm = True)
        show = aux.from_kwargs(&#34;show&#34;, True, kwargs, rm = True)
        show_violins = aux.from_kwargs(&#34;violin&#34;, True, kwargs, rm = True)
        rot = aux.from_kwargs(&#34;rot&#34;, None, kwargs, rm = True)
        alpha = aux.from_kwargs(&#34;alpha&#34;, 1, kwargs, rm = True)
        xlabel = aux.from_kwargs(&#34;xlabel&#34;, None, kwargs, rm = True)
        ylabel = aux.from_kwargs(&#34;ylabel&#34;, None, kwargs, rm = True)

        # generate a custom color palette in case color kwarg is provided
        palette = gx.generate_palette(kwargs)

        # set a seaborn style
        style = aux.from_kwargs(&#34;style&#34;, &#34;dark&#34;, kwargs, rm = True)
        sns.set_style( style )

        # make figure
        figsize = aux.from_kwargs(&#34;figsize&#34;, None, kwargs, rm = True)
        fig, axs = plt.subplots(nrows = nrows, ncols = ncols, figsize = figsize)
        fig.suptitle( title )

        # setup Coords
        Coords = gx.AxesCoords(fig, axs, (nrows, ncols))
        idx = 0
        for assay in assays: 

            try: 
                tmp_df = data[ [&#34;group&#34;, &#34;group_name&#34;, assay] ]
                tmp_df = tmp_df.sort_values(&#34;group&#34;)

                # now plot a new violin chart 
                subplot = Coords.subplot()

                if show_violins:
                    sns.violinplot(
                                    x = tmp_df[&#34;group_name&#34;],
                                    y = tmp_df[ assay ],
                                    color = None,
                                    inner = None, 
                                    palette = palette,
                                    ax = subplot,

                                )
                    for i in subplot.collections:
                        i.set_alpha( alpha * 0.3 )

                sns.stripplot(
                                x = tmp_df[&#34;group_name&#34;],
                                y = tmp_df[ assay ],
                                palette = palette,
                                alpha = alpha,
                                ax = subplot,
                                **kwargs
                            )
            
                subplot.set(
                            title = assay if headers is None else headers[idx],
                            xlabel = xlabel,
                            ylabel = ylabel,        
                        )

                # adjust xtick rotation   
                if rot is not None: 
                    align = &#34;center&#34; if rot == 0 else &#34;left&#34;
                    plt.setp( subplot.xaxis.get_majorticklabels(), rotation = -rot, ha=align, rotation_mode=&#34;anchor&#34;) 

                if not show_spines:
                    subplot.spines[&#34;right&#34;].set_visible(False)
                    subplot.spines[&#34;top&#34;].set_visible(False)
                    subplot.spines[&#34;left&#34;].set_linewidth(1.05)
                    subplot.spines[&#34;bottom&#34;].set_linewidth(1.05)

                # add ABCD... label to subplot
                if label_subplots:
                    self._add_subplot_label(idx, subplot, start_character)         

                Coords.increment()
                idx += 1
            except Exception as e:
                raise e 
                break
        
        plt.tight_layout()

        if show:
            plt.show()

        # print(&#34;&lt;&lt;&lt; Static Check &gt;&gt;&gt;&#34;)

        return fig 

    def _add_subplot_label(self, idx, subplot, start_character):
        &#34;&#34;&#34;
        Adds A B C ... to upper left corner of a subplot...
        It will start labelling at any arbitrary start_character
        &#34;&#34;&#34;
        subplot_label = chr(ord(start_character)+idx)
        subplot.annotate(
                            xy = (-0.1,1.03), 
                            text = subplot_label, 
                            xycoords = &#34;axes fraction&#34;,
                            weight = &#34;bold&#34;, fontsize = 12
                        )

    def _interactive_plot(self, **kwargs):
        &#34;&#34;&#34;
        The interactive Preview Results Figure
        &#34;&#34;&#34;

        kwargs = self.update_params(kwargs)
        data = self._rep_data

        # get assays to plot
        assays = [ i for i in data.columns if i not in [ &#34;group&#34;, &#34;group_name&#34;, raw_col_names[0] ] ]
        
        # get the info of groups present in the data
        # for later use as xtick labels
        group_names = data[ [&#34;group&#34;, &#34;group_name&#34;] ]
        group_names = group_names.sort_values( &#34;group&#34; )
        group_names = aux.sorted_set( group_names[ &#34;group_name&#34;] )
        ticks = np.arange( len(group_names) )

        # make subplot layout
        ncols, nrows = gx.make_layout_from_list( assays )

        try: 
            # get incompaltible kwargs 
            headers = aux.from_kwargs(&#34;headers&#34;, assays, kwargs, rm = True)
            show = aux.from_kwargs(&#34;show&#34;, True, kwargs, rm = True)
            show_violins = aux.from_kwargs(&#34;violin&#34;, True, kwargs, rm = True)

            # setup padding
            padding = aux.from_kwargs(&#34;padding&#34;, 0.1, kwargs, rm = True)
            if isinstance(padding, (list, tuple)):
                hpad, vpad = padding
            else: 
                hpad, vpad = padding, None

            # make figure
            speclist = gx.make_speclist(nrows, ncols, &#34;xy&#34;)
            fig = make_subplots(
                                    rows = nrows, cols = ncols, 
                                    specs = speclist, 
                                    subplot_titles = headers,
                                    horizontal_spacing = hpad,
                                    vertical_spacing = vpad
                            )

            # setup subplot coords handling
            Coords = gx.AxesCoords(fig, [], (ncols, nrows))

            # setup figure
            fig.update_layout(
                                title = aux.from_kwargs(&#34;title&#34;, &#34;Results Preview&#34;, kwargs, rm = True), 
                                height = aux.from_kwargs(&#34;height&#34;, None, kwargs, rm = True), 
                                width = aux.from_kwargs(&#34;width&#34;, None, kwargs, rm = True),
                                margin = {&#34;autoexpand&#34;: True, &#34;pad&#34; : 0, &#34;b&#34;: 1, &#34;t&#34;: 50}, 
                                autosize = True, 
                                template = aux.from_kwargs(&#34;template&#34;, &#34;plotly_white&#34;, kwargs, rm = True),
                                # legend = {  &#34;title&#34; : aux.from_kwargs(&#34;legend_title&#34;, &#34;Assay&#34;, kwargs, rm = True),  },
                                showlegend = False
                            )

            # set default axes labels
            xlabel = aux.from_kwargs(&#34;xlabel&#34;, &#34;&#34;, kwargs, rm = True) 
            fig.update_xaxes(title_text = xlabel)
            
            ylabel = aux.from_kwargs(&#34;ylabel&#34;, &#34;&#34;, kwargs, rm = True) 
            fig.update_yaxes(title_text = ylabel)

            idx = 0
            for assay, header in zip( assays, headers ):
                
                row, col = Coords.get()

                tmp_df = data[ [&#34;group&#34;, &#34;group_name&#34;, assay] ]
                tmp_df = tmp_df.sort_values(&#34;group&#34;)

                # now plot a new violin chart 
                fig.add_trace(

                    go.Violin(
                                    name = header,
                                    y = tmp_df[ assay ], x = tmp_df[ &#34;group&#34; ], 
                                    points = &#34;all&#34;,
                                    pointpos = 0,
                                    hoverinfo = aux.from_kwargs(&#34;hoverinfo&#34;, &#34;y&#34;, kwargs, rm = True), 
                                    **kwargs
                            ), 
                                    row, col
                        )

                # remove violins if not desired (leaving only dot plot)
                if not show_violins: 
                    fig.update_traces(
                                        fillcolor=&#34;rgba(0,0,0,0)&#34;, 
                                        line_width = 0, 
                                        selector=dict(type=&#39;violin&#39;),
                                    )


                # update x axis to categorical group names
                fig.update_layout(
                                    { 
                                        f&#34;xaxis{idx+1}&#34; : dict(
                                                                tickmode = &#39;array&#39;,
                                                                tickvals = ticks,
                                                                ticktext = group_names,
                                                        )         
                                    }
                                )

                Coords.increment()

                idx += 1

            if show:
                fig.show()

            # print(&#34;&lt;&lt;&lt; Interactive Check &gt;&gt;&gt;&#34;)
            return fig 
        except Exception as e: 
            raise e </code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="qpcr.Plotters.Plotters.Plotter" href="#qpcr.Plotters.Plotters.Plotter">Plotter</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="qpcr.Plotters.Plotters.Plotter" href="#qpcr.Plotters.Plotters.Plotter">Plotter</a></b></code>:
<ul class="hlist">
<li><code><a title="qpcr.Plotters.Plotters.Plotter.get" href="#qpcr.Plotters.Plotters.Plotter.get">get</a></code></li>
<li><code><a title="qpcr.Plotters.Plotters.Plotter.id" href="#qpcr.Plotters.Plotters.Plotter.id">id</a></code></li>
<li><code><a title="qpcr.Plotters.Plotters.Plotter.link" href="#qpcr.Plotters.Plotters.Plotter.link">link</a></code></li>
<li><code><a title="qpcr.Plotters.Plotters.Plotter.params" href="#qpcr.Plotters.Plotters.Plotter.params">params</a></code></li>
<li><code><a title="qpcr.Plotters.Plotters.Plotter.plot" href="#qpcr.Plotters.Plotters.Plotter.plot">plot</a></code></li>
<li><code><a title="qpcr.Plotters.Plotters.Plotter.save" href="#qpcr.Plotters.Plotters.Plotter.save">save</a></code></li>
<li><code><a title="qpcr.Plotters.Plotters.Plotter.suffix" href="#qpcr.Plotters.Plotters.Plotter.suffix">suffix</a></code></li>
<li><code><a title="qpcr.Plotters.Plotters.Plotter.update_params" href="#qpcr.Plotters.Plotters.Plotter.update_params">update_params</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="qpcr.Plotters.Plotters.EfficiencyLines"><code class="flex name class">
<span>class <span class="ident">EfficiencyLines</span></span>
<span>(</span><span>mode:Â str)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates a Figure for the linear regressions used for Assay efficiency
calculations. This FigureClass specifically works with the <code><a title="qpcr.Calibrator" href="../index.html#qpcr.Calibrator">Calibrator</a></code>
class. </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>mode</code></strong> :&ensp;<code>str</code></dt>
<dd>The plotting mode. May be either "static" (matplotlib) or "interactive" (plotly).</dd>
</dl>
<h2 id="plotting-kwargs">Plotting Kwargs</h2>
<h4 id="static-kwargs"><code>"static"</code> Kwargs</h4>
<p>Static EfficiencyLines figures accept the following kwargs:</p>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Description</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td>show : <code>bool</code></td>
<td>Whether or not to show the figure</td>
<td><code>show = True</code> (default)</td>
</tr>
<tr>
<td>figsize : <code>tuple</code></td>
<td>The figure size</td>
<td><code>figsize = (10, 4)</code></td>
</tr>
<tr>
<td>title : <code>str</code></td>
<td>The overall figure title</td>
<td>`title = "Today's efficiencies"</td>
</tr>
<tr>
<td>xlabel : <code>str</code></td>
<td>The x-axis label of each subplot</td>
<td><code>xlabel = "Log Dilution"</code></td>
</tr>
<tr>
<td>ylabel : <code>str</code></td>
<td>The y-axis label of each subplot</td>
<td><code>ylabel = "My Ct Values"</code></td>
</tr>
<tr>
<td>rot : <code>float</code></td>
<td>The rotation of x-axis labels</td>
<td><code>rot = 0.3</code></td>
</tr>
<tr>
<td>headers : <code>list</code></td>
<td>A list of titles for each subplot in the preview figure</td>
<td><code>headers = ["transcript A", "transcript B"]</code></td>
</tr>
<tr>
<td>label_subplots
: <code>bool</code></td>
<td>Add each subplot with A, B, C &hellip; (if True, default)</td>
<td><code>label_subplots = True</code> (default)</td>
</tr>
<tr>
<td>labeltype : <code>str</code></td>
<td>The starting character for subplot labelling. By default an <code>"A"</code>.</td>
<td><code>labeltype = "a"</code></td>
</tr>
<tr>
<td>frame
: <code>bool</code></td>
<td>Show left and top spines of subplots (if True)</td>
<td><code>frame = False</code> (default)</td>
</tr>
<tr>
<td>color : <code>str or list</code></td>
<td>The fillcolor for the individual bars</td>
<td><code>color = "yellow"</code></td>
</tr>
<tr>
<td>style : <code>str</code></td>
<td>A <code>seaborn</code> style to set. Check out available styles <a href="https://www.python-graph-gallery.com/104-seaborn-themes">here</a>.</td>
<td><code>style = "darkgrid"</code></td>
</tr>
<tr>
<td>edgecolor : <code>str or list</code></td>
<td>The edgecolor for the individual dots for the datapoints.</td>
<td><code>edgecolor = "black"</code></td>
</tr>
<tr>
<td>edgewidth : <code>float</code></td>
<td>The width of the edge of individual dots.</td>
<td><code>edgewidth = 0.5</code></td>
</tr>
<tr>
<td>linecolor : <code>str or list</code></td>
<td>The color for regression line.</td>
<td><code>linecolor = "crimson"</code></td>
</tr>
<tr>
<td>linewidth : <code>float</code></td>
<td>The width of the regression line.</td>
<td><code>edgewidth = 0.5</code></td>
</tr>
<tr>
<td>**kwargs</td>
<td>Any additional kwargs that can be passed to <code>seaborn</code>'s <code>scatterplot</code> and <code>lineplot</code> (both!).</td>
<td></td>
</tr>
</tbody>
</table>
<p><br></br></p>
<h4 id="interactive-kwargs"><code>"interactive"</code> Kwargs</h4>
<p>Interactive EfficiencyLines figures accept the following kwargs:</p>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Description</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td>show : <code>bool</code></td>
<td>Whether or not to show the figure</td>
<td><code>show = True</code> (default)</td>
</tr>
<tr>
<td>title : <code>str</code></td>
<td>The overall figure title</td>
<td><code>title = "Today's efficiencies"</code></td>
</tr>
<tr>
<td>xlabel : <code>str</code></td>
<td>The x axis label</td>
<td><code>xlabel = "Log Dilution"</code></td>
</tr>
<tr>
<td>ylabel : <code>str</code></td>
<td>The y axis label</td>
<td><code>ylabel = My super Ct values"</code></td>
</tr>
<tr>
<td>height : <code>int</code></td>
<td>Height of the figure</td>
<td><code>height = 50</code></td>
</tr>
<tr>
<td>width : <code>int</code></td>
<td>Width of the figure</td>
<td><code>width = 50</code></td>
</tr>
<tr>
<td>padding : <code>float or tuple</code></td>
<td>Padding between subplots. This can be a single float (interpreted as horizontal padding), or a tuple of (horizontal, vertical) paddings.</td>
<td><code>padding = 0.2</code></td>
</tr>
<tr>
<td>template : <code>str</code></td>
<td>The <code>plotly</code> template to use. Check out available templates <a href="https://plotly.com/python/templates/">here</a>.</td>
<td><code>template = "plotly_dark"</code></td>
</tr>
<tr>
<td>headers : <code>list</code></td>
<td>A list of titles for each subplot in the preview figure</td>
<td><code>headers = ["transcript A", "transcript B"]</code></td>
</tr>
<tr>
<td>hoverinfo : <code>str</code></td>
<td>The type of hoverinfo to display. By default just <code>"y+x"</code>. Learn more about plotly hoverinfo <a href="https://plotly.com/python/hover-text-and-formatting/">here</a>. Please, note that <code>hovertemplate</code> is not currently supported.</td>
<td><code>hoverinfo = "name+y"</code></td>
</tr>
<tr>
<td>**kwargs</td>
<td>Any additional kwargs that can be passed to <code>plotly</code>'s<code>graphs_objs.Scatter()</code>.</td>
<td></td>
</tr>
</tbody>
</table></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EfficiencyLines(Plotter):
    &#34;&#34;&#34;
    Generates a Figure for the linear regressions used for Assay efficiency 
    calculations. This FigureClass specifically works with the `qpcr.Calibrator` 
    class. 

    Parameters
    ----------
    mode : str
        The plotting mode. May be either &#34;static&#34; (matplotlib) or &#34;interactive&#34; (plotly).
    
    Plotting Kwargs
    ----

    #### `&#34;static&#34;` Kwargs
    Static EfficiencyLines figures accept the following kwargs:
    
    |   Argument  |  Description    |  Example    |
    | ---- | ---- | ---- |
    |  show : `bool`    |  Whether or not to show the figure    |  `show = True` (default)   |
    |   figsize : `tuple`   |  The figure size    | `figsize = (10, 4)`     |
    | title : `str`   |  The overall figure title   | `title = &#34;Today&#39;s efficiencies&#34;    |
    | xlabel : `str`| The x-axis label of each subplot | `xlabel = &#34;Log Dilution&#34;` |
    | ylabel : `str`| The y-axis label of each subplot | `ylabel = &#34;My Ct Values&#34;` |
    | rot : `float` | The rotation of x-axis labels | `rot = 0.3` |
    |    headers : `list` |  A list of titles for each subplot in the preview figure    | `headers = [&#34;transcript A&#34;, &#34;transcript B&#34;]`     |
    |  label_subplots  : `bool`   |   Add each subplot with A, B, C ... (if True, default)   | `label_subplots = True` (default)     |
    | labeltype : `str`| The starting character for subplot labelling. By default an `&#34;A&#34;`. | `labeltype = &#34;a&#34;` |
    |   frame   : `bool` |  Show left and top spines of subplots (if True)    | `frame = False` (default)     |
    |   color : `str or list`   | The fillcolor for the individual bars   | `color = &#34;yellow&#34;`     |
    |  style : `str`   | A `seaborn` style to set. Check out available styles [here](https://www.python-graph-gallery.com/104-seaborn-themes).     | `style = &#34;darkgrid&#34;`    |
    |   edgecolor : `str or list`   | The edgecolor for the individual dots for the datapoints.   | `edgecolor = &#34;black&#34;`     |
    |   edgewidth : `float`   |  The width of the edge of individual dots.  | `edgewidth = 0.5`     |
    |   linecolor : `str or list`   | The color for regression line.   | `linecolor = &#34;crimson&#34;`     |
    |   linewidth : `float`   |  The width of the regression line.  | `edgewidth = 0.5`     |
    |  **kwargs    | Any additional kwargs that can be passed to `seaborn`&#39;s `scatterplot` and `lineplot` (both!).     |      |

    &lt;br&gt;&lt;/br&gt;
    #### `&#34;interactive&#34;` Kwargs
    Interactive EfficiencyLines figures accept the following kwargs:

    |   Argument  |  Description    |  Example    |
    | ---- | ---- | ---- |
    |  show : `bool`    |  Whether or not to show the figure    |  `show = True` (default)   |
    | title : `str`   |  The overall figure title   | `title = &#34;Today&#39;s efficiencies&#34;`    |
    | xlabel : `str`   |  The x axis label   | `xlabel = &#34;Log Dilution&#34;`    |
    | ylabel : `str`   |  The y axis label   | `ylabel = My super Ct values&#34;`    |
    |  height : `int`   |   Height of the figure   | `height = 50`    |
    |  width : `int`   |   Width of the figure   | `width = 50`    |
    |  padding : `float or tuple`   |   Padding between subplots. This can be a single float (interpreted as horizontal padding), or a tuple of (horizontal, vertical) paddings.   | `padding = 0.2`    |
    |  template : `str`   | The `plotly` template to use. Check out available templates [here](https://plotly.com/python/templates/).     | `template = &#34;plotly_dark&#34;`    |
    |    headers : `list` |  A list of titles for each subplot in the preview figure    | `headers = [&#34;transcript A&#34;, &#34;transcript B&#34;]`     |
    |  hoverinfo : `str`   | The type of hoverinfo to display. By default just `&#34;y+x&#34;`. Learn more about plotly hoverinfo [here](https://plotly.com/python/hover-text-and-formatting/). Please, note that `hovertemplate` is not currently supported.  | `hoverinfo = &#34;name+y&#34;`    |
    |  **kwargs    | Any additional kwargs that can be passed to `plotly`&#39;s`graphs_objs.Scatter()`.     |      |


    &#34;&#34;&#34;
    def __init__(self, mode : str ):
        self._setup_default_params(
                                    static = defaults.static_EfficiencyLines, 
                                    interactive = defaults.interactive_EfficiencyLines
                                )
        super().__init__( mode = mode )
        self._Calibrator = None

    def link( self, calibrator : qpcr.Calibrator ):
        &#34;&#34;&#34;
        Links a `qpcr.Calibrator` object to source data from.

        Note
        -----
        Only a `qpcr.Calibrator` that has actually *de novo*
        computed efficiencies will have data to plot, and only for 
        the newly computed effiencies! 

        Parameters
        ----------
        calibrator : qpcr.Calibrator
            A `qpcr.Calibrator` object that has computed new efficiencies.
        &#34;&#34;&#34;
        self._Calibrator = calibrator
    
    def _static_plot(self, **kwargs):
        &#34;&#34;&#34;
        Generates a static Effiency Regression Figure
        &#34;&#34;&#34;
        kwargs = self.update_params(kwargs)
        data = self._Calibrator._computed_values
        headers = list(  data.keys()  )

        title = aux.from_kwargs(&#34;title&#34;, None, kwargs, rm = True)
        headers = aux.from_kwargs(&#34;headers&#34;, headers, kwargs, rm = True)
        label_subplots = aux.from_kwargs(&#34;label_subplots&#34;, True, kwargs, rm = True)
        start_character = aux.from_kwargs(&#34;labeltype&#34;, &#34;A&#34;, kwargs, rm = True)
        show_spines = aux.from_kwargs(&#34;frame&#34;, True, kwargs, rm = True)
        show = aux.from_kwargs(&#34;show&#34;, True, kwargs, rm = True)
        rot = aux.from_kwargs(&#34;rot&#34;, None, kwargs, rm = True)

        palette = gx.generate_palette(kwargs)

        xlabel = aux.from_kwargs(&#34;xlabel&#34;, None, kwargs, rm = True)
        ylabel = aux.from_kwargs(&#34;ylabel&#34;, None, kwargs, rm = True)

        # set a seaborn style
        style = aux.from_kwargs(&#34;style&#34;, &#34;ticks&#34;, kwargs, rm = True)
        sns.set_style( style )

        edgecolor = aux.from_kwargs(&#34;edgecolor&#34;, &#34;white&#34;, kwargs, rm = True)
        edgewidth = aux.from_kwargs(&#34;edgewidth&#34;, None, kwargs, rm = True)

        linecolor = aux.from_kwargs(&#34;linecolor&#34;, &#34;black&#34;, kwargs, rm = True)
        linewidth = aux.from_kwargs(&#34;linewidth&#34;, 1, kwargs, rm = True)

        ncols, nrows = gx.make_layout_from_list( headers )

        fig, axs = plt.subplots( nrows = nrows, ncols = ncols)
        fig.suptitle( title )
        Coords = gx.AxesCoords( fig, axs, subplots = (nrows, ncols) )

        idx = 0 
        for id, obj in data.items(): 
            
            ax = Coords.subplot()

            # get data to plot              
            dilutions, cts = obj.values()
            eff = obj.efficiency()
            model = obj.model()
            Rsquare = model.rvalue ** 2

            # plot the regression line
            yvals = model.slope * dilutions + model.intercept
            sns.lineplot(
                                x = dilutions,
                                y = yvals,
                                color = linecolor,
                                linewidth = linewidth,
                                ax = ax,
                                **kwargs
                    )

            # plot the original data
            sns.scatterplot(
                                x = dilutions,
                                y = cts,
                                palette = palette, 
                                edgecolor = edgecolor,
                                linewidth = edgewidth,
                                ax = ax,
                                **kwargs
                            )

            # add additional info to a legend
            ax.legend( handles = [
                                    # R^2 Value
                                    Line2D(  [0], [0], 
                                            color = &#34;black&#34;, 
                                            visible = False, 
                                            label = f&#34;$R^2$ \t = {Rsquare:.4f}&#34;
                                        ),
                                    # Efficiency Value
                                    Line2D(  [0], [0], 
                                            color = &#34;black&#34;, 
                                            visible = False, 
                                            label = f&#34;$eff.$\t= {eff:.4f}&#34;
                                        )
                                ], 
                                loc = &#34;upper right&#34;,
                                frameon = False 
                    )

            # some formatting...
            ax.set(
                    title = id, 
                    xlabel = xlabel,
                    ylabel = ylabel,
                )

            if rot is not None: 
                align = &#34;center&#34; if rot == 0 else &#34;left&#34;
                plt.setp( ax.xaxis.get_majorticklabels(), rotation = -rot, ha=align, rotation_mode=&#34;anchor&#34;) 

            # add ABCD... label to subplot
            if label_subplots:
                self._add_subplot_label(idx, ax, start_character)         

            if not show_spines:
                sns.despine()
            
            idx += 1
            Coords.increment()

        plt.tight_layout()
        if show: 
            plt.show()

        return fig 

    def _interactive_plot(self, **kwargs):
        &#34;&#34;&#34;
        Generates an interactive EfficiencyLines figure
        &#34;&#34;&#34;
        kwargs = self.update_params(kwargs)
        data = self._Calibrator._computed_values
        headers = list(  data.keys()  )

        title = aux.from_kwargs(&#34;title&#34;, None, kwargs, rm = True)
        headers = aux.from_kwargs(&#34;headers&#34;, headers, kwargs, rm = True)
        show = aux.from_kwargs(&#34;show&#34;, True, kwargs, rm = True)
        padding = aux.from_kwargs(&#34;padding&#34;, 0.1, kwargs, rm = True)

        if isinstance(padding, (list, tuple)):
            hpad, vpad = padding
        else: 
            hpad, vpad = padding, None

        # make new ncols and nrows based on the headers list
        nrows, ncols = gx.make_layout_from_list(headers)

        speclist = gx.make_speclist(nrows, ncols, &#34;xy&#34;)
        fig = make_subplots(
                                rows = nrows, cols = ncols, 
                                specs = speclist, 
                                subplot_titles = headers,
                                horizontal_spacing = hpad,
                                vertical_spacing = vpad
                        )


        Coords = gx.AxesCoords(fig, [], (ncols, nrows))

        fig.update_layout(
                    title = title, 
                    height = aux.from_kwargs(&#34;height&#34;, None, kwargs, rm = True), 
                    width = aux.from_kwargs(&#34;width&#34;, None, kwargs, rm = True),
                    margin = {&#34;autoexpand&#34;: True, &#34;pad&#34; : 0, &#34;b&#34;: 1, &#34;t&#34;: 50}, 
                    autosize = True, 
                    template = aux.from_kwargs(&#34;template&#34;, &#34;plotly_white&#34;, kwargs, rm = True),
                    # legend = {&#34;title&#34; : aux.from_kwargs(&#34;legend_title&#34;, &#34;Assay&#34;, kwargs, rm = True), },
                )

        # set default axes labels
        xlabel = aux.from_kwargs(&#34;xlabel&#34;, None, kwargs, rm = True) 
        fig.update_xaxes(title_text = xlabel)
        
        ylabel = aux.from_kwargs(&#34;ylabel&#34;, None, kwargs, rm = True) 
        fig.update_yaxes(title_text = ylabel)

        Coords = gx.AxesCoords(fig, [], (ncols, nrows))

        # iterate over the data...
        idx = 0 
        for id, obj in data.items():

            row, col = Coords.get()

            # get data to plot              
            dilutions, cts = obj.values()
            eff = obj.efficiency()
            model = obj.model()
            Rsquare = model.rvalue ** 2

            # plot the original data
            fig.add_trace(
                            go.Scatter(
                                name = id,
                                x = dilutions,
                                y = cts,  
                                mode = &#34;markers&#34;,
                                showlegend = False,
                                hoverinfo = aux.from_kwargs(&#34;hoverinfo&#34;, &#34;y+x&#34;, kwargs, rm = True), 
                                **kwargs
                            ), 
                            row, col
                        )
            
            # plot the regression line
            yvals = model.slope * dilutions + model.intercept

            fig.add_trace(
                            go.Scatter(
                                name = id,
                                x = dilutions,
                                y = yvals,  
                                mode = &#34;lines&#34;,
                                showlegend = False,
                                **kwargs
                            ), 
                            row, col
                        )


            # add infos as annotations (because custom legends don&#39;t work here)
            # NOTE: The xref x{idx} is a pretty nice lifehack to essentially 
            #       emulate the ax behaviour from matplotib.subplots... 
            xref = &#34;x&#34; if idx == 0 else f&#34;x{idx+1}&#34;
            yref = &#34;y&#34; if idx == 0 else f&#34;y{idx+1}&#34;
            info_text = f&#34;R^2 = {Rsquare:.4f}&lt;br&gt;eff. = {eff:.4f}&#34;

            fig.add_annotation(
                            dict(
                                    x = 0, 
                                    y = np.max( cts ), 
                                    xref = xref, 
                                    yref = yref, 
                                    text = info_text, 
                                    showarrow = False
                                )
                            )

            Coords.increment()
            idx += 1

        if show: 
            fig.show()

        return fig 



# if __name__ == &#39;__main__&#39;:

    # files = [&#34;Example Data/28S.csv&#34;, &#34;Example Data/28S_again.csv&#34;, &#34;Example Data/actin.csv&#34;,
    # &#34;Example Data/actin2.csv&#34;,
    # &#34;Example Data/actin3.csv&#34;,
    # &#34;Example Data/HNRNPL_nmd.csv&#34;, &#34;Example Data/HNRNPL_prot.csv&#34;]
    # groupnames = [&#34;wt-&#34;, &#34;wt+&#34;, &#34;ko-&#34;, &#34;ko+&#34;]

    # # setup figures
    # a = PreviewResults(mode = &#34;static&#34;)
    # b = PreviewResults(mode = &#34;interactive&#34;)

    # a.params(
    #       frame = True, labeltype = &#34;a&#34;, show = False
    # )
    # b.params(
    #     show = False, template = &#34;plotly&#34;  
    # )

    # # predefined pipeline use
    # pipe = qpcr.Pipes.Basic()
    # pipe.link(files)
    # pipe.add_normalisers(files[:2])
    # pipe.replicates(6)
    # pipe.names(groupnames)


    # print()
    # print(&#34;==== Multiple (ALL) Samples ====&#34;)
    # pipe.run()
    # result = pipe.get(kind = &#34;obj&#34;)
    # try:
    #     a.link(result)
    #     a.plot(color = &#34;green&#34;)
    # except: 
    #     print(&#34;Static Failed!&#34;)

    # try:
    #     b.link(result)
    #     b.plot()
    # except: print(&#34;Interactive Failed!&#34;)

    # print()
    # print(&#34;==== Multiple (7) Samples ====&#34;)
    # pipe.link(files[:7])
    # pipe.run()
    # result = pipe.get(kind = &#34;obj&#34;)
    # try:
    #     a.link(result)
    #     a.plot(show = False)
    # except: 
    #     print(&#34;Static Failed!&#34;)

    # try:
    #     b.link(result)
    #     b.plot(template = &#34;plotly&#34;)
    # except: print(&#34;Interactive Failed!&#34;)

    # print()
    # print(&#34;==== Multiple (6) Samples ====&#34;)
    # pipe.link(files[:6])
    # pipe.run()
    # result = pipe.get(kind = &#34;obj&#34;)
    # try:
    #     a.link(result)
    #     a.plot()
    # except: 
    #     print(&#34;Static Failed!&#34;)

    # try:
    #     b.link(result)
    #     b.plot()
    # except: print(&#34;Interactive Failed!&#34;)

    # print()
    # print(&#34;==== Multiple (4) Samples ====&#34;)
    # pipe.link(files[:4])
    # pipe.run()
    # result = pipe.get(kind = &#34;obj&#34;)
    # try:
    #     a.link(result)
    #     a.plot()
    # except: 
    #     print(&#34;Static Failed!&#34;)

    # try:
    #     b.link(result)
    #     b.plot()
    # except: print(&#34;Interactive Failed!&#34;)

    # print()
    # print(&#34;==== Multiple (3) Samples ====&#34;)
    # pipe.link(files[:3])
    # pipe.run()
    # result = pipe.get(kind = &#34;obj&#34;)
    # try:
    #     a.link(result)
    #     a.plot()
    # except Exception as e: 
    #     print(e)
    #     print(&#34;Static Failed!&#34;)

    # try:
    #     b.link(result)
    #     b.plot()
    # except Exception as e: 
    #     print(&#34;Interactive Failed!&#34;)
    #     raise e

    # print()
    # print(&#34;==== Multiple (2) Samples ====&#34;)
    # pipe.link(files[:2])
    # pipe.run()
    # result = pipe.get(kind = &#34;obj&#34;)
    # try:
    #     a.link(result)
    #     a.plot(show = False)
    # except Exception as e: 
    #     print(e)
    #     print(&#34;Static Failed!&#34;)

    # try:
    #     b.link(result)
    #     b.plot(show = False)
    # except Exception as e: 
    #     print(&#34;Interactive Failed!&#34;)
    #     raise e


    # print()
    # print(&#34;==== One (1) Sample ====&#34;)
    # pipe.link([files[0]])
    # pipe.run()
    # result = pipe.get(kind = &#34;obj&#34;)
    # try:
    #     a.link(result)
    #     a.plot()
    # except: 
    #     print(&#34;Static Failed!&#34;)

    # try:
    #     b.link(result)
    #     b.plot()
    # except: print(&#34;Interactive Failed!&#34;)
    # exit(0)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="qpcr.Plotters.Plotters.Plotter" href="#qpcr.Plotters.Plotters.Plotter">Plotter</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="qpcr.Plotters.Plotters.EfficiencyLines.link"><code class="name flex">
<span>def <span class="ident">link</span></span>(<span>self, calibrator:Â qpcr.__init__.Calibrator)</span>
</code></dt>
<dd>
<div class="desc"><p>Links a <code><a title="qpcr.Calibrator" href="../index.html#qpcr.Calibrator">Calibrator</a></code> object to source data from.</p>
<h2 id="note">Note</h2>
<p>Only a <code><a title="qpcr.Calibrator" href="../index.html#qpcr.Calibrator">Calibrator</a></code> that has actually <em>de novo</em>
computed efficiencies will have data to plot, and only for
the newly computed effiencies! </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>calibrator</code></strong> :&ensp;<code><a title="qpcr.Calibrator" href="../index.html#qpcr.Calibrator">Calibrator</a></code></dt>
<dd>A <code><a title="qpcr.Calibrator" href="../index.html#qpcr.Calibrator">Calibrator</a></code> object that has computed new efficiencies.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def link( self, calibrator : qpcr.Calibrator ):
    &#34;&#34;&#34;
    Links a `qpcr.Calibrator` object to source data from.

    Note
    -----
    Only a `qpcr.Calibrator` that has actually *de novo*
    computed efficiencies will have data to plot, and only for 
    the newly computed effiencies! 

    Parameters
    ----------
    calibrator : qpcr.Calibrator
        A `qpcr.Calibrator` object that has computed new efficiencies.
    &#34;&#34;&#34;
    self._Calibrator = calibrator</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="qpcr.Plotters.Plotters.Plotter" href="#qpcr.Plotters.Plotters.Plotter">Plotter</a></b></code>:
<ul class="hlist">
<li><code><a title="qpcr.Plotters.Plotters.Plotter.get" href="#qpcr.Plotters.Plotters.Plotter.get">get</a></code></li>
<li><code><a title="qpcr.Plotters.Plotters.Plotter.id" href="#qpcr.Plotters.Plotters.Plotter.id">id</a></code></li>
<li><code><a title="qpcr.Plotters.Plotters.Plotter.params" href="#qpcr.Plotters.Plotters.Plotter.params">params</a></code></li>
<li><code><a title="qpcr.Plotters.Plotters.Plotter.plot" href="#qpcr.Plotters.Plotters.Plotter.plot">plot</a></code></li>
<li><code><a title="qpcr.Plotters.Plotters.Plotter.save" href="#qpcr.Plotters.Plotters.Plotter.save">save</a></code></li>
<li><code><a title="qpcr.Plotters.Plotters.Plotter.suffix" href="#qpcr.Plotters.Plotters.Plotter.suffix">suffix</a></code></li>
<li><code><a title="qpcr.Plotters.Plotters.Plotter.update_params" href="#qpcr.Plotters.Plotters.Plotter.update_params">update_params</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="qpcr.Plotters.Plotters.FilterSummary"><code class="flex name class">
<span>class <span class="ident">FilterSummary</span></span>
<span>(</span><span>mode)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates a summary figure of the replicate
Ct values for each assay before and after filtering.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>mode</code></strong> :&ensp;<code>str</code></dt>
<dd>The plotting mode. May be either "static" (matplotlib) or "interactive" (plotly).</dd>
</dl>
<h4 id="static-kwargs"><code>"static"</code> Kwargs</h4>
<p>Static FilterSummary figures accept the following kwargs:</p>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Description</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td>show : <code>bool</code></td>
<td>Whether or not to show the figure</td>
<td><code>show = True</code> (default)</td>
</tr>
<tr>
<td>figsize : <code>tuple</code></td>
<td>The figure size</td>
<td><code>figsize = (10, 4)</code></td>
</tr>
<tr>
<td>subplots : <code>tuple</code></td>
<td>A tuple specifying the number of colums and rows (in that order) for the figure</td>
<td><code>subplots = (2, 3)</code></td>
</tr>
<tr>
<td>title : <code>str</code></td>
<td>The overall figure title</td>
<td>`title = "Today's run"</td>
</tr>
<tr>
<td>xlabel : <code>str</code></td>
<td>The x-axis label of each subplot</td>
<td><code>xlabel = "Conditions"</code></td>
</tr>
<tr>
<td>ylabel : <code>str</code></td>
<td>The y-axis label of each subplot</td>
<td><code>ylabel = "My Ct values"</code></td>
</tr>
<tr>
<td>rot : <code>float</code></td>
<td>The rotation of x-axis labels</td>
<td><code>rot = 0.3</code></td>
</tr>
<tr>
<td>frame
: <code>bool</code></td>
<td>Show left and top spines of subplots (if True)</td>
<td><code>frame = False</code> (default)</td>
</tr>
<tr>
<td>style : <code>str</code></td>
<td>A <code>seaborn</code> style to set. Check out available styles <a href="https://www.python-graph-gallery.com/104-seaborn-themes">here</a>.</td>
<td><code>style = "darkgrid"</code></td>
</tr>
<tr>
<td>color : <code>str or list</code></td>
<td>The color for the boxes.</td>
<td><code>color = ["yellow", "green"]</code></td>
</tr>
<tr>
<td>**kwargs</td>
<td>Any additional kwargs that can be passed to the <code>seaborn</code>'s <code>boxplot()</code>.</td>
<td></td>
</tr>
</tbody>
</table>
<p><br></br></p>
<h4 id="interactive-kwargs"><code>"interactive"</code> Kwargs</h4>
<p>Interactive FilterSummary figures accept the following kwargs:</p>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Description</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td>show : <code>bool</code></td>
<td>Whether or not to show the figure</td>
<td><code>show = True</code> (default)</td>
</tr>
<tr>
<td>title : <code>str</code></td>
<td>The overall figure title</td>
<td><code>title = "Today's run"</code></td>
</tr>
<tr>
<td>ylabel : <code>str</code></td>
<td>The y axis label</td>
<td><code>ylabel = "Raw Ct values"</code></td>
</tr>
<tr>
<td>height : <code>int</code></td>
<td>Height of the figure</td>
<td><code>height = 50</code></td>
</tr>
<tr>
<td>width : <code>int</code></td>
<td>Width of the figure</td>
<td><code>width = 50</code></td>
</tr>
<tr>
<td>padding : <code>float or tuple</code></td>
<td>Padding between subplots. This can be a single float (interpreted as horizontal padding), or a tuple of (horizontal, vertical) paddings.</td>
<td><code>padding = 0.2</code></td>
</tr>
<tr>
<td>colors : <code>list</code></td>
<td>List of two colors for <em>before</em> and <em>after</em> filtering boxes.</td>
<td><code>colors = ["red", "green"]</code></td>
</tr>
<tr>
<td>template : <code>str</code></td>
<td>The <code>plotly</code> template to use. Check out available templates <a href="https://plotly.com/python/templates/">here</a>.</td>
<td><code>template = "plotly_dark"</code></td>
</tr>
<tr>
<td>headers : <code>list</code></td>
<td>A list of titles for each subplot in the preview figure</td>
<td><code>headers = ["transcript A", "transcript B"]</code></td>
</tr>
<tr>
<td>hoverinfo : <code>str</code></td>
<td>The type of hoverinfo to display. By default <code>"y+x+name"</code>. Learn more about plotly hoverinfo <a href="https://plotly.com/python/hover-text-and-formatting/">here</a>. Please, note that <code>hovertemplate</code> is not currently supported.</td>
<td><code>hoverinfo = "name+y"</code></td>
</tr>
<tr>
<td>**kwargs</td>
<td>Any additional kwargs that can be passed to <code>plotly</code>'s<code>graphs_objs.Box()</code>.</td>
<td></td>
</tr>
</tbody>
</table></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FilterSummary(Plotter):
    &#34;&#34;&#34;
    Generates a summary figure of the replicate
    Ct values for each assay before and after filtering.

    Parameters
    ----------
    mode : str
        The plotting mode. May be either &#34;static&#34; (matplotlib) or &#34;interactive&#34; (plotly).


    
    #### `&#34;static&#34;` Kwargs
    Static FilterSummary figures accept the following kwargs:
    
    |   Argument  |  Description    |  Example    |
    | ---- | ---- | ---- |
    |  show : `bool`    |  Whether or not to show the figure    |  `show = True` (default)   |
    |   figsize : `tuple`   |  The figure size    | `figsize = (10, 4)`     |
    |   subplots : `tuple`   |  A tuple specifying the number of colums and rows (in that order) for the figure    | `subplots = (2, 3)`     |
    | title : `str`   |  The overall figure title   | `title = &#34;Today&#39;s run&#34;    |
    | xlabel : `str`| The x-axis label of each subplot | `xlabel = &#34;Conditions&#34;` |
    | ylabel : `str`| The y-axis label of each subplot | `ylabel = &#34;My Ct values&#34;` |
    | rot : `float` | The rotation of x-axis labels | `rot = 0.3` |
    |   frame   : `bool` |  Show left and top spines of subplots (if True)    | `frame = False` (default)     |
    |  style : `str`   | A `seaborn` style to set. Check out available styles [here](https://www.python-graph-gallery.com/104-seaborn-themes).     | `style = &#34;darkgrid&#34;`    |
    |   color : `str or list`   | The color for the boxes.   | `color = [&#34;yellow&#34;, &#34;green&#34;]`     |
    |  **kwargs    | Any additional kwargs that can be passed to the `seaborn`&#39;s `boxplot()`.     |      |
  
    &lt;br&gt;&lt;/br&gt;
    #### `&#34;interactive&#34;` Kwargs
    Interactive FilterSummary figures accept the following kwargs:

    |   Argument  |  Description    |  Example    |
    | ---- | ---- | ---- |
    |  show : `bool`    |  Whether or not to show the figure    |  `show = True` (default)   |
    | title : `str`   |  The overall figure title   | `title = &#34;Today&#39;s run&#34;`    |
    | ylabel : `str`   |  The y axis label   | `ylabel = &#34;Raw Ct values&#34;`    |
    |  height : `int`   |   Height of the figure   | `height = 50`    |
    |  width : `int`   |   Width of the figure   | `width = 50`    |
    |  padding : `float or tuple`   |   Padding between subplots. This can be a single float (interpreted as horizontal padding), or a tuple of (horizontal, vertical) paddings.   | `padding = 0.2`    |
    |  colors : `list`   |   List of two colors for _before_ and _after_ filtering boxes. | `colors = [&#34;red&#34;, &#34;green&#34;]`    |
    |  template : `str`   | The `plotly` template to use. Check out available templates [here](https://plotly.com/python/templates/).     | `template = &#34;plotly_dark&#34;`    |
    |  headers : `list` |  A list of titles for each subplot in the preview figure    | `headers = [&#34;transcript A&#34;, &#34;transcript B&#34;]`     |
    |  hoverinfo : `str`   | The type of hoverinfo to display. By default `&#34;y+x+name&#34;`. Learn more about plotly hoverinfo [here](https://plotly.com/python/hover-text-and-formatting/). Please, note that `hovertemplate` is not currently supported.  | `hoverinfo = &#34;name+y&#34;`    |
    |  **kwargs    | Any additional kwargs that can be passed to `plotly`&#39;s`graphs_objs.Box()`.     |      |


    &#34;&#34;&#34;
    def __init__(self, mode):
        self._setup_default_params(
                                    static = defaults.static_FilterSummary,
                                    interactive = defaults.interactive_FilterSummary
                                )
        super().__init__( mode = mode)
        self._before = qpcr.Results()
        self._after = qpcr.Results()

    def clear(self):
        &#34;&#34;&#34;
        Clears the pre- and post-filtering Ct value records.
        &#34;&#34;&#34;
        self._before = qpcr.Results()
        self._after = qpcr.Results()

    def add_before(self, assay : qpcr.Assay ):
        &#34;&#34;&#34;
        Add a pre-filtered set of Ct values
        from an `qpcr.Assay` object. 

        Parameters
        ----------
        assay : qpcr.Assay
            An `qpcr.Assay` object
        &#34;&#34;&#34;
        # setup groups and stuff information 
        if self._before.is_empty():
            self._before.adopt_names( assay )
            self._after.adopt_names( assay )

        self._before.add_Ct( assay )
    
    def add_after(self, assay : qpcr.Assay ):
        &#34;&#34;&#34;
        Add a post-filtered set of Ct values
        from an `qpcr.Assay` object. 

        Parameters
        ----------
        assay : qpcr.Assay
            An `qpcr.Assay` object
        &#34;&#34;&#34;
        self._after.add_Ct( assay )


    def _interactive_plot(self, **kwargs):
        &#34;&#34;&#34;
        Generates an interactive Filter Summary Figure
        &#34;&#34;&#34;
        kwargs = self.update_params(kwargs)

        show = aux.from_kwargs(&#34;show&#34;, True, kwargs, rm = True)
        template = aux.from_kwargs(&#34;template&#34;, None, kwargs, rm=True)
        title = aux.from_kwargs(&#34;title&#34;, None, kwargs, rm=True)
        padding = aux.from_kwargs(&#34;padding&#34;, 0.1, kwargs, rm = True)
        
        # setup color scheme
        colors = aux.from_kwargs(&#34;colors&#34;, [&#34;blue&#34;, &#34;crimson&#34;], kwargs, rm = True)
        before_color, after_color = colors

        if isinstance(padding, (list, tuple)):
            hpad, vpad = padding
        else: 
            hpad, vpad = padding, None

        # get the data
        before = self._before.get()
        after = self._after.get()

        # get the number of assays to visualse
        assays = [ i for i in before.columns if i not in [ &#34;group&#34;, &#34;group_name&#34;, raw_col_names[0]] ]
        headers = aux.from_kwargs(&#34;headers&#34;, assays, kwargs, rm = True)

        # each assay will be on its own plot,
        ncols, nrows = gx.make_layout_from_list( assays )
        
        speclist = gx.make_speclist(nrows, ncols, &#34;xy&#34;)
        fig = make_subplots(
                                rows = nrows, cols = ncols, 
                                specs = speclist, 
                                subplot_titles = headers,
                                horizontal_spacing = hpad,
                                vertical_spacing = vpad,
                                # sharex = True
                        )
        
        fig.update_layout(
                            boxmode=&#34;group&#34;, 
                            height = aux.from_kwargs(&#34;height&#34;, None, kwargs, rm = True), 
                            width = aux.from_kwargs(&#34;width&#34;, None, kwargs, rm = True),
                            template = template, 
                            title = title,
                        )

        # add default ylabel
        ylabel = aux.from_kwargs(&#34;ylabel&#34;, &#34;Ct&#34;, kwargs, rm = True) 
        fig.update_yaxes(title_text = ylabel)
        
        Coords = gx.AxesCoords(fig, [], (ncols, nrows))

        show_legend = True
        # now iterate over each assay and make a BoxPlot
        for assay in assays : 
            
            # get before and after filter datasets for each assay
            pre_Cts = before[ [&#34;group&#34;, &#34;group_name&#34;, assay] ]
            post_Cts = after[ [&#34;group&#34;, &#34;group_name&#34;, assay] ]
            
            row, col = Coords.get()

            # pre-filter boxes 
            fig.add_trace(
                            go.Box(
                                x = pre_Cts[&#34;group_name&#34;],
                                y = pre_Cts[ assay ],
                                name = &#34;Before&#34;,
                                hoverinfo = &#34;y+x+name&#34;,
                                marker_color = before_color,
                                legendgroup=&#39;group1&#39;,
                                showlegend = show_legend,
                                **kwargs,
                            ),
                            row, col
                        )
            # post-filter boxes
            fig.add_trace(
                            go.Box(
                                x = post_Cts[&#34;group_name&#34;],
                                y = post_Cts[ assay ],
                                name = &#34;After&#34;,
                                hoverinfo = &#34;y+x+name&#34;,
                                marker_color = after_color,
                                legendgroup=&#39;group2&#39;,
                                showlegend = show_legend,
                                **kwargs,
                            ),
                            row, col
                        )

            Coords.increment()

            # set show_legend to False after the first assay,
            # to avoid repetitive legends...
            show_legend = False

        fig.update_layout( showlegend = True )
        if show:
            fig.show()

        return fig 


    def _static_plot(self, **kwargs):
        &#34;&#34;&#34;
        Generates a static Filter Summary Fig
        &#34;&#34;&#34;
        kwargs = self.update_params(kwargs)

        show = aux.from_kwargs(&#34;show&#34;, True, kwargs, rm = True)
        figsize = aux.from_kwargs(&#34;figsize&#34;, (7,5), kwargs, rm=True)
        title = aux.from_kwargs(&#34;title&#34;, None, kwargs, rm=True)
        ylabel = aux.from_kwargs(&#34;ylabel&#34;, &#34;Ct&#34;, kwargs, rm = True)
        xlabel = aux.from_kwargs(&#34;xlabel&#34;, &#34;&#34;, kwargs, rm = True)
        rot = aux.from_kwargs(&#34;rot&#34;,None, kwargs, rm = True)
        show_spines = aux.from_kwargs(&#34;frame&#34;, True, kwargs, rm = True)
        palette = gx.generate_palette(kwargs)

        # set a seaborn style
        style = aux.from_kwargs(&#34;style&#34;, &#34;ticks&#34;, kwargs, rm = True)
        sns.set_style( style )

        # get the data
        before = self._before.get()
        after = self._after.get()

        # get the number of assays to visualse
        assays = [ i for i in before.columns if i not in [ &#34;group&#34;, &#34;group_name&#34;, raw_col_names[0]] ]
        headers = aux.from_kwargs(&#34;headers&#34;, assays, kwargs, rm = True)

        # each assay will be on its own plot
        ncols, nrows = gx.make_layout_from_list( assays )

        ncols, nrows = aux.from_kwargs(&#34;subplots&#34;, (ncols, nrows), kwargs, rm=True)


        fig, axs = plt.subplots(nrows = nrows, ncols = ncols, figsize=figsize)
        
        # possibly nrows and ncols should be switched...
        Coords = gx.AxesCoords(fig, axs, (nrows, ncols))

        # set a kind column for grouping in the boxplots
        before[ &#34;kind&#34; ] = &#34;before&#34; 
        after[ &#34;kind&#34; ] = &#34;after&#34;

        show_legend = True
        for assay, header in zip( assays, headers ): 

            # get before and after filter datasets for each assay
            pre_Cts = before[ [&#34;group&#34;, &#34;group_name&#34;, &#34;kind&#34;, assay] ]
            post_Cts = after[ [&#34;group&#34;, &#34;group_name&#34;, &#34;kind&#34;, assay] ]

            # assemble data to one dataframe
            df = pd.concat( (pre_Cts, post_Cts) )

            # get the new subplot
            try: 
                ax = Coords.subplot()
            except: 
                print(&#34;We ran out of axes ... &#34;)
                break

            # main box plot
            sns.boxplot(
                        data = df, 
                        x = &#34;group_name&#34;,
                        y = assay,
                        hue = &#34;kind&#34;,
                        palette = palette, 
                        ax = ax,
                        **kwargs
                    )
            
            # format the subplot
            ax.set(title = header, ylabel = ylabel, xlabel = xlabel)
            if rot is not None and rot != 0 :
                plt.setp( ax.xaxis.get_majorticklabels(), rotation = -rot, ha=&#34;left&#34;, rotation_mode=&#34;anchor&#34;) 
            if not show_legend: 
                ax.legend().remove()
            else:
                ax.legend( bbox_to_anchor=(1,1), loc = None, frameon = False )
            show_legend = False

            Coords.increment()

        if not show_spines: 
            sns.despine()

        fig.suptitle(title)

        plt.tight_layout()
        if show: 
            plt.show()

        return fig</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="qpcr.Plotters.Plotters.Plotter" href="#qpcr.Plotters.Plotters.Plotter">Plotter</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="qpcr.Plotters.Plotters.FilterSummary.add_after"><code class="name flex">
<span>def <span class="ident">add_after</span></span>(<span>self, assay:Â qpcr.__init__.Assay)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a post-filtered set of Ct values
from an <code><a title="qpcr.Assay" href="../index.html#qpcr.Assay">Assay</a></code> object. </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>assay</code></strong> :&ensp;<code><a title="qpcr.Assay" href="../index.html#qpcr.Assay">Assay</a></code></dt>
<dd>An <code><a title="qpcr.Assay" href="../index.html#qpcr.Assay">Assay</a></code> object</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_after(self, assay : qpcr.Assay ):
    &#34;&#34;&#34;
    Add a post-filtered set of Ct values
    from an `qpcr.Assay` object. 

    Parameters
    ----------
    assay : qpcr.Assay
        An `qpcr.Assay` object
    &#34;&#34;&#34;
    self._after.add_Ct( assay )</code></pre>
</details>
</dd>
<dt id="qpcr.Plotters.Plotters.FilterSummary.add_before"><code class="name flex">
<span>def <span class="ident">add_before</span></span>(<span>self, assay:Â qpcr.__init__.Assay)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a pre-filtered set of Ct values
from an <code><a title="qpcr.Assay" href="../index.html#qpcr.Assay">Assay</a></code> object. </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>assay</code></strong> :&ensp;<code><a title="qpcr.Assay" href="../index.html#qpcr.Assay">Assay</a></code></dt>
<dd>An <code><a title="qpcr.Assay" href="../index.html#qpcr.Assay">Assay</a></code> object</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_before(self, assay : qpcr.Assay ):
    &#34;&#34;&#34;
    Add a pre-filtered set of Ct values
    from an `qpcr.Assay` object. 

    Parameters
    ----------
    assay : qpcr.Assay
        An `qpcr.Assay` object
    &#34;&#34;&#34;
    # setup groups and stuff information 
    if self._before.is_empty():
        self._before.adopt_names( assay )
        self._after.adopt_names( assay )

    self._before.add_Ct( assay )</code></pre>
</details>
</dd>
<dt id="qpcr.Plotters.Plotters.FilterSummary.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Clears the pre- and post-filtering Ct value records.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear(self):
    &#34;&#34;&#34;
    Clears the pre- and post-filtering Ct value records.
    &#34;&#34;&#34;
    self._before = qpcr.Results()
    self._after = qpcr.Results()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="qpcr.Plotters.Plotters.Plotter" href="#qpcr.Plotters.Plotters.Plotter">Plotter</a></b></code>:
<ul class="hlist">
<li><code><a title="qpcr.Plotters.Plotters.Plotter.get" href="#qpcr.Plotters.Plotters.Plotter.get">get</a></code></li>
<li><code><a title="qpcr.Plotters.Plotters.Plotter.id" href="#qpcr.Plotters.Plotters.Plotter.id">id</a></code></li>
<li><code><a title="qpcr.Plotters.Plotters.Plotter.link" href="#qpcr.Plotters.Plotters.Plotter.link">link</a></code></li>
<li><code><a title="qpcr.Plotters.Plotters.Plotter.params" href="#qpcr.Plotters.Plotters.Plotter.params">params</a></code></li>
<li><code><a title="qpcr.Plotters.Plotters.Plotter.plot" href="#qpcr.Plotters.Plotters.Plotter.plot">plot</a></code></li>
<li><code><a title="qpcr.Plotters.Plotters.Plotter.save" href="#qpcr.Plotters.Plotters.Plotter.save">save</a></code></li>
<li><code><a title="qpcr.Plotters.Plotters.Plotter.suffix" href="#qpcr.Plotters.Plotters.Plotter.suffix">suffix</a></code></li>
<li><code><a title="qpcr.Plotters.Plotters.Plotter.update_params" href="#qpcr.Plotters.Plotters.Plotter.update_params">update_params</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="qpcr.Plotters.Plotters.GroupBars"><code class="flex name class">
<span>class <span class="ident">GroupBars</span></span>
<span>(</span><span>mode:Â str)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates a Bar plot figure with a separate subplot for each group. </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>mode</code></strong> :&ensp;<code>str</code></dt>
<dd>The plotting mode. May be either "static" (matplotlib) or "interactive" (plotly).</dd>
</dl>
<h2 id="plotting-kwargs">Plotting Kwargs</h2>
<h4 id="static-kwargs"><code>"static"</code> Kwargs</h4>
<p>Static GroupBars figures accept the following kwargs:</p>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Description</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td>show : <code>bool</code></td>
<td>Whether or not to show the figure</td>
<td><code>show = True</code> (default)</td>
</tr>
<tr>
<td>figsize : <code>tuple</code></td>
<td>The figure size</td>
<td><code>figsize = (10, 4)</code></td>
</tr>
<tr>
<td>title : <code>str</code></td>
<td>The overall figure title</td>
<td>`title = "Today's results"</td>
</tr>
<tr>
<td>xlabel : <code>str</code></td>
<td>The x-axis label of each subplot</td>
<td><code>xlabel = "Conditions"</code></td>
</tr>
<tr>
<td>ylabel : <code>str</code></td>
<td>The y-axis label of each subplot</td>
<td><code>ylabel = "Mean $\Delta\Delta Ct$"</code></td>
</tr>
<tr>
<td>rot : <code>float</code></td>
<td>The rotation of x-axis labels</td>
<td><code>rot = 0.3</code></td>
</tr>
<tr>
<td>headers : <code>list</code></td>
<td>A list of titles for each subplot in the preview figure</td>
<td><code>headers = ["transcript A", "transcript B"]</code></td>
</tr>
<tr>
<td>label_subplots
: <code>bool</code></td>
<td>Add each subplot with A, B, C &hellip; (if True, default)</td>
<td><code>label_subplots = True</code> (default)</td>
</tr>
<tr>
<td>labeltype : <code>str</code></td>
<td>The starting character for subplot labelling. By default an <code>"A"</code>.</td>
<td><code>labeltype = "a"</code></td>
</tr>
<tr>
<td>frame
: <code>bool</code></td>
<td>Show left and top spines of subplots (if True)</td>
<td><code>frame = False</code> (default)</td>
</tr>
<tr>
<td>color : <code>str or list</code></td>
<td>The fillcolor for the individual bars</td>
<td><code>color = "yellow"</code></td>
</tr>
<tr>
<td>style : <code>str</code></td>
<td>A <code>seaborn</code> style to set. Check out available styles <a href="https://www.python-graph-gallery.com/104-seaborn-themes">here</a>.</td>
<td><code>style = "darkgrid"</code></td>
</tr>
<tr>
<td>edgecolor : <code>str or list</code></td>
<td>The edgecolor for the individual bars</td>
<td><code>edgecolor = "black"</code></td>
</tr>
<tr>
<td>edgewidth : <code>float</code></td>
<td>The width of the edge of individual bars</td>
<td><code>edgewidth = 0.5</code></td>
</tr>
<tr>
<td>ecolor : <code>str</code></td>
<td>The color of errorbars</td>
<td><code>ecolor = "orange"</code></td>
</tr>
<tr>
<td>**kwargs</td>
<td>Any additional kwargs that can be passed to the <code>matplotlib</code>-backend pandas <code>.plot.bar()</code> API.</td>
<td></td>
</tr>
</tbody>
</table>
<p><br></br></p>
<h4 id="interactive-kwargs"><code>"interactive"</code> Kwargs</h4>
<p>Interactive GroupBars figures accept the following kwargs:</p>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Description</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td>show : <code>bool</code></td>
<td>Whether or not to show the figure</td>
<td><code>show = True</code> (default)</td>
</tr>
<tr>
<td>title : <code>str</code></td>
<td>The overall figure title</td>
<td><code>title = "Today's results"</code></td>
</tr>
<tr>
<td>xlabel : <code>str</code></td>
<td>The x axis label</td>
<td><code>xlabel = "My super qPCR samples"</code></td>
</tr>
<tr>
<td>ylabel : <code>str</code></td>
<td>The y axis label</td>
<td><code>ylabel = "Mean of ddCt"</code></td>
</tr>
<tr>
<td>height : <code>int</code></td>
<td>Height of the figure</td>
<td><code>height = 50</code></td>
</tr>
<tr>
<td>width : <code>int</code></td>
<td>Width of the figure</td>
<td><code>width = 50</code></td>
</tr>
<tr>
<td>padding : <code>float or tuple</code></td>
<td>Padding between subplots. This can be a single float (interpreted as horizontal padding), or a tuple of (horizontal, vertical) paddings.</td>
<td><code>padding = 0.2</code></td>
</tr>
<tr>
<td>template : <code>str</code></td>
<td>The <code>plotly</code> template to use. Check out available templates <a href="https://plotly.com/python/templates/">here</a>.</td>
<td><code>template = "plotly_dark"</code></td>
</tr>
<tr>
<td>headers : <code>list</code></td>
<td>A list of titles for each subplot in the preview figure</td>
<td><code>headers = ["transcript A", "transcript B"]</code></td>
</tr>
<tr>
<td>legend_title : <code>str</code></td>
<td>The title to be displayed above the legend</td>
<td><code>legend_title = "my assays"</code></td>
</tr>
<tr>
<td>hoverinfo : <code>str</code></td>
<td>The type of hoverinfo to display. By default just <code>"y"</code>. Learn more about plotly hoverinfo <a href="https://plotly.com/python/hover-text-and-formatting/">here</a>. Please, note that <code>hovertemplate</code> is not currently supported.</td>
<td><code>hoverinfo = "name+y"</code></td>
</tr>
<tr>
<td>**kwargs</td>
<td>Any additional kwargs that can be passed to <code>plotly</code>'s<code>graphs_objs.Bar()</code>.</td>
<td></td>
</tr>
</tbody>
</table></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GroupBars(Plotter):
    &#34;&#34;&#34;
    Generates a Bar plot figure with a separate subplot for each group. 

    Parameters
    ----------
    mode : str
        The plotting mode. May be either &#34;static&#34; (matplotlib) or &#34;interactive&#34; (plotly).

    Plotting Kwargs
    ----
    
    #### `&#34;static&#34;` Kwargs
    Static GroupBars figures accept the following kwargs:
    
    |   Argument  |  Description    |  Example    |
    | ---- | ---- | ---- |
    |  show : `bool`    |  Whether or not to show the figure    |  `show = True` (default)   |
    |   figsize : `tuple`   |  The figure size    | `figsize = (10, 4)`     |
    | title : `str`   |  The overall figure title   | `title = &#34;Today&#39;s results&#34;    |
    | xlabel : `str`| The x-axis label of each subplot | `xlabel = &#34;Conditions&#34;` |
    | ylabel : `str`| The y-axis label of each subplot | `ylabel = &#34;Mean $\Delta\Delta Ct$&#34;` |
    | rot : `float` | The rotation of x-axis labels | `rot = 0.3` |
    |    headers : `list` |  A list of titles for each subplot in the preview figure    | `headers = [&#34;transcript A&#34;, &#34;transcript B&#34;]`     |
    |  label_subplots  : `bool`   |   Add each subplot with A, B, C ... (if True, default)   | `label_subplots = True` (default)     |
    | labeltype : `str`| The starting character for subplot labelling. By default an `&#34;A&#34;`. | `labeltype = &#34;a&#34;` |
    |   frame   : `bool` |  Show left and top spines of subplots (if True)    | `frame = False` (default)     |
    |   color : `str or list`   | The fillcolor for the individual bars   | `color = &#34;yellow&#34;`     |
    |  style : `str`   | A `seaborn` style to set. Check out available styles [here](https://www.python-graph-gallery.com/104-seaborn-themes).     | `style = &#34;darkgrid&#34;`    |
    |   edgecolor : `str or list`   | The edgecolor for the individual bars   | `edgecolor = &#34;black&#34;`     |
    |   edgewidth : `float`   |  The width of the edge of individual bars  | `edgewidth = 0.5`     |
    |  ecolor : `str`    |   The color of errorbars   |  `ecolor = &#34;orange&#34;`    |
    |  **kwargs    | Any additional kwargs that can be passed to the `matplotlib`-backend pandas `.plot.bar()` API.     |      |

    &lt;br&gt;&lt;/br&gt;
    #### `&#34;interactive&#34;` Kwargs
    Interactive GroupBars figures accept the following kwargs:

    |   Argument  |  Description    |  Example    |
    | ---- | ---- | ---- |
    |  show : `bool`    |  Whether or not to show the figure    |  `show = True` (default)   |
    | title : `str`   |  The overall figure title   | `title = &#34;Today&#39;s results&#34;`    |
    | xlabel : `str`   |  The x axis label   | `xlabel = &#34;My super qPCR samples&#34;`    |
    | ylabel : `str`   |  The y axis label   | `ylabel = &#34;Mean of ddCt&#34;`    |
    |  height : `int`   |   Height of the figure   | `height = 50`    |
    |  width : `int`   |   Width of the figure   | `width = 50`    |
    |  padding : `float or tuple`   |   Padding between subplots. This can be a single float (interpreted as horizontal padding), or a tuple of (horizontal, vertical) paddings.   | `padding = 0.2`    |
    |  template : `str`   | The `plotly` template to use. Check out available templates [here](https://plotly.com/python/templates/).     | `template = &#34;plotly_dark&#34;`    |
    |    headers : `list` |  A list of titles for each subplot in the preview figure    | `headers = [&#34;transcript A&#34;, &#34;transcript B&#34;]`     |
    | legend_title : `str`    | The title to be displayed above the legend   |  `legend_title = &#34;my assays&#34;`   |
    |  hoverinfo : `str`   | The type of hoverinfo to display. By default just `&#34;y&#34;`. Learn more about plotly hoverinfo [here](https://plotly.com/python/hover-text-and-formatting/). Please, note that `hovertemplate` is not currently supported.  | `hoverinfo = &#34;name+y&#34;`    |
    |  **kwargs    | Any additional kwargs that can be passed to `plotly`&#39;s`graphs_objs.Bar()`.     |      |

    &#34;&#34;&#34;
    def __init__(self, mode : str):
        self._setup_default_params(
                                    static = defaults.static_PreviewBars, 
                                    interactive = defaults.interactive_PreviewBars
                                )
        super().__init__( mode = mode )
    
    
    def _static_plot(self, **kwargs):
        &#34;&#34;&#34;
        Generate a static figure
        &#34;&#34;&#34;

        kwargs = self.update_params(kwargs)
        data = self.get()
        groups = data[&#34;group&#34;].unique()
        names = data[&#34;group_name&#34;].unique()

        ref_col, ncols, nrows, headings, x, y, sterr, query = self._prep_properties(kwargs)
        x = &#34;assay&#34; 

        title = aux.from_kwargs(&#34;title&#34;, &#34;Results Preview&#34;, kwargs, rm = True)
        headers = aux.from_kwargs(&#34;headers&#34;, names, kwargs, rm = True)
        label_subplots = aux.from_kwargs(&#34;label_subplots&#34;, True, kwargs, rm = True)
        start_character = aux.from_kwargs(&#34;labeltype&#34;, &#34;A&#34;, kwargs, rm = True)
        show_spines = aux.from_kwargs(&#34;frame&#34;, True, kwargs, rm = True)
        show = aux.from_kwargs(&#34;show&#34;, True, kwargs, rm = True)
        rot = aux.from_kwargs(&#34;rot&#34;, None, kwargs, rm = True)

        palette = gx.generate_palette(kwargs)

        xlabel = aux.from_kwargs(&#34;xlabel&#34;, None, kwargs, rm = True)
        ylabel = aux.from_kwargs(&#34;ylabel&#34;, &#34;$\Delta\Delta$Ct&#34;, kwargs, rm = True)
        # set a seaborn style
        style = aux.from_kwargs(&#34;style&#34;, &#34;ticks&#34;, kwargs, rm = True)
        sns.set_style( style )

        edgecolor = aux.from_kwargs(&#34;edgecolor&#34;, &#34;white&#34;, kwargs, rm = True)
        edgewidth = aux.from_kwargs(&#34;linewidth&#34;, 1, kwargs, rm = True)
        edgewidth = aux.from_kwargs(&#34;edgewidth&#34;, edgewidth, kwargs, rm = True)
        figsize = aux.from_kwargs(&#34;figsize&#34;, None, kwargs, rm = True)

        groups = data[&#34;group&#34;].unique()
        nrows, ncols = gx.make_layout_from_list( groups )
        
        fig, axs = plt.subplots( ncols, nrows, figsize = figsize )
        fig.suptitle( title )

        coords = gx.AxesCoords( fig, axs, (ncols, nrows) )

        idx = 0 
        for group, name in zip(groups, headers): 

            ax = coords.subplot()
            
            tmp_df = data.query( f&#34;group == {group}&#34; )
            tmp_df = tmp_df.sort_values( x )

            tmp_df.plot.bar(
                        x = x, 
                        y = y,
                        # yerr = &#34;stdev&#34;,
                        color = palette,
                        edgecolor = edgecolor,
                        linewidth = edgewidth,
                        ax = ax,
                        **kwargs
                    )

            ax.errorbar(
                            x = tmp_df[x], y = tmp_df[y], 
                            yerr = tmp_df[sterr], 
                            fmt = &#34;.&#34;, markersize = 0, capsize = 3, 
                            ecolor = aux.from_kwargs(&#34;ecolor&#34;, &#34;black&#34;, kwargs),
                    )
            
            ax.set(
                            title = name,
                            xlabel = xlabel,
                            ylabel = ylabel,        
                )

            if rot is not None: 
                align = &#34;center&#34; if rot == 0 else &#34;left&#34;
                plt.setp( ax.xaxis.get_majorticklabels(), rotation = -rot, ha=align, rotation_mode=&#34;anchor&#34;) 


            if not show_spines:
                ax.spines[&#34;right&#34;].set_visible(False)
                ax.spines[&#34;top&#34;].set_visible(False)
                ax.spines[&#34;left&#34;].set_linewidth(1.05)
                ax.spines[&#34;bottom&#34;].set_linewidth(1.05)

                # add ABCD... label to subplot
                if label_subplots:
                    self._add_subplot_label(idx, ax, start_character)         

            coords.increment()
            idx += 1

        plt.tight_layout()

        if show:
            plt.show()
        
        return fig 


    def _interactive_plot(self, **kwargs):
        &#34;&#34;&#34;
        The interactive Preview Results Figure
        &#34;&#34;&#34;

        kwargs = self.update_params(kwargs)
        data = self.get()
        groups = data[&#34;group&#34;].unique()
        names = data[&#34;group_name&#34;].unique()

        try: 
            # setup figure framework variables that have to be removed from 
            ref_col, ncols, nrows, headings, x, y, sterr, query = self._prep_properties(kwargs)
            x = &#34;assay&#34;
            headers = aux.from_kwargs(&#34;headers&#34;, names, kwargs, rm = True)
            show = aux.from_kwargs(&#34;show&#34;, True, kwargs, rm = True)
            padding = aux.from_kwargs(&#34;padding&#34;, 0.1, kwargs, rm = True)

            if isinstance(padding, (list, tuple)):
                hpad, vpad = padding
            else: 
                hpad, vpad = padding, None

            # make new ncols and nrows based on the groups list
            nrows, ncols = gx.make_layout_from_list(groups)

            speclist = gx.make_speclist(nrows, ncols, &#34;xy&#34;)
            fig = make_subplots(
                                    rows = nrows, cols = ncols, 
                                    specs = speclist, 
                                    subplot_titles = headers,
                                    horizontal_spacing = hpad,
                                    vertical_spacing = vpad
                            )


            Coords = gx.AxesCoords(fig, [], (ncols, nrows))

            fig.update_layout(
                        title = aux.from_kwargs(&#34;title&#34;, &#34;Results Preview&#34;, kwargs, rm = True), 
                        height = aux.from_kwargs(&#34;height&#34;, None, kwargs, rm = True), 
                        width = aux.from_kwargs(&#34;width&#34;, None, kwargs, rm = True),
                        margin = {&#34;autoexpand&#34;: True, &#34;pad&#34; : 0, &#34;b&#34;: 1, &#34;t&#34;: 50}, 
                        autosize = True, 
                        template = aux.from_kwargs(&#34;template&#34;, &#34;plotly_white&#34;, kwargs, rm = True),
                        legend = {&#34;title&#34; : aux.from_kwargs(&#34;legend_title&#34;, &#34;group name&#34;, kwargs, rm = True),
                        },
                    )

            # set default axes labels
            xlabel = aux.from_kwargs(&#34;xlabel&#34;, &#34;&#34;, kwargs, rm = True) 
            fig.update_xaxes(title_text = xlabel)
            
            ylabel = aux.from_kwargs(&#34;ylabel&#34;, &#34;DeltaDeltaCt&#34;, kwargs, rm = True) 
            fig.update_yaxes(title_text = ylabel)

            idx = 0
            for group, name in zip( groups, names ):
                row, col = Coords.get()
                tmp_df = data.query(f&#34;group == {group}&#34;)
                tmp_df = tmp_df.sort_values( x )

                # now plot a new bar chart 
                fig.add_trace(

                    go.Bar(
                        name = name,
                        y = tmp_df[y], x = tmp_df[x], 
                        error_y=dict(type=&#39;data&#39;, array = tmp_df[sterr]),
                        hoverinfo = aux.from_kwargs(&#34;hoverinfo&#34;, &#34;y&#34;, kwargs, rm = True), 
                        **kwargs
                    ), 

                    row, col
                )
                Coords.increment()

                idx += 1

            if show:
                fig.show()

            # print(&#34;&lt;&lt;&lt; Interactive Check &gt;&gt;&gt;&#34;)
            return fig 
        except Exception as e: 
            raise e </code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="qpcr.Plotters.Plotters.Plotter" href="#qpcr.Plotters.Plotters.Plotter">Plotter</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="qpcr.Plotters.Plotters.Plotter" href="#qpcr.Plotters.Plotters.Plotter">Plotter</a></b></code>:
<ul class="hlist">
<li><code><a title="qpcr.Plotters.Plotters.Plotter.get" href="#qpcr.Plotters.Plotters.Plotter.get">get</a></code></li>
<li><code><a title="qpcr.Plotters.Plotters.Plotter.id" href="#qpcr.Plotters.Plotters.Plotter.id">id</a></code></li>
<li><code><a title="qpcr.Plotters.Plotters.Plotter.link" href="#qpcr.Plotters.Plotters.Plotter.link">link</a></code></li>
<li><code><a title="qpcr.Plotters.Plotters.Plotter.params" href="#qpcr.Plotters.Plotters.Plotter.params">params</a></code></li>
<li><code><a title="qpcr.Plotters.Plotters.Plotter.plot" href="#qpcr.Plotters.Plotters.Plotter.plot">plot</a></code></li>
<li><code><a title="qpcr.Plotters.Plotters.Plotter.save" href="#qpcr.Plotters.Plotters.Plotter.save">save</a></code></li>
<li><code><a title="qpcr.Plotters.Plotters.Plotter.suffix" href="#qpcr.Plotters.Plotters.Plotter.suffix">suffix</a></code></li>
<li><code><a title="qpcr.Plotters.Plotters.Plotter.update_params" href="#qpcr.Plotters.Plotters.Plotter.update_params">update_params</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="qpcr.Plotters.Plotters.GroupDots"><code class="flex name class">
<span>class <span class="ident">GroupDots</span></span>
<span>(</span><span>mode:Â str)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a Preview of all results from all Assays in subplots, plotting individual values
in a Dot Plot rather than Bar Plot.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>mode</code></strong> :&ensp;<code>str</code></dt>
<dd>The plotting mode. May be either "static" (matplotlib) or "interactive" (plotly).</dd>
</dl>
<h2 id="plotting-kwargs">Plotting Kwargs</h2>
<h4 id="static-kwargs"><code>"static"</code> Kwargs</h4>
<p>Static GroupDots figures accept the following kwargs:</p>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Description</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td>show : <code>bool</code></td>
<td>Whether or not to show the figure</td>
<td><code>show = True</code> (default)</td>
</tr>
<tr>
<td>figsize : <code>tuple</code></td>
<td>The figure size</td>
<td><code>figsize = (10, 4)</code></td>
</tr>
<tr>
<td>title : <code>str</code></td>
<td>The overall figure title</td>
<td>`title = "Today's results"</td>
</tr>
<tr>
<td>xlabel : <code>str</code></td>
<td>The x-axis label of each subplot</td>
<td><code>xlabel = "Conditions"</code></td>
</tr>
<tr>
<td>ylabel : <code>str</code></td>
<td>The y-axis label of each subplot</td>
<td><code>ylabel = "Mean $\Delta\Delta Ct$"</code></td>
</tr>
<tr>
<td>rot : <code>float</code></td>
<td>The rotation of x-axis labels</td>
<td><code>rot = 0.3</code></td>
</tr>
<tr>
<td>headers : <code>list</code></td>
<td>A list of titles for each subplot in the preview figure</td>
<td><code>headers = ["transcript A", "transcript B"]</code></td>
</tr>
<tr>
<td>label_subplots
: <code>bool</code></td>
<td>Add each subplot with A, B, C &hellip; (if True, default)</td>
<td><code>label_subplots = True</code> (default)</td>
</tr>
<tr>
<td>labeltype : <code>str</code></td>
<td>The starting character for subplot labelling. By default an <code>"A"</code>.</td>
<td><code>labeltype = "a"</code></td>
</tr>
<tr>
<td>frame
: <code>bool</code></td>
<td>Show left and top spines of subplots (if True)</td>
<td><code>frame = False</code> (default)</td>
</tr>
<tr>
<td>violin
: <code>bool</code></td>
<td>Show symmetric kde of the dots of each group (if True).</td>
<td><code>violin = False</code></td>
</tr>
<tr>
<td>color : <code>str or list</code></td>
<td>The fillcolor for the individual dots from replicate groups</td>
<td><code>color = "yellow"</code></td>
</tr>
<tr>
<td>style : <code>str</code></td>
<td>A <code>seaborn</code> style to set. Check out available styles <a href="https://www.python-graph-gallery.com/104-seaborn-themes">here</a>.</td>
<td><code>style = "darkgrid"</code></td>
</tr>
<tr>
<td>**kwargs</td>
<td>Any additional kwargs that can be passed to the <code>seaborn</code>'s <code>stripplot()</code>.</td>
<td></td>
</tr>
</tbody>
</table>
<p><br></br></p>
<h4 id="interactive-kwargs"><code>"interactive"</code> Kwargs</h4>
<p>Interactive GroupDots figures accept the following kwargs:</p>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Description</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td>show : <code>bool</code></td>
<td>Whether or not to show the figure</td>
<td><code>show = True</code> (default)</td>
</tr>
<tr>
<td>title : <code>str</code></td>
<td>The overall figure title</td>
<td><code>title = "Today's results"</code></td>
</tr>
<tr>
<td>xlabel : <code>str</code></td>
<td>The x axis label</td>
<td><code>xlabel = "My super qPCR samples"</code></td>
</tr>
<tr>
<td>ylabel : <code>str</code></td>
<td>The y axis label</td>
<td><code>ylabel = "Mean of ddCt"</code></td>
</tr>
<tr>
<td>height : <code>int</code></td>
<td>Height of the figure</td>
<td><code>height = 50</code></td>
</tr>
<tr>
<td>width : <code>int</code></td>
<td>Width of the figure</td>
<td><code>width = 50</code></td>
</tr>
<tr>
<td>padding : <code>float or tuple</code></td>
<td>Padding between subplots. This can be a single float (interpreted as horizontal padding), or a tuple of (horizontal, vertical) paddings.</td>
<td><code>padding = 0.2</code></td>
</tr>
<tr>
<td>template : <code>str</code></td>
<td>The <code>plotly</code> template to use. Check out available templates <a href="https://plotly.com/python/templates/">here</a>.</td>
<td><code>template = "plotly_dark"</code></td>
</tr>
<tr>
<td>headers : <code>list</code></td>
<td>A list of titles for each subplot in the preview figure</td>
<td><code>headers = ["transcript A", "transcript B"]</code></td>
</tr>
<tr>
<td>violin
: <code>bool</code></td>
<td>Show symmetric kde of the dots of each group (if True).</td>
<td><code>violin = False</code></td>
</tr>
<tr>
<td>hoverinfo : <code>str</code></td>
<td>The type of hoverinfo to display. By default just <code>"y"</code>. Learn more about plotly hoverinfo <a href="https://plotly.com/python/hover-text-and-formatting/">here</a>. Please, note that <code>hovertemplate</code> is not currently supported.</td>
<td><code>hoverinfo = "name+y"</code></td>
</tr>
<tr>
<td>**kwargs</td>
<td>Any additional kwargs that can be passed to <code>plotly</code>'s<code>graphs_objs.Violin()</code>.</td>
<td></td>
</tr>
</tbody>
</table></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GroupDots(Plotter):
    &#34;&#34;&#34;
    Generate a Preview of all results from all Assays in subplots, plotting individual values
    in a Dot Plot rather than Bar Plot.

    Parameters
    ----------
    mode : str
        The plotting mode. May be either &#34;static&#34; (matplotlib) or &#34;interactive&#34; (plotly).


    Plotting Kwargs
    ----
    
    #### `&#34;static&#34;` Kwargs
    Static GroupDots figures accept the following kwargs:
    
    |   Argument  |  Description    |  Example    |
    | ---- | ---- | ---- |
    |  show : `bool`    |  Whether or not to show the figure    |  `show = True` (default)   |
    |   figsize : `tuple`   |  The figure size    | `figsize = (10, 4)`     |
    | title : `str`   |  The overall figure title   | `title = &#34;Today&#39;s results&#34;    |
    | xlabel : `str`| The x-axis label of each subplot | `xlabel = &#34;Conditions&#34;` |
    | ylabel : `str`| The y-axis label of each subplot | `ylabel = &#34;Mean $\Delta\Delta Ct$&#34;` |
    | rot : `float` | The rotation of x-axis labels | `rot = 0.3` |
    |    headers : `list` |  A list of titles for each subplot in the preview figure    | `headers = [&#34;transcript A&#34;, &#34;transcript B&#34;]`     |
    |  label_subplots  : `bool`   |   Add each subplot with A, B, C ... (if True, default)   | `label_subplots = True` (default)     |
    | labeltype : `str`| The starting character for subplot labelling. By default an `&#34;A&#34;`. | `labeltype = &#34;a&#34;` |
    |   frame   : `bool` |  Show left and top spines of subplots (if True)    | `frame = False` (default)     |
    |   violin   : `bool` |  Show symmetric kde of the dots of each group (if True).   | `violin = False`    |
    |   color : `str or list`   | The fillcolor for the individual dots from replicate groups   | `color = &#34;yellow&#34;`     |
    |  style : `str`   | A `seaborn` style to set. Check out available styles [here](https://www.python-graph-gallery.com/104-seaborn-themes).     | `style = &#34;darkgrid&#34;`    |
    |  **kwargs    | Any additional kwargs that can be passed to the `seaborn`&#39;s `stripplot()`.     |      |

    &lt;br&gt;&lt;/br&gt;
    #### `&#34;interactive&#34;` Kwargs
    Interactive GroupDots figures accept the following kwargs:

    |   Argument  |  Description    |  Example    |
    | ---- | ---- | ---- |
    |  show : `bool`    |  Whether or not to show the figure    |  `show = True` (default)   |
    | title : `str`   |  The overall figure title   | `title = &#34;Today&#39;s results&#34;`    |
    | xlabel : `str`   |  The x axis label   | `xlabel = &#34;My super qPCR samples&#34;`    |
    | ylabel : `str`   |  The y axis label   | `ylabel = &#34;Mean of ddCt&#34;`    |
    |  height : `int`   |   Height of the figure   | `height = 50`    |
    |  width : `int`   |   Width of the figure   | `width = 50`    |
    |  padding : `float or tuple`   |   Padding between subplots. This can be a single float (interpreted as horizontal padding), or a tuple of (horizontal, vertical) paddings.   | `padding = 0.2`    |
    |  template : `str`   | The `plotly` template to use. Check out available templates [here](https://plotly.com/python/templates/).     | `template = &#34;plotly_dark&#34;`    |
    |    headers : `list` |  A list of titles for each subplot in the preview figure    | `headers = [&#34;transcript A&#34;, &#34;transcript B&#34;]`     |
    |   violin   : `bool` |  Show symmetric kde of the dots of each group (if True).   | `violin = False`    |
    |  hoverinfo : `str`   | The type of hoverinfo to display. By default just `&#34;y&#34;`. Learn more about plotly hoverinfo [here](https://plotly.com/python/hover-text-and-formatting/). Please, note that `hovertemplate` is not currently supported.  | `hoverinfo = &#34;name+y&#34;`    |
    |  **kwargs    | Any additional kwargs that can be passed to `plotly`&#39;s`graphs_objs.Violin()`.     |      |

    &#34;&#34;&#34;
    def __init__(self, mode:str):
        self._setup_default_params(
                                    static = defaults.static_PreviewDots, 
                                    interactive = defaults.interactive_PreviewDots
                                )
        # __init__ is going to require default_params to be already set!
        super().__init__(mode)

    def _static_plot(self, **kwargs):
        &#34;&#34;&#34;
        The static Preview Results Figure
        &#34;&#34;&#34;

        kwargs = self.update_params(kwargs)
        data = self._rep_data

        # get assays to plot
        assays = [ i for i in data.columns if i not in [ &#34;group&#34;, &#34;group_name&#34;, raw_col_names[0] ] ]
        assays = sorted( assays )

        # get the groups
        groups = data[&#34;group&#34;].unique()
        names = data[&#34;group_name&#34;].unique()
        
        # generate subplot layout
        ncols, nrows = gx.make_layout_from_list( groups )

        # get kwargs incompatible with the main plotting method
        title = aux.from_kwargs(&#34;title&#34;, None, kwargs, rm = True)
        headers = aux.from_kwargs(&#34;headers&#34;, names, kwargs, rm = True)
        label_subplots = aux.from_kwargs(&#34;label_subplots&#34;, True, kwargs, rm = True)
        start_character = aux.from_kwargs(&#34;labeltype&#34;, &#34;A&#34;, kwargs, rm = True)
        show_spines = aux.from_kwargs(&#34;frame&#34;, True, kwargs, rm = True)
        show = aux.from_kwargs(&#34;show&#34;, True, kwargs, rm = True)
        show_violins = aux.from_kwargs(&#34;violin&#34;, True, kwargs, rm = True)
        rot = aux.from_kwargs(&#34;rot&#34;, None, kwargs, rm = True)
        alpha = aux.from_kwargs(&#34;alpha&#34;, 1, kwargs, rm = True)
        xlabel = aux.from_kwargs(&#34;xlabel&#34;, None, kwargs, rm = True)
        ylabel = aux.from_kwargs(&#34;ylabel&#34;, None, kwargs, rm = True)

        # generate a custom color palette in case color kwarg is provided
        palette = gx.generate_palette(kwargs)

        # set a seaborn style
        style = aux.from_kwargs(&#34;style&#34;, &#34;dark&#34;, kwargs, rm = True)
        sns.set_style( style )

        # make figure
        figsize = aux.from_kwargs(&#34;figsize&#34;, None, kwargs, rm = True)
        fig, axs = plt.subplots(nrows = nrows, ncols = ncols, figsize = figsize)
        fig.suptitle( title )

        # setup Coords
        Coords = gx.AxesCoords(fig, axs, (nrows, ncols))
        idx = 0
        for group, name in zip( groups, headers ): 

            try:
                
                # prepare a vertical bigtable format dataframe 
                tmp_df = self._prepare_df(data, assays, group)
                
                # now plot a new violin chart 
                subplot = Coords.subplot()

                if show_violins:
                    sns.violinplot(
                                    x = tmp_df[ &#34;assay&#34; ],
                                    y = tmp_df[ &#34;value&#34; ],
                                    color = None,
                                    inner = None, 
                                    palette = palette,
                                    ax = subplot,

                                )
                    for i in subplot.collections:
                        i.set_alpha( alpha * 0.3 )

                sns.stripplot(
                                x = tmp_df[ &#34;assay&#34; ],
                                y = tmp_df[ &#34;value&#34; ],
                                palette = palette,
                                alpha = alpha,
                                ax = subplot,
                                **kwargs
                            )
            
                subplot.set(
                            title = name,
                            xlabel = xlabel,
                            ylabel = ylabel,        
                        )

                # adjust xtick rotation   
                if rot is not None: 
                    align = &#34;center&#34; if rot == 0 else &#34;left&#34;
                    plt.setp( subplot.xaxis.get_majorticklabels(), rotation = -rot, ha=align, rotation_mode=&#34;anchor&#34;) 

                if not show_spines:
                    subplot.spines[&#34;right&#34;].set_visible(False)
                    subplot.spines[&#34;top&#34;].set_visible(False)
                    subplot.spines[&#34;left&#34;].set_linewidth(1.05)
                    subplot.spines[&#34;bottom&#34;].set_linewidth(1.05)

                # add ABCD... label to subplot
                if label_subplots:
                    self._add_subplot_label(idx, subplot, start_character)         

                Coords.increment()
                idx += 1
            except Exception as e:
                raise e 
                break
        
        plt.tight_layout()

        if show:
            plt.show()

        # print(&#34;&lt;&lt;&lt; Static Check &gt;&gt;&gt;&#34;)

        return fig 

    def _prepare_df(self, data, assays, group):
        &#34;&#34;&#34;
        Concatenates the different assay colums into a single 
        set of two columns, one for all &#34;value&#34;s and one for 
        the &#34;assay&#34; identifiers. 
        &#34;&#34;&#34;
        # get a group subset 
        group_df = data.query( f&#34;group == {group}&#34; )

        # concatenate all separate assay columns into a set of 
        # &#39;value&#39; and &#39;assay&#39; columns.

        # setup the _assays concatenated dataframe   
        _assays = group_df[ [ &#34;group&#34;, assays[0] ] ]
        _assays = _assays.rename( columns = { assays[0] : &#34;value&#34; } )
        _assays[&#34;assay&#34;] = [ assays[0] for i in _assays[&#34;group&#34;] ]

        # now iteratively add all remaining assays
        for assay in assays[1:]:
            tmp_df = group_df[ [ &#34;group&#34;, assay ] ]
            tmp_df = tmp_df.rename( columns = { assay : &#34;value&#34; } )
            tmp_df[&#34;assay&#34;] = [ assay for i in tmp_df[&#34;group&#34;] ]
            _assays = pd.concat( [_assays, tmp_df], ignore_index = True)
                
        # remove the group col, and sort
        tmp_df = _assays.drop( columns = [&#34;group&#34;] )
        tmp_df = tmp_df.sort_values( &#34;assay&#34; )

        return tmp_df

    def _add_subplot_label(self, idx, subplot, start_character):
        &#34;&#34;&#34;
        Adds A B C ... to upper left corner of a subplot...
        It will start labelling at any arbitrary start_character
        &#34;&#34;&#34;
        subplot_label = chr(ord(start_character)+idx)
        subplot.annotate(
                            xy = (-0.1,1.03), 
                            text = subplot_label, 
                            xycoords = &#34;axes fraction&#34;,
                            weight = &#34;bold&#34;, fontsize = 12
                        )

    def _interactive_plot(self, **kwargs):
        &#34;&#34;&#34;
        The interactive Preview Results Figure
        &#34;&#34;&#34;

        kwargs = self.update_params(kwargs)
        data = self._rep_data

        # get assays to plot
        assays = [ i for i in data.columns if i not in [ &#34;group&#34;, &#34;group_name&#34;, raw_col_names[0] ] ]
        assays = sorted( assays )

        # get the groups
        groups = data[&#34;group&#34;].unique()
        names = data[&#34;group_name&#34;].unique()
        ticks = np.arange( len(assays) )

        # make subplot layout
        ncols, nrows = gx.make_layout_from_list( groups )

        try: 
            # get incompaltible kwargs 
            headers = aux.from_kwargs(&#34;headers&#34;, names, kwargs, rm = True)
            show = aux.from_kwargs(&#34;show&#34;, True, kwargs, rm = True)
            show_violins = aux.from_kwargs(&#34;violin&#34;, True, kwargs, rm = True)

            # setup padding
            padding = aux.from_kwargs(&#34;padding&#34;, 0.1, kwargs, rm = True)
            if isinstance(padding, (list, tuple)):
                hpad, vpad = padding
            else: 
                hpad, vpad = padding, None

            # make figure
            speclist = gx.make_speclist(nrows, ncols, &#34;xy&#34;)
            fig = make_subplots(
                                    rows = nrows, cols = ncols, 
                                    specs = speclist, 
                                    subplot_titles = headers,
                                    horizontal_spacing = hpad,
                                    vertical_spacing = vpad
                            )

            # setup subplot coords handling
            Coords = gx.AxesCoords(fig, [], (ncols, nrows))

            # setup figure
            fig.update_layout(
                                title = aux.from_kwargs(&#34;title&#34;, &#34;Results Preview&#34;, kwargs, rm = True), 
                                height = aux.from_kwargs(&#34;height&#34;, None, kwargs, rm = True), 
                                width = aux.from_kwargs(&#34;width&#34;, None, kwargs, rm = True),
                                margin = {&#34;autoexpand&#34;: True, &#34;pad&#34; : 0, &#34;b&#34;: 1, &#34;t&#34;: 50}, 
                                autosize = True, 
                                template = aux.from_kwargs(&#34;template&#34;, &#34;plotly_white&#34;, kwargs, rm = True),
                                # legend = {  &#34;title&#34; : aux.from_kwargs(&#34;legend_title&#34;, &#34;Assay&#34;, kwargs, rm = True),  },
                                showlegend = False
                            )

            # set default axes labels
            xlabel = aux.from_kwargs(&#34;xlabel&#34;, &#34;&#34;, kwargs, rm = True) 
            fig.update_xaxes(title_text = xlabel)
            
            ylabel = aux.from_kwargs(&#34;ylabel&#34;, &#34;&#34;, kwargs, rm = True) 
            fig.update_yaxes(title_text = ylabel)

            idx = 0
            for group, name in zip( groups, headers ):
                
                # prepare a vertical bigtable format dataframe 
                tmp_df = self._prepare_df(data, assays, group)

                row, col = Coords.get()

                # now plot a new violin chart 
                fig.add_trace(

                    go.Violin(
                                    name = name,
                                    x = tmp_df[ &#34;assay&#34; ], 
                                    y = tmp_df[ &#34;value&#34; ], 
                                    points = &#34;all&#34;,
                                    pointpos = 0,
                                    hoverinfo = aux.from_kwargs(&#34;hoverinfo&#34;, &#34;y&#34;, kwargs, rm = True), 
                                    **kwargs
                            ), 
                                    row, col
                        )

                # remove violins if not desired (leaving only dot plot)
                if not show_violins: 
                    fig.update_traces(
                                        fillcolor=&#34;rgba(0,0,0,0)&#34;, 
                                        line_width = 0, 
                                        selector=dict(type=&#39;violin&#39;),
                                    )


                # update x axis to categorical group names
                fig.update_layout(
                                    { 
                                        f&#34;xaxis{idx+1}&#34; : dict(
                                                                tickmode = &#39;array&#39;,
                                                                tickvals = ticks,
                                                                ticktext = assays,
                                                        )         
                                    }
                                )

                Coords.increment()

                idx += 1

            if show:
                fig.show()

            # print(&#34;&lt;&lt;&lt; Interactive Check &gt;&gt;&gt;&#34;)
            return fig 
        except Exception as e: 
            raise e </code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="qpcr.Plotters.Plotters.Plotter" href="#qpcr.Plotters.Plotters.Plotter">Plotter</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="qpcr.Plotters.Plotters.Plotter" href="#qpcr.Plotters.Plotters.Plotter">Plotter</a></b></code>:
<ul class="hlist">
<li><code><a title="qpcr.Plotters.Plotters.Plotter.get" href="#qpcr.Plotters.Plotters.Plotter.get">get</a></code></li>
<li><code><a title="qpcr.Plotters.Plotters.Plotter.id" href="#qpcr.Plotters.Plotters.Plotter.id">id</a></code></li>
<li><code><a title="qpcr.Plotters.Plotters.Plotter.link" href="#qpcr.Plotters.Plotters.Plotter.link">link</a></code></li>
<li><code><a title="qpcr.Plotters.Plotters.Plotter.params" href="#qpcr.Plotters.Plotters.Plotter.params">params</a></code></li>
<li><code><a title="qpcr.Plotters.Plotters.Plotter.plot" href="#qpcr.Plotters.Plotters.Plotter.plot">plot</a></code></li>
<li><code><a title="qpcr.Plotters.Plotters.Plotter.save" href="#qpcr.Plotters.Plotters.Plotter.save">save</a></code></li>
<li><code><a title="qpcr.Plotters.Plotters.Plotter.suffix" href="#qpcr.Plotters.Plotters.Plotter.suffix">suffix</a></code></li>
<li><code><a title="qpcr.Plotters.Plotters.Plotter.update_params" href="#qpcr.Plotters.Plotters.Plotter.update_params">update_params</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="qpcr.Plotters.Plotters.Plotter"><code class="flex name class">
<span>class <span class="ident">Plotter</span></span>
<span>(</span><span>mode=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A superclass that handles Data Linking and Parameter setup for FigureClasses
(not for End-User usage)</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>mode</code></strong> :&ensp;<code>str</code></dt>
<dd>The plotting mode. May be either "static" (matplotlib) or "interactive" (plotly).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Plotter:
    &#34;&#34;&#34;
    A superclass that handles Data Linking and Parameter setup for FigureClasses
    (not for End-User usage)

    Parameters
    ----------
    mode : str
        The plotting mode. May be either &#34;static&#34; (matplotlib) or &#34;interactive&#34; (plotly).    
    &#34;&#34;&#34;
    def __init__(self, mode = None):
        self._default_params = None
        self._PARAMS = {} #: _PARAMS will store the plotting parameter kwargs from both _default_params and any additional user specified parameters
        self._Results = None
        self._data = None
        self._rep_data = None
        self._id = type(self).__name__
        self._MODE = &#34;interactive&#34; if mode is None else mode
        self._fig = None
        self._set_plot()

    def link(self, Results:(qpcr.Results or pd.DataFrame)):
        &#34;&#34;&#34;
        Links a Results object or pandas DataFrame of the same architecture
        as one handled by a Results object to the Plotter. 
        Note, that this will replace any previously linked data!

        Parameters
        ----------
        Results : qpcr.Results or pd.DataFrame
            A qpcr.Results Object or a pandas DataFrame of the same architecture.
        &#34;&#34;&#34;
        
        if aux.same_type(Results, qpcr.Results()):
            self._Results = Results
            self._data = self._Results.stats()
            self._rep_data = self._Results.get()
        elif isinstance(Results, pd.DataFrame):
            self._Results = None
            self._data = Results
        else:
            wa.HardWarning(&#34;Plotter:unknown_data&#34;, obj = Results)

    def plot(self, **kwargs):
        &#34;&#34;&#34;
        Generate Figure

        Parameters
        ----------
        **kwargs
            Any arbitrary keyword arguments to be passed to the plotting method
        
        Returns
        -------
        fig
            A figure object, either from matplotlib or plotly
        &#34;&#34;&#34;
        total_kwargs = self.update_params(kwargs)
        fig = self._plot(**total_kwargs)
        self._fig = fig
        return fig

    def id(self, id:str = None):
        &#34;&#34;&#34;
        Set a unique Id, by default the Classname will be used.

        Parameters
        ----------
        id : str
            A unique identifier for the Plotter object
        
        Returns
        -------
        id 
            The Plotter Id (if no id keyword was entered)
        &#34;&#34;&#34;
        if id is not None:
            self._id = id
        else:
            return self._id

    def get(self):
        &#34;&#34;&#34;
        Returns the DataFrame used for plotting

        Returns
        -------
        data
            A pandas DataFrame containing the data underlying the plot.
        &#34;&#34;&#34;
        return self._data

    def params(self, **params):
        &#34;&#34;&#34;
        Set default parameters for plotting (will be forwarded to **kwargs)
        Returns default parameters if no new parameters are added.

        Parameters
        ----------
        **params
            Any arbitrary keyword arguments to be passed on to the pre-set plotting kwargs.
            This will either set the default parameters (if none has been specified up to the function call)
            or will update the parameters. In case of keyword duplications any OLD key : value pairs will be 
            OVERWRITTEN by new ones. 
        
        Returns
        -------
        params : dict
            A dictionary of the new pre-set plotting parameters
        &#34;&#34;&#34;
        if params != {} and self._PARAMS == {}:
            self._PARAMS = params
        elif params != {}:
            self.update_params(params, store = True)
        return self._PARAMS

    def update_params(self, kwargs, supersede = True, store = False):
        &#34;&#34;&#34;
        Appends pre-set parameters to kwargs. 
        
        Parameters
        ----------
        kwargs : dict
            A dictionary of arbitrary keywords for plotting 
        supersede : bool 
            In case of key duplications: Old values will be replaced with new ones (if supersede = True, default), 
            or keep old ones (supersede = False).
        store : bool
            The newly set plotting parameter dictionary will be stored by the plotting object as new default (if store = True, default is False).
        
        Returns
        -------
        params : dict
            A dictionary of updated plotting parameters
        &#34;&#34;&#34;
        if supersede:
            kwargs = dict(self._PARAMS, **kwargs)
        else:
            kwargs = dict(kwargs, **self._PARAMS)
        
        if store:
            self._PARAMS = kwargs

        return kwargs

    def save(self, filename, **kwargs):
        &#34;&#34;&#34;
        Saves the figure to a file. 
        Figures are either saved using `plt.savefig` or `plotly.offline.plot`.

        Parameters
        ----------
        filename : str 
            A filename to save the figure to.
        
        **kwargs
            Any arbitrary keyword arguments for the respective figure saving method. 
        &#34;&#34;&#34;
        if self._fig is None:
            wa.SoftWarning(&#34;Plotter:no_fig_yet&#34;)
        else:
            if self._MODE == &#34;static&#34;:
                self._fig.savefig(filename, bbox_inches = &#39;tight&#39;, **kwargs)
            elif self._MODE == &#34;interactive&#34;:
                plotly.offline.plot(self._fig, filename=filename, **kwargs)

    def suffix(self):
        &#34;&#34;&#34;
        Returns
        ------- 
        suffix : str
            The appropriate file suffix for save (html for &#34;interactive&#34; or jpg for &#34;static&#34; figures)
        &#34;&#34;&#34;
        suffix = &#34;jpg&#34; if self._MODE == &#34;static&#34; else &#34;html&#34;
        return suffix

    def _setup_default_params(self, static:dict, interactive:dict):
        &#34;&#34;&#34;
        Setup and set default parameters for a FigureClass
        &#34;&#34;&#34;
        self._static_default = static
        self._interactive_default = interactive

    def _set_plot(self):
        &#34;&#34;&#34;
        Sets self._plot either interactive or static depending on MODe
        &#34;&#34;&#34;
        self._plot  = self._static_plot if self._MODE == &#34;static&#34; else self._interactive_plot
        prev_default = self._default_params
        self._default_params = self._static_default if self._MODE == &#34;static&#34; else self._interactive_default

        if self.params() == {} or self.params() == prev_default:
            self.params(**self._default_params)
        else:
            self.update_params(self._default_params, store = True, supersede = False)

    def _static_plot(self, **kwargs):
        &#34;&#34;&#34;
        The plot function that will handle static plotting (will be redefined for each FigureClass)
        &#34;&#34;&#34;
        print(&#34;The plot function that will handle static plotting...&#34;)
        print(&#34;Surprised to see this?, \nPerhaps your desired plotting methods are not named properly. Make sure to name your method _static_plot()!&#34;)

    def _interactive_plot(self, **kwargs):
        &#34;&#34;&#34;
        The plot function that will handle interactive plotting (will be redefined for each FigureClass)
        &#34;&#34;&#34;
        print(&#34;The plot function that will handle interactive plotting...&#34;)
        print(&#34;Surprised to see this?, \nPerhaps your desired plotting methods are not named properly. Make sure to name your method _interactive_plot()!&#34;)

    def _prep_properties(self, kwargs):
        &#34;&#34;&#34;
        Setup ncols, nrows, subplot titles (headers), x, y, and sterr, columns for figure...
        &#34;&#34;&#34;
        self._setup_default_plot_cols()
        data = self.get()

        # setup reference column and figure subplots
        ref_col = aux.from_kwargs(&#34;key&#34;, &#34;assay&#34;, kwargs, rm=True)
        ncols, nrows = aux.from_kwargs(&#34;subplots&#34;, 
                                        gx.make_layout(data, ref_col), 
                                        kwargs, rm=True
                                       )

        # transposing currently not supported...
        # if aux.from_kwargs(&#34;transpose&#34;, False, kwargs, rm = True):
        #     ncols, nrows = nrows, ncols

        headers = aux.sorted_set(data[ref_col])

        x = aux.from_kwargs(&#34;x&#34;, self._default_x, kwargs, rm = True)
        y = aux.from_kwargs(&#34;y&#34;, self._default_y, kwargs, rm = True)
        sterr = aux.from_kwargs(&#34;sterr&#34;, self._default_sterr, kwargs, rm = True)
        
        # the query to be used if group or group_name is ref_col
        query = &#34;{ref_col} == &#39;{q}&#39;&#34; if isinstance(headers[0], str) else &#34;{ref_col} == {q}&#34;

        return ref_col,ncols,nrows, headers, x, y, sterr, query

    def _setup_default_plot_cols(self):
        &#34;&#34;&#34;
        Sets default columns for x and y in barcharts,
        default x
        - &#34;group_name&#34; column if present 
        - &#34;group&#34; Otherwise
        default y
        - &#34;mean&#34;
        default sterr
        - &#34;stdev&#34;
        &#34;&#34;&#34;
        columns = self._data.columns
        self._default_x = &#34;group_name&#34; if &#34;group_name&#34; in columns else &#34;group&#34;
        self._default_y = &#34;mean&#34;
        self._default_sterr = &#34;stdev&#34;

    def _add_subplot_label(self, idx, subplot, start_character):
        &#34;&#34;&#34;
        Adds A B C ... to upper left corner of a subplot...
        It will start labelling at any arbitrary start_character
        &#34;&#34;&#34;
        subplot_label = chr(ord(start_character)+idx)
        subplot.annotate(
                    xy = (-0.1,1.03), 
                    text = subplot_label, 
                    xycoords = &#34;axes fraction&#34;,
                    weight = &#34;bold&#34;, fontsize = 12
                )</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="qpcr.Plotters.Plotters.AssayBars" href="#qpcr.Plotters.Plotters.AssayBars">AssayBars</a></li>
<li><a title="qpcr.Plotters.Plotters.AssayDots" href="#qpcr.Plotters.Plotters.AssayDots">AssayDots</a></li>
<li><a title="qpcr.Plotters.Plotters.EfficiencyLines" href="#qpcr.Plotters.Plotters.EfficiencyLines">EfficiencyLines</a></li>
<li><a title="qpcr.Plotters.Plotters.FilterSummary" href="#qpcr.Plotters.Plotters.FilterSummary">FilterSummary</a></li>
<li><a title="qpcr.Plotters.Plotters.GroupBars" href="#qpcr.Plotters.Plotters.GroupBars">GroupBars</a></li>
<li><a title="qpcr.Plotters.Plotters.GroupDots" href="#qpcr.Plotters.Plotters.GroupDots">GroupDots</a></li>
<li><a title="qpcr.Plotters.Plotters.ReplicateBoxPlot" href="#qpcr.Plotters.Plotters.ReplicateBoxPlot">ReplicateBoxPlot</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="qpcr.Plotters.Plotters.Plotter.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the DataFrame used for plotting</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>data</code></dt>
<dd>A pandas DataFrame containing the data underlying the plot.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(self):
    &#34;&#34;&#34;
    Returns the DataFrame used for plotting

    Returns
    -------
    data
        A pandas DataFrame containing the data underlying the plot.
    &#34;&#34;&#34;
    return self._data</code></pre>
</details>
</dd>
<dt id="qpcr.Plotters.Plotters.Plotter.id"><code class="name flex">
<span>def <span class="ident">id</span></span>(<span>self, id:Â strÂ =Â None)</span>
</code></dt>
<dd>
<div class="desc"><p>Set a unique Id, by default the Classname will be used.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>id</code></strong> :&ensp;<code>str</code></dt>
<dd>A unique identifier for the Plotter object</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>id </code></dt>
<dd>The Plotter Id (if no id keyword was entered)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def id(self, id:str = None):
    &#34;&#34;&#34;
    Set a unique Id, by default the Classname will be used.

    Parameters
    ----------
    id : str
        A unique identifier for the Plotter object
    
    Returns
    -------
    id 
        The Plotter Id (if no id keyword was entered)
    &#34;&#34;&#34;
    if id is not None:
        self._id = id
    else:
        return self._id</code></pre>
</details>
</dd>
<dt id="qpcr.Plotters.Plotters.Plotter.link"><code class="name flex">
<span>def <span class="ident">link</span></span>(<span>self, Results:Â qpcr.__init__.Results)</span>
</code></dt>
<dd>
<div class="desc"><p>Links a Results object or pandas DataFrame of the same architecture
as one handled by a Results object to the Plotter.
Note, that this will replace any previously linked data!</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>Results</code></strong> :&ensp;<code><a title="qpcr.Results" href="../index.html#qpcr.Results">Results</a></code> or <code>pd.DataFrame</code></dt>
<dd>A qpcr.Results Object or a pandas DataFrame of the same architecture.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def link(self, Results:(qpcr.Results or pd.DataFrame)):
    &#34;&#34;&#34;
    Links a Results object or pandas DataFrame of the same architecture
    as one handled by a Results object to the Plotter. 
    Note, that this will replace any previously linked data!

    Parameters
    ----------
    Results : qpcr.Results or pd.DataFrame
        A qpcr.Results Object or a pandas DataFrame of the same architecture.
    &#34;&#34;&#34;
    
    if aux.same_type(Results, qpcr.Results()):
        self._Results = Results
        self._data = self._Results.stats()
        self._rep_data = self._Results.get()
    elif isinstance(Results, pd.DataFrame):
        self._Results = None
        self._data = Results
    else:
        wa.HardWarning(&#34;Plotter:unknown_data&#34;, obj = Results)</code></pre>
</details>
</dd>
<dt id="qpcr.Plotters.Plotters.Plotter.params"><code class="name flex">
<span>def <span class="ident">params</span></span>(<span>self, **params)</span>
</code></dt>
<dd>
<div class="desc"><p>Set default parameters for plotting (will be forwarded to **kwargs)
Returns default parameters if no new parameters are added.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>**params</code></strong></dt>
<dd>Any arbitrary keyword arguments to be passed on to the pre-set plotting kwargs.
This will either set the default parameters (if none has been specified up to the function call)
or will update the parameters. In case of keyword duplications any OLD key : value pairs will be
OVERWRITTEN by new ones.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>params</code></strong> :&ensp;<code>dict</code></dt>
<dd>A dictionary of the new pre-set plotting parameters</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def params(self, **params):
    &#34;&#34;&#34;
    Set default parameters for plotting (will be forwarded to **kwargs)
    Returns default parameters if no new parameters are added.

    Parameters
    ----------
    **params
        Any arbitrary keyword arguments to be passed on to the pre-set plotting kwargs.
        This will either set the default parameters (if none has been specified up to the function call)
        or will update the parameters. In case of keyword duplications any OLD key : value pairs will be 
        OVERWRITTEN by new ones. 
    
    Returns
    -------
    params : dict
        A dictionary of the new pre-set plotting parameters
    &#34;&#34;&#34;
    if params != {} and self._PARAMS == {}:
        self._PARAMS = params
    elif params != {}:
        self.update_params(params, store = True)
    return self._PARAMS</code></pre>
</details>
</dd>
<dt id="qpcr.Plotters.Plotters.Plotter.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate Figure</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Any arbitrary keyword arguments to be passed to the plotting method</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>fig</code></dt>
<dd>A figure object, either from matplotlib or plotly</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self, **kwargs):
    &#34;&#34;&#34;
    Generate Figure

    Parameters
    ----------
    **kwargs
        Any arbitrary keyword arguments to be passed to the plotting method
    
    Returns
    -------
    fig
        A figure object, either from matplotlib or plotly
    &#34;&#34;&#34;
    total_kwargs = self.update_params(kwargs)
    fig = self._plot(**total_kwargs)
    self._fig = fig
    return fig</code></pre>
</details>
</dd>
<dt id="qpcr.Plotters.Plotters.Plotter.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, filename, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Saves the figure to a file.
Figures are either saved using <code>plt.savefig</code> or <code>plotly.offline.plot</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>str </code></dt>
<dd>A filename to save the figure to.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Any arbitrary keyword arguments for the respective figure saving method.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save(self, filename, **kwargs):
    &#34;&#34;&#34;
    Saves the figure to a file. 
    Figures are either saved using `plt.savefig` or `plotly.offline.plot`.

    Parameters
    ----------
    filename : str 
        A filename to save the figure to.
    
    **kwargs
        Any arbitrary keyword arguments for the respective figure saving method. 
    &#34;&#34;&#34;
    if self._fig is None:
        wa.SoftWarning(&#34;Plotter:no_fig_yet&#34;)
    else:
        if self._MODE == &#34;static&#34;:
            self._fig.savefig(filename, bbox_inches = &#39;tight&#39;, **kwargs)
        elif self._MODE == &#34;interactive&#34;:
            plotly.offline.plot(self._fig, filename=filename, **kwargs)</code></pre>
</details>
</dd>
<dt id="qpcr.Plotters.Plotters.Plotter.suffix"><code class="name flex">
<span>def <span class="ident">suffix</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<p>suffix : str
The appropriate file suffix for save (html for "interactive" or jpg for "static" figures)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def suffix(self):
    &#34;&#34;&#34;
    Returns
    ------- 
    suffix : str
        The appropriate file suffix for save (html for &#34;interactive&#34; or jpg for &#34;static&#34; figures)
    &#34;&#34;&#34;
    suffix = &#34;jpg&#34; if self._MODE == &#34;static&#34; else &#34;html&#34;
    return suffix</code></pre>
</details>
</dd>
<dt id="qpcr.Plotters.Plotters.Plotter.update_params"><code class="name flex">
<span>def <span class="ident">update_params</span></span>(<span>self, kwargs, supersede=True, store=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Appends pre-set parameters to kwargs. </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>A dictionary of arbitrary keywords for plotting</dd>
<dt><strong><code>supersede</code></strong> :&ensp;<code>bool </code></dt>
<dd>In case of key duplications: Old values will be replaced with new ones (if supersede = True, default),
or keep old ones (supersede = False).</dd>
<dt><strong><code>store</code></strong> :&ensp;<code>bool</code></dt>
<dd>The newly set plotting parameter dictionary will be stored by the plotting object as new default (if store = True, default is False).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>params</code></strong> :&ensp;<code>dict</code></dt>
<dd>A dictionary of updated plotting parameters</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_params(self, kwargs, supersede = True, store = False):
    &#34;&#34;&#34;
    Appends pre-set parameters to kwargs. 
    
    Parameters
    ----------
    kwargs : dict
        A dictionary of arbitrary keywords for plotting 
    supersede : bool 
        In case of key duplications: Old values will be replaced with new ones (if supersede = True, default), 
        or keep old ones (supersede = False).
    store : bool
        The newly set plotting parameter dictionary will be stored by the plotting object as new default (if store = True, default is False).
    
    Returns
    -------
    params : dict
        A dictionary of updated plotting parameters
    &#34;&#34;&#34;
    if supersede:
        kwargs = dict(self._PARAMS, **kwargs)
    else:
        kwargs = dict(kwargs, **self._PARAMS)
    
    if store:
        self._PARAMS = kwargs

    return kwargs</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="qpcr.Plotters.Plotters.PreviewResults"><code class="flex name class">
<span>class <span class="ident">PreviewResults</span></span>
<span>(</span><span>mode:Â str, kind:Â strÂ =Â 'AssayBars')</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a Preview of all results from all Assays in subplots.</p>
<p>This is a wrapper for the Plotters: </p>
<ul>
<li><code><a title="qpcr.Plotters.Plotters.AssayBars" href="#qpcr.Plotters.Plotters.AssayBars">AssayBars</a></code> ( which was previously <code><a title="qpcr.Plotters.Plotters.PreviewResults" href="#qpcr.Plotters.Plotters.PreviewResults">PreviewResults</a></code>, and is now the default setting )</li>
<li><code><a title="qpcr.Plotters.Plotters.GroupBars" href="#qpcr.Plotters.Plotters.GroupBars">GroupBars</a></code></li>
<li><code><a title="qpcr.Plotters.Plotters.AssayDots" href="#qpcr.Plotters.Plotters.AssayDots">AssayDots</a></code></li>
<li><code><a title="qpcr.Plotters.Plotters.GroupDots" href="#qpcr.Plotters.Plotters.GroupDots">GroupDots</a></code> </li>
</ul>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>mode</code></strong> :&ensp;<code>str</code></dt>
<dd>The plotting mode. May be either "static" (matplotlib) or "interactive" (plotly).</dd>
<dt><strong><code>kind</code></strong> :&ensp;<code>str</code></dt>
<dd>The kind of Plotter to call. This can be any of the four wrapped
Plotters, e.g. <code>kind = "GroupBars"</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PreviewResults(Wrapper):
    &#34;&#34;&#34;
    Generate a Preview of all results from all Assays in subplots.

    This is a wrapper for the Plotters: 

    - `AssayBars` ( which was previously `PreviewResults`, and is now the default setting )
    - `GroupBars`
    - `AssayDots`
    - `GroupDots` 

    Parameters
    ----------
    mode : str
        The plotting mode. May be either &#34;static&#34; (matplotlib) or &#34;interactive&#34; (plotly).

    kind : str
        The kind of Plotter to call. This can be any of the four wrapped 
        Plotters, e.g. `kind = &#34;GroupBars&#34;`.
    &#34;&#34;&#34;
    def __init__(self, mode : str, kind : str = &#34;AssayBars&#34; ):

        super().__init__( kind = kind, mode = mode )
        
        plotters = {
                        &#34;AssayBars&#34; : AssayBars,
                        &#34;GroupBars&#34; : GroupBars,
                        &#34;AssayDots&#34; : AssayDots,
                        &#34;GroupDots&#34; : GroupDots,  
                }
        
        self._Plotter = plotters[ kind ]
        self._Plotter = self._Plotter( mode = mode )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="qpcr.Plotters.Plotters.Wrapper" href="#qpcr.Plotters.Plotters.Wrapper">Wrapper</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="qpcr.Plotters.Plotters.Wrapper" href="#qpcr.Plotters.Plotters.Wrapper">Wrapper</a></b></code>:
<ul class="hlist">
<li><code><a title="qpcr.Plotters.Plotters.Wrapper.get" href="#qpcr.Plotters.Plotters.Wrapper.get">get</a></code></li>
<li><code><a title="qpcr.Plotters.Plotters.Wrapper.id" href="#qpcr.Plotters.Plotters.Wrapper.id">id</a></code></li>
<li><code><a title="qpcr.Plotters.Plotters.Wrapper.link" href="#qpcr.Plotters.Plotters.Wrapper.link">link</a></code></li>
<li><code><a title="qpcr.Plotters.Plotters.Wrapper.params" href="#qpcr.Plotters.Plotters.Wrapper.params">params</a></code></li>
<li><code><a title="qpcr.Plotters.Plotters.Wrapper.plot" href="#qpcr.Plotters.Plotters.Wrapper.plot">plot</a></code></li>
<li><code><a title="qpcr.Plotters.Plotters.Wrapper.plotter" href="#qpcr.Plotters.Plotters.Wrapper.plotter">plotter</a></code></li>
<li><code><a title="qpcr.Plotters.Plotters.Wrapper.save" href="#qpcr.Plotters.Plotters.Wrapper.save">save</a></code></li>
<li><code><a title="qpcr.Plotters.Plotters.Wrapper.suffix" href="#qpcr.Plotters.Plotters.Wrapper.suffix">suffix</a></code></li>
<li><code><a title="qpcr.Plotters.Plotters.Wrapper.update_params" href="#qpcr.Plotters.Plotters.Wrapper.update_params">update_params</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="qpcr.Plotters.Plotters.ReplicateBoxPlot"><code class="flex name class">
<span>class <span class="ident">ReplicateBoxPlot</span></span>
<span>(</span><span>Filter=None, mode='interactive')</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a boxplot figure summary for the input sample replicates.</p>
<h2 id="note">Note</h2>
<p>This used to be the core of making filter summary figures. However, this has now
been replaced by a dedicated <code><a title="qpcr.Plotters.Plotters.FilterSummary" href="#qpcr.Plotters.Plotters.FilterSummary">FilterSummary</a></code> figure class. Hence, support for linking
<code><a title="qpcr.Filters" href="../Filters/index.html">qpcr.Filters</a></code> directly to this figure class will be dropped in a future release!</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>Filter</code></strong> :&ensp;<code>qpcr.Filters.Filter</code></dt>
<dd>A qpcr.Filters.Filter object. The Filter can also be set using the <code>filter()</code> method.</dd>
<dt><strong><code>mode</code></strong> :&ensp;<code>str</code></dt>
<dd>The plotting mode (either <code>"interactive"</code> or <code>"static"</code>).</dd>
</dl>
<h2 id="plotting-kwargs">Plotting Kwargs</h2>
<h4 id="static-kwargs"><code>"static"</code> Kwargs</h4>
<p>Static ReplicateBoxPlot figures accept the following kwargs:</p>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Description</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td>show : <code>bool</code></td>
<td>Whether or not to show the figure</td>
<td><code>show = True</code> (default)</td>
</tr>
<tr>
<td>figsize : <code>tuple</code></td>
<td>The figure size</td>
<td><code>figsize = (10, 4)</code></td>
</tr>
<tr>
<td>subplots : <code>tuple</code></td>
<td>A tuple specifying the number of colums and rows (in that order) for the figure</td>
<td><code>subplots = (2, 3)</code></td>
</tr>
<tr>
<td>title : <code>str</code></td>
<td>The overall figure title</td>
<td>`title = "My assays"</td>
</tr>
<tr>
<td>style : <code>str</code></td>
<td>A <code>seaborn</code> style to set. Check out available styles <a href="https://www.python-graph-gallery.com/104-seaborn-themes">here</a>.</td>
<td><code>style = "darkgrid"</code></td>
</tr>
<tr>
<td>color : <code>str or list</code></td>
<td>The fillcolor for the boxes.</td>
<td><code>color = "yellow"</code></td>
</tr>
<tr>
<td>**kwargs</td>
<td>Any additional kwargs that can be passed to the <code>seaborn</code>'s <code>boxplot()</code>.</td>
<td></td>
</tr>
</tbody>
</table>
<p><br></br></p>
<h4 id="interactive-kwargs"><code>"interactive"</code> Kwargs</h4>
<p>Interactive ReplicateBoxPlot figures accept the following kwargs:</p>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Description</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td>show : <code>bool</code></td>
<td>Whether or not to show the figure</td>
<td><code>show = True</code> (default)</td>
</tr>
<tr>
<td>title : <code>str</code></td>
<td>The overall figure title</td>
<td><code>title = "My run"</code></td>
</tr>
<tr>
<td>ylabel : <code>str</code></td>
<td>The y-axis title</td>
<td><code>ylabel = "Raw Ct value"</code></td>
</tr>
<tr>
<td>height : <code>int</code></td>
<td>Height of the figure</td>
<td><code>height = 50</code></td>
</tr>
<tr>
<td>width : <code>int</code></td>
<td>Width of the figure</td>
<td><code>width = 50</code></td>
</tr>
<tr>
<td>template : <code>str</code></td>
<td>The <code>plotly</code> template to use. Check out available templates <a href="https://plotly.com/python/templates/">here</a>.</td>
<td><code>template = "plotly_dark"</code></td>
</tr>
<tr>
<td>**kwargs</td>
<td>Any additional kwargs that can be passed to <code>plotly</code>'s<code>graphs_objs.Box()</code>.</td>
<td></td>
</tr>
</tbody>
</table></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ReplicateBoxPlot(Plotter):
    &#34;&#34;&#34;
    Generate a boxplot figure summary for the input sample replicates.
    

    Note
    ------
    This used to be the core of making filter summary figures. However, this has now
    been replaced by a dedicated `FilterSummary` figure class. Hence, support for linking
    `qpcr.Filters` directly to this figure class will be dropped in a future release!

    Parameters
    ----------
    Filter : qpcr.Filters.Filter
        A qpcr.Filters.Filter object. The Filter can also be set using the `filter()` method.

    mode : str
        The plotting mode (either `&#34;interactive&#34;` or `&#34;static&#34;`).

    Plotting Kwargs
    ----
    
    #### `&#34;static&#34;` Kwargs
    Static ReplicateBoxPlot figures accept the following kwargs:
    
    |   Argument  |  Description    |  Example    |
    | ---- | ---- | ---- |
    |  show : `bool`    |  Whether or not to show the figure    |  `show = True` (default)   |
    |   figsize : `tuple`   |  The figure size    | `figsize = (10, 4)`     |
    |   subplots : `tuple`   |  A tuple specifying the number of colums and rows (in that order) for the figure    | `subplots = (2, 3)`     |
    | title : `str`   |  The overall figure title   | `title = &#34;My assays&#34;    |
    |  style : `str`   | A `seaborn` style to set. Check out available styles [here](https://www.python-graph-gallery.com/104-seaborn-themes).     | `style = &#34;darkgrid&#34;`    |
    |   color : `str or list`   | The fillcolor for the boxes.   | `color = &#34;yellow&#34;`     |
    |  **kwargs    | Any additional kwargs that can be passed to the `seaborn`&#39;s `boxplot()`.     |      |

    &lt;br&gt;&lt;/br&gt;
    #### `&#34;interactive&#34;` Kwargs
    Interactive ReplicateBoxPlot figures accept the following kwargs:

    |   Argument  |  Description    |  Example    |
    | ---- | ---- | ---- |
    |  show : `bool`    |  Whether or not to show the figure    |  `show = True` (default)   |
    | title : `str`   |  The overall figure title   | `title = &#34;My run&#34;`    |
    | ylabel : `str`   |  The y-axis title   | `ylabel = &#34;Raw Ct value&#34;`    |
    |  height : `int`   |   Height of the figure   | `height = 50`    |
    |  width : `int`   |   Width of the figure   | `width = 50`    |
    |  template : `str`   | The `plotly` template to use. Check out available templates [here](https://plotly.com/python/templates/).     | `template = &#34;plotly_dark&#34;`    |
    |  **kwargs    | Any additional kwargs that can be passed to `plotly`&#39;s`graphs_objs.Box()`.     |      |

    &#34;&#34;&#34;
    def __init__(self, Filter = None, mode=&#34;interactive&#34;):
        self._setup_default_params(
                                    static = defaults.static_ReplicateBoxPlot, 
                                    interactive = defaults.interactive_ReplicateBoxPlot
                                )
        # __init__ is going to require default_params to be already set!
        super().__init__(mode=mode)
        self._data = None
        if Filter is not None: 
            wa.SoftWarning(&#34;Versions:Deprecation&#34;, old = &#34;ReplicateBoxPlot for use with Filters&#34;, new = &#34;FilterSummary&#34; )
        self._Filter = Filter
        self._filter_stats = None
    
    # FUTURE DROP HERE
    def filter(self, Filter):
        &#34;&#34;&#34;
        Links a Filter object for which a report figure shall be generated

        Note
        -------
        Support for linking Filters to use this Figure class to visualse Filter Summaries will be 
        dropped in a future release! Use the dedicated `FilterSummary` figure class instead!

        Parameters
        ----------
        Filter : qpcr.Filters.Filter
            A qpcr.Filters.Filter object.

        &#34;&#34;&#34;
        wa.SoftWarning(&#34;Versions:Deprecation&#34;, old = &#34;ReplicateBoxPlot for use with Filters&#34;, new = &#34;FilterSummary&#34; )
        self._Filter = Filter

    def clear(self):
        &#34;&#34;&#34;
        Will clear the currently stored Assay data
        &#34;&#34;&#34;
        self._data = None

    def link(self, Assay:qpcr.Assay):
        &#34;&#34;&#34;
        Links an Assay object to the BoxPlotter.
        This will simply add the Ct column to the current overall data!
        Hence, repeated linking of Assay objects will add data and NOT replace any existing.

        Parameters
        ----------
        Assay : qpcr.Assay
            A qpcr.Assay object.
        &#34;&#34;&#34;
        if aux.same_type(Assay, qpcr.Assay()):
            self._Results = Assay
            data = self._Results.get( copy = True )
        else:
            wa.HardWarning(&#34;Plotter:unknown_data&#34;, obj = Assay)

        # add itentifier column
        data[&#34;assay&#34;] = [self._Results.id() for i in range(len(data))]

        if self._data is None: 
            self._data = data
        else:
            self._data = pd.concat([self._data, data], ignore_index=True)
        

    def _interactive_plot(self, **kwargs):
        &#34;&#34;&#34;
        Generates an interactive Boxplot summary of the input Ct values
        &#34;&#34;&#34;
        kwargs = self.update_params(kwargs)

        show = aux.from_kwargs(&#34;show&#34;, True, kwargs, rm = True)
        template = aux.from_kwargs(&#34;template&#34;, None, kwargs, rm=True)
        title = aux.from_kwargs(&#34;title&#34;, None, kwargs, rm=True)

        data = self._data
    
        groups = aux.sorted_set(data[&#34;group&#34;])
        group_names = aux.sorted_set(data[&#34;group_name&#34;])

        fig = go.Figure()

        fig.update_layout(
                            boxmode=&#34;group&#34;, 
                            height = aux.from_kwargs(&#34;height&#34;, None, kwargs, rm = True), 
                            width = aux.from_kwargs(&#34;width&#34;, None, kwargs, rm = True),
                            template = template, 
                            title = title,
                        )

        # add default ylabel
        ylabel = aux.from_kwargs(&#34;ylabel&#34;, &#34;Ct&#34;, kwargs, rm = True) 
        fig.update_yaxes(title_text = ylabel)

        fig.update_xaxes(showgrid=True)

        for group, name in zip(groups, group_names):
            tmp_df = data.query(f&#34;group == {group}&#34;)
            
            
            fig.add_trace(
                            go.Box(
                                x = tmp_df[&#34;assay&#34;],
                                y = tmp_df[&#34;Ct&#34;],
                                name = name,
                                hoverinfo = &#34;y+name&#34;,
                                **kwargs,
                            ),
                        )

        if show:
            fig.show()

        return fig 


    def _static_plot(self, **kwargs):
        &#34;&#34;&#34;
        Generates a static Boxplot summary of the input Ct values
        &#34;&#34;&#34;
        kwargs = self.update_params(kwargs)
        data = self._data
        
        # set a seaborn style
        style = aux.from_kwargs(&#34;style&#34;, &#34;ticks&#34;, kwargs, rm = True)
        sns.set_style( style )

        show = aux.from_kwargs(&#34;show&#34;, True, kwargs, rm = True)
        figsize = aux.from_kwargs(&#34;figsize&#34;, (7,5), kwargs, rm=True)
        title = aux.from_kwargs(&#34;title&#34;, None, kwargs, rm=True)
        palette = gx.generate_palette(kwargs)
        show_spines = aux.from_kwargs(&#34;frame&#34;, True, kwargs, rm = True)
        ncols, nrows = aux.from_kwargs(&#34;subplots&#34;, gx.make_layout(data, &#34;assay&#34;), kwargs, rm=True)

        fig, axs = plt.subplots(nrows = nrows, ncols = ncols, figsize=figsize)
        
        # possibly nrows and ncols should be switched...
        Coords = gx.AxesCoords(fig, axs, (nrows, ncols))
        
        for assay in aux.sorted_set(data[&#34;assay&#34;]):
            
            try: 
                ax = Coords.subplot()
            except: 
                print(&#34;We ran out of axes ... &#34;)
                break
            tmp = data.query(f&#34;assay == &#39;{assay}&#39;&#34;)

            sns.boxplot(
                        data=tmp, 
                        x = &#34;assay&#34;, y = &#34;Ct&#34;, hue=&#34;group_name&#34;, 
                        palette = palette, 
                        ax = ax, 
                        **kwargs
                    )

            ax.legend(bbox_to_anchor=(1,1), loc = None).remove()
            ax.set(title=assay, xlabel = &#34;&#34;, xticklabels = [],)
            
            if not show_spines:
                sns.despine()

            Coords.increment()

        # add one single legend to the last plot
        ax.legend(bbox_to_anchor=(1,1), loc = None)

        fig.suptitle(title)
        plt.tight_layout()

        if show:
            fig.show()

        return fig </code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="qpcr.Plotters.Plotters.Plotter" href="#qpcr.Plotters.Plotters.Plotter">Plotter</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="qpcr.Plotters.Plotters.ReplicateBoxPlot.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Will clear the currently stored Assay data</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear(self):
    &#34;&#34;&#34;
    Will clear the currently stored Assay data
    &#34;&#34;&#34;
    self._data = None</code></pre>
</details>
</dd>
<dt id="qpcr.Plotters.Plotters.ReplicateBoxPlot.filter"><code class="name flex">
<span>def <span class="ident">filter</span></span>(<span>self, Filter)</span>
</code></dt>
<dd>
<div class="desc"><p>Links a Filter object for which a report figure shall be generated</p>
<h2 id="note">Note</h2>
<p>Support for linking Filters to use this Figure class to visualse Filter Summaries will be
dropped in a future release! Use the dedicated <code><a title="qpcr.Plotters.Plotters.FilterSummary" href="#qpcr.Plotters.Plotters.FilterSummary">FilterSummary</a></code> figure class instead!</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>Filter</code></strong> :&ensp;<code>qpcr.Filters.Filter</code></dt>
<dd>A qpcr.Filters.Filter object.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter(self, Filter):
    &#34;&#34;&#34;
    Links a Filter object for which a report figure shall be generated

    Note
    -------
    Support for linking Filters to use this Figure class to visualse Filter Summaries will be 
    dropped in a future release! Use the dedicated `FilterSummary` figure class instead!

    Parameters
    ----------
    Filter : qpcr.Filters.Filter
        A qpcr.Filters.Filter object.

    &#34;&#34;&#34;
    wa.SoftWarning(&#34;Versions:Deprecation&#34;, old = &#34;ReplicateBoxPlot for use with Filters&#34;, new = &#34;FilterSummary&#34; )
    self._Filter = Filter</code></pre>
</details>
</dd>
<dt id="qpcr.Plotters.Plotters.ReplicateBoxPlot.link"><code class="name flex">
<span>def <span class="ident">link</span></span>(<span>self, Assay:Â qpcr.__init__.Assay)</span>
</code></dt>
<dd>
<div class="desc"><p>Links an Assay object to the BoxPlotter.
This will simply add the Ct column to the current overall data!
Hence, repeated linking of Assay objects will add data and NOT replace any existing.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>Assay</code></strong> :&ensp;<code><a title="qpcr.Assay" href="../index.html#qpcr.Assay">Assay</a></code></dt>
<dd>A qpcr.Assay object.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def link(self, Assay:qpcr.Assay):
    &#34;&#34;&#34;
    Links an Assay object to the BoxPlotter.
    This will simply add the Ct column to the current overall data!
    Hence, repeated linking of Assay objects will add data and NOT replace any existing.

    Parameters
    ----------
    Assay : qpcr.Assay
        A qpcr.Assay object.
    &#34;&#34;&#34;
    if aux.same_type(Assay, qpcr.Assay()):
        self._Results = Assay
        data = self._Results.get( copy = True )
    else:
        wa.HardWarning(&#34;Plotter:unknown_data&#34;, obj = Assay)

    # add itentifier column
    data[&#34;assay&#34;] = [self._Results.id() for i in range(len(data))]

    if self._data is None: 
        self._data = data
    else:
        self._data = pd.concat([self._data, data], ignore_index=True)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="qpcr.Plotters.Plotters.Plotter" href="#qpcr.Plotters.Plotters.Plotter">Plotter</a></b></code>:
<ul class="hlist">
<li><code><a title="qpcr.Plotters.Plotters.Plotter.get" href="#qpcr.Plotters.Plotters.Plotter.get">get</a></code></li>
<li><code><a title="qpcr.Plotters.Plotters.Plotter.id" href="#qpcr.Plotters.Plotters.Plotter.id">id</a></code></li>
<li><code><a title="qpcr.Plotters.Plotters.Plotter.params" href="#qpcr.Plotters.Plotters.Plotter.params">params</a></code></li>
<li><code><a title="qpcr.Plotters.Plotters.Plotter.plot" href="#qpcr.Plotters.Plotters.Plotter.plot">plot</a></code></li>
<li><code><a title="qpcr.Plotters.Plotters.Plotter.save" href="#qpcr.Plotters.Plotters.Plotter.save">save</a></code></li>
<li><code><a title="qpcr.Plotters.Plotters.Plotter.suffix" href="#qpcr.Plotters.Plotters.Plotter.suffix">suffix</a></code></li>
<li><code><a title="qpcr.Plotters.Plotters.Plotter.update_params" href="#qpcr.Plotters.Plotters.Plotter.update_params">update_params</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="qpcr.Plotters.Plotters.Wrapper"><code class="flex name class">
<span>class <span class="ident">Wrapper</span></span>
<span>(</span><span>kind:Â str, mode:Â str)</span>
</code></dt>
<dd>
<div class="desc"><p>A superclass that allows to make wrappers for multiple Plotters
(not for End-User usage).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>kind</code></strong> :&ensp;<code>str</code></dt>
<dd>The kind of Plotter to call. This can be any of the wrapped
Plotters, e.g. <code>kind = "GroupBars"</code>.</dd>
<dt><strong><code>mode</code></strong> :&ensp;<code>str</code></dt>
<dd>The plotting mode. May be either "static" (matplotlib) or "interactive" (plotly).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Wrapper:
    &#34;&#34;&#34;
    A superclass that allows to make wrappers for multiple Plotters 
    (not for End-User usage).

    Parameters
    ----------
    kind : str
        The kind of Plotter to call. This can be any of the wrapped 
        Plotters, e.g. `kind = &#34;GroupBars&#34;`.   
    mode : str
        The plotting mode. May be either &#34;static&#34; (matplotlib) or &#34;interactive&#34; (plotly). 

    &#34;&#34;&#34;
    def __init__(self, kind : str, mode : str):

        self._Plotter = None
        self._id = type(self).__name__

        # Application of this would work as:
        # plotters = {
        #                 &#34;some_Plotter&#34; : some_Plotter, 
        #         }
            
        # self._Plotter = plotters[ kind ]
        # self._Plotter = self._Plotter( mode = mode )
    
    def plotter(self):
        &#34;&#34;&#34;
        Returns
        -------
        plotter
            The currently used core Plotter
        &#34;&#34;&#34;
        plotter = self._Plotter
        return plotter


    def link(self, Results:(qpcr.Results or pd.DataFrame)):
        &#34;&#34;&#34;
        Links a Results object or pandas DataFrame of the same architecture
        as one handled by a Results object to the Plotter. 
        Note, that this will replace any previously linked data!

        Parameters
        ----------
        Results : qpcr.Results or pd.DataFrame
            A qpcr.Results Object or a pandas DataFrame of the same architecture.
        &#34;&#34;&#34;
        plotter = self._Plotter
        plotter.link( Results )


    def plot(self, **kwargs):
        &#34;&#34;&#34;
        Generate Figure

        Parameters
        ----------
        **kwargs
            Any arbitrary keyword arguments to be passed to the plotting method
        
        Returns
        -------
        fig
            A figure object, either from matplotlib or plotly
        &#34;&#34;&#34;
        fig = self._Plotter.plot( **kwargs )
        return fig 

    def id(self, id:str = None):
        &#34;&#34;&#34;
        Set a unique Id, by default the Classname will be used.

        Parameters
        ----------
        id : str
            A unique identifier for the Plotter object
        
        Returns
        -------
        id 
            The Plotter Id (if no id keyword was entered)
        &#34;&#34;&#34;
        if id is not None:
            self._id = id
        else:
            return self._id

    def get(self):
        &#34;&#34;&#34;
        Returns the DataFrame used for plotting

        Returns
        -------
        data
            A pandas DataFrame containing the data underlying the plot.
        &#34;&#34;&#34;
        return self._Plotter.get()

    def params(self, **params):
        &#34;&#34;&#34;
        Set default parameters for plotting (will be forwarded to **kwargs)
        Returns default parameters if no new parameters are added.

        Parameters
        ----------
        **params
            Any arbitrary keyword arguments to be passed on to the pre-set plotting kwargs.
            This will either set the default parameters (if none has been specified up to the function call)
            or will update the parameters. In case of keyword duplications any OLD key : value pairs will be 
            OVERWRITTEN by new ones. 
        
        Returns
        -------
        params : dict
            A dictionary of the new pre-set plotting parameters
        &#34;&#34;&#34;
        params = self._Plotter.params( **params )
        return params

    def update_params(self, kwargs, supersede = True, store = False):
        &#34;&#34;&#34;
        Appends pre-set parameters to kwargs. 
        
        Parameters
        ----------
        kwargs : dict
            A dictionary of arbitrary keywords for plotting 
        supersede : bool 
            In case of key duplications: Old values will be replaced with new ones (if supersede = True, default), 
            or keep old ones (supersede = False).
        store : bool
            The newly set plotting parameter dictionary will be stored by the plotting object as new default (if store = True, default is False).
        
        Returns
        -------
        params : dict
            A dictionary of updated plotting parameters
        &#34;&#34;&#34;
        params = self._Plotter.update_params( kwargs, supersede = supersede, store = store )
        return params

    def save(self, filename, **kwargs):
        &#34;&#34;&#34;
        Saves the figure to a file. 
        Figures are either saved using `plt.savefig` or `plotly.offline.plot`.

        Parameters
        ----------
        filename : str 
            A filename to save the figure to.
        
        **kwargs
            Any arbitrary keyword arguments for the respective figure saving method. 
        &#34;&#34;&#34;
        self._Plotter.save( filename = filename, **kwargs )
    
    def suffix(self):
        &#34;&#34;&#34;
        Returns
        ------- 
        suffix : str
            The appropriate file suffix for save (html for &#34;interactive&#34; or jpg for &#34;static&#34; figures)
        &#34;&#34;&#34;
        suffix = self._Plotter.suffix()
        return suffix

    def id(self, id:str = None):
        &#34;&#34;&#34;
        Set a unique Id, by default the Classname will be used.

        Parameters
        ----------
        id : str
            A unique identifier for the Plotter object
        
        Returns
        -------
        id 
            The Plotter Id (if no id keyword was entered)
        &#34;&#34;&#34;
        if id is not None:
            self._id = id
        else:
            return self._id</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="qpcr.Plotters.Plotters.PreviewResults" href="#qpcr.Plotters.Plotters.PreviewResults">PreviewResults</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="qpcr.Plotters.Plotters.Wrapper.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the DataFrame used for plotting</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>data</code></dt>
<dd>A pandas DataFrame containing the data underlying the plot.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(self):
    &#34;&#34;&#34;
    Returns the DataFrame used for plotting

    Returns
    -------
    data
        A pandas DataFrame containing the data underlying the plot.
    &#34;&#34;&#34;
    return self._Plotter.get()</code></pre>
</details>
</dd>
<dt id="qpcr.Plotters.Plotters.Wrapper.id"><code class="name flex">
<span>def <span class="ident">id</span></span>(<span>self, id:Â strÂ =Â None)</span>
</code></dt>
<dd>
<div class="desc"><p>Set a unique Id, by default the Classname will be used.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>id</code></strong> :&ensp;<code>str</code></dt>
<dd>A unique identifier for the Plotter object</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>id </code></dt>
<dd>The Plotter Id (if no id keyword was entered)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def id(self, id:str = None):
    &#34;&#34;&#34;
    Set a unique Id, by default the Classname will be used.

    Parameters
    ----------
    id : str
        A unique identifier for the Plotter object
    
    Returns
    -------
    id 
        The Plotter Id (if no id keyword was entered)
    &#34;&#34;&#34;
    if id is not None:
        self._id = id
    else:
        return self._id</code></pre>
</details>
</dd>
<dt id="qpcr.Plotters.Plotters.Wrapper.link"><code class="name flex">
<span>def <span class="ident">link</span></span>(<span>self, Results:Â qpcr.__init__.Results)</span>
</code></dt>
<dd>
<div class="desc"><p>Links a Results object or pandas DataFrame of the same architecture
as one handled by a Results object to the Plotter.
Note, that this will replace any previously linked data!</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>Results</code></strong> :&ensp;<code><a title="qpcr.Results" href="../index.html#qpcr.Results">Results</a></code> or <code>pd.DataFrame</code></dt>
<dd>A qpcr.Results Object or a pandas DataFrame of the same architecture.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def link(self, Results:(qpcr.Results or pd.DataFrame)):
    &#34;&#34;&#34;
    Links a Results object or pandas DataFrame of the same architecture
    as one handled by a Results object to the Plotter. 
    Note, that this will replace any previously linked data!

    Parameters
    ----------
    Results : qpcr.Results or pd.DataFrame
        A qpcr.Results Object or a pandas DataFrame of the same architecture.
    &#34;&#34;&#34;
    plotter = self._Plotter
    plotter.link( Results )</code></pre>
</details>
</dd>
<dt id="qpcr.Plotters.Plotters.Wrapper.params"><code class="name flex">
<span>def <span class="ident">params</span></span>(<span>self, **params)</span>
</code></dt>
<dd>
<div class="desc"><p>Set default parameters for plotting (will be forwarded to **kwargs)
Returns default parameters if no new parameters are added.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>**params</code></strong></dt>
<dd>Any arbitrary keyword arguments to be passed on to the pre-set plotting kwargs.
This will either set the default parameters (if none has been specified up to the function call)
or will update the parameters. In case of keyword duplications any OLD key : value pairs will be
OVERWRITTEN by new ones.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>params</code></strong> :&ensp;<code>dict</code></dt>
<dd>A dictionary of the new pre-set plotting parameters</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def params(self, **params):
    &#34;&#34;&#34;
    Set default parameters for plotting (will be forwarded to **kwargs)
    Returns default parameters if no new parameters are added.

    Parameters
    ----------
    **params
        Any arbitrary keyword arguments to be passed on to the pre-set plotting kwargs.
        This will either set the default parameters (if none has been specified up to the function call)
        or will update the parameters. In case of keyword duplications any OLD key : value pairs will be 
        OVERWRITTEN by new ones. 
    
    Returns
    -------
    params : dict
        A dictionary of the new pre-set plotting parameters
    &#34;&#34;&#34;
    params = self._Plotter.params( **params )
    return params</code></pre>
</details>
</dd>
<dt id="qpcr.Plotters.Plotters.Wrapper.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate Figure</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Any arbitrary keyword arguments to be passed to the plotting method</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>fig</code></dt>
<dd>A figure object, either from matplotlib or plotly</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self, **kwargs):
    &#34;&#34;&#34;
    Generate Figure

    Parameters
    ----------
    **kwargs
        Any arbitrary keyword arguments to be passed to the plotting method
    
    Returns
    -------
    fig
        A figure object, either from matplotlib or plotly
    &#34;&#34;&#34;
    fig = self._Plotter.plot( **kwargs )
    return fig </code></pre>
</details>
</dd>
<dt id="qpcr.Plotters.Plotters.Wrapper.plotter"><code class="name flex">
<span>def <span class="ident">plotter</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<dl>
<dt><code>plotter</code></dt>
<dd>The currently used core Plotter</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plotter(self):
    &#34;&#34;&#34;
    Returns
    -------
    plotter
        The currently used core Plotter
    &#34;&#34;&#34;
    plotter = self._Plotter
    return plotter</code></pre>
</details>
</dd>
<dt id="qpcr.Plotters.Plotters.Wrapper.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, filename, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Saves the figure to a file.
Figures are either saved using <code>plt.savefig</code> or <code>plotly.offline.plot</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>str </code></dt>
<dd>A filename to save the figure to.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Any arbitrary keyword arguments for the respective figure saving method.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save(self, filename, **kwargs):
    &#34;&#34;&#34;
    Saves the figure to a file. 
    Figures are either saved using `plt.savefig` or `plotly.offline.plot`.

    Parameters
    ----------
    filename : str 
        A filename to save the figure to.
    
    **kwargs
        Any arbitrary keyword arguments for the respective figure saving method. 
    &#34;&#34;&#34;
    self._Plotter.save( filename = filename, **kwargs )</code></pre>
</details>
</dd>
<dt id="qpcr.Plotters.Plotters.Wrapper.suffix"><code class="name flex">
<span>def <span class="ident">suffix</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<p>suffix : str
The appropriate file suffix for save (html for "interactive" or jpg for "static" figures)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def suffix(self):
    &#34;&#34;&#34;
    Returns
    ------- 
    suffix : str
        The appropriate file suffix for save (html for &#34;interactive&#34; or jpg for &#34;static&#34; figures)
    &#34;&#34;&#34;
    suffix = self._Plotter.suffix()
    return suffix</code></pre>
</details>
</dd>
<dt id="qpcr.Plotters.Plotters.Wrapper.update_params"><code class="name flex">
<span>def <span class="ident">update_params</span></span>(<span>self, kwargs, supersede=True, store=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Appends pre-set parameters to kwargs. </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>A dictionary of arbitrary keywords for plotting</dd>
<dt><strong><code>supersede</code></strong> :&ensp;<code>bool </code></dt>
<dd>In case of key duplications: Old values will be replaced with new ones (if supersede = True, default),
or keep old ones (supersede = False).</dd>
<dt><strong><code>store</code></strong> :&ensp;<code>bool</code></dt>
<dd>The newly set plotting parameter dictionary will be stored by the plotting object as new default (if store = True, default is False).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>params</code></strong> :&ensp;<code>dict</code></dt>
<dd>A dictionary of updated plotting parameters</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_params(self, kwargs, supersede = True, store = False):
    &#34;&#34;&#34;
    Appends pre-set parameters to kwargs. 
    
    Parameters
    ----------
    kwargs : dict
        A dictionary of arbitrary keywords for plotting 
    supersede : bool 
        In case of key duplications: Old values will be replaced with new ones (if supersede = True, default), 
        or keep old ones (supersede = False).
    store : bool
        The newly set plotting parameter dictionary will be stored by the plotting object as new default (if store = True, default is False).
    
    Returns
    -------
    params : dict
        A dictionary of updated plotting parameters
    &#34;&#34;&#34;
    params = self._Plotter.update_params( kwargs, supersede = supersede, store = store )
    return params</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">

<a href="https://github.com/NoahHenrikKleinschmidt/qpcr">
<img src="../qpcr_light.svg" width = "100%" >
</a>
<h1>Index</h1>

<div class="toc">
<ul>
<li><a href="#static-vs-interactive-figures">Static vs Interactive Figures</a><ul>
<li><a href="#static-figures">Static Figures</a></li>
<li><a href="#interactive-figures">Interactive Figures</a></li>
<li><a href="#plotting-kwargs">Plotting kwargs</a></li>
</ul>
</li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="qpcr.Plotters" href="index.html">qpcr.Plotters</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="qpcr.Plotters.Plotters.AssayBars" href="#qpcr.Plotters.Plotters.AssayBars">AssayBars</a></code></h4>
</li>
<li>
<h4><code><a title="qpcr.Plotters.Plotters.AssayDots" href="#qpcr.Plotters.Plotters.AssayDots">AssayDots</a></code></h4>
</li>
<li>
<h4><code><a title="qpcr.Plotters.Plotters.EfficiencyLines" href="#qpcr.Plotters.Plotters.EfficiencyLines">EfficiencyLines</a></code></h4>
<ul class="">
<li><code><a title="qpcr.Plotters.Plotters.EfficiencyLines.link" href="#qpcr.Plotters.Plotters.EfficiencyLines.link">link</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="qpcr.Plotters.Plotters.FilterSummary" href="#qpcr.Plotters.Plotters.FilterSummary">FilterSummary</a></code></h4>
<ul class="">
<li><code><a title="qpcr.Plotters.Plotters.FilterSummary.add_after" href="#qpcr.Plotters.Plotters.FilterSummary.add_after">add_after</a></code></li>
<li><code><a title="qpcr.Plotters.Plotters.FilterSummary.add_before" href="#qpcr.Plotters.Plotters.FilterSummary.add_before">add_before</a></code></li>
<li><code><a title="qpcr.Plotters.Plotters.FilterSummary.clear" href="#qpcr.Plotters.Plotters.FilterSummary.clear">clear</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="qpcr.Plotters.Plotters.GroupBars" href="#qpcr.Plotters.Plotters.GroupBars">GroupBars</a></code></h4>
</li>
<li>
<h4><code><a title="qpcr.Plotters.Plotters.GroupDots" href="#qpcr.Plotters.Plotters.GroupDots">GroupDots</a></code></h4>
</li>
<li>
<h4><code><a title="qpcr.Plotters.Plotters.Plotter" href="#qpcr.Plotters.Plotters.Plotter">Plotter</a></code></h4>
<ul class="two-column">
<li><code><a title="qpcr.Plotters.Plotters.Plotter.get" href="#qpcr.Plotters.Plotters.Plotter.get">get</a></code></li>
<li><code><a title="qpcr.Plotters.Plotters.Plotter.id" href="#qpcr.Plotters.Plotters.Plotter.id">id</a></code></li>
<li><code><a title="qpcr.Plotters.Plotters.Plotter.link" href="#qpcr.Plotters.Plotters.Plotter.link">link</a></code></li>
<li><code><a title="qpcr.Plotters.Plotters.Plotter.params" href="#qpcr.Plotters.Plotters.Plotter.params">params</a></code></li>
<li><code><a title="qpcr.Plotters.Plotters.Plotter.plot" href="#qpcr.Plotters.Plotters.Plotter.plot">plot</a></code></li>
<li><code><a title="qpcr.Plotters.Plotters.Plotter.save" href="#qpcr.Plotters.Plotters.Plotter.save">save</a></code></li>
<li><code><a title="qpcr.Plotters.Plotters.Plotter.suffix" href="#qpcr.Plotters.Plotters.Plotter.suffix">suffix</a></code></li>
<li><code><a title="qpcr.Plotters.Plotters.Plotter.update_params" href="#qpcr.Plotters.Plotters.Plotter.update_params">update_params</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="qpcr.Plotters.Plotters.PreviewResults" href="#qpcr.Plotters.Plotters.PreviewResults">PreviewResults</a></code></h4>
</li>
<li>
<h4><code><a title="qpcr.Plotters.Plotters.ReplicateBoxPlot" href="#qpcr.Plotters.Plotters.ReplicateBoxPlot">ReplicateBoxPlot</a></code></h4>
<ul class="">
<li><code><a title="qpcr.Plotters.Plotters.ReplicateBoxPlot.clear" href="#qpcr.Plotters.Plotters.ReplicateBoxPlot.clear">clear</a></code></li>
<li><code><a title="qpcr.Plotters.Plotters.ReplicateBoxPlot.filter" href="#qpcr.Plotters.Plotters.ReplicateBoxPlot.filter">filter</a></code></li>
<li><code><a title="qpcr.Plotters.Plotters.ReplicateBoxPlot.link" href="#qpcr.Plotters.Plotters.ReplicateBoxPlot.link">link</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="qpcr.Plotters.Plotters.Wrapper" href="#qpcr.Plotters.Plotters.Wrapper">Wrapper</a></code></h4>
<ul class="two-column">
<li><code><a title="qpcr.Plotters.Plotters.Wrapper.get" href="#qpcr.Plotters.Plotters.Wrapper.get">get</a></code></li>
<li><code><a title="qpcr.Plotters.Plotters.Wrapper.id" href="#qpcr.Plotters.Plotters.Wrapper.id">id</a></code></li>
<li><code><a title="qpcr.Plotters.Plotters.Wrapper.link" href="#qpcr.Plotters.Plotters.Wrapper.link">link</a></code></li>
<li><code><a title="qpcr.Plotters.Plotters.Wrapper.params" href="#qpcr.Plotters.Plotters.Wrapper.params">params</a></code></li>
<li><code><a title="qpcr.Plotters.Plotters.Wrapper.plot" href="#qpcr.Plotters.Plotters.Wrapper.plot">plot</a></code></li>
<li><code><a title="qpcr.Plotters.Plotters.Wrapper.plotter" href="#qpcr.Plotters.Plotters.Wrapper.plotter">plotter</a></code></li>
<li><code><a title="qpcr.Plotters.Plotters.Wrapper.save" href="#qpcr.Plotters.Plotters.Wrapper.save">save</a></code></li>
<li><code><a title="qpcr.Plotters.Plotters.Wrapper.suffix" href="#qpcr.Plotters.Plotters.Wrapper.suffix">suffix</a></code></li>
<li><code><a title="qpcr.Plotters.Plotters.Wrapper.update_params" href="#qpcr.Plotters.Plotters.Wrapper.update_params">update_params</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>