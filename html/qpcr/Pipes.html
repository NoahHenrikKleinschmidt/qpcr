<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>qpcr.Pipes API documentation</title>
<meta name="description" content="This module contains a set of common lightweight wrappers to perform simple and non-customised DeltaDeltaCt analyses.
This is designed for lightweight …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>qpcr.Pipes</code></h1>
</header>
<section id="section-intro">
<p>This module contains a set of common lightweight wrappers to perform simple and non-customised DeltaDeltaCt analyses.
This is designed for lightweight users that do not wish to employ specialised pipelines.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This module contains a set of common lightweight wrappers to perform simple and non-customised DeltaDeltaCt analyses.
This is designed for lightweight users that do not wish to employ specialised pipelines.
&#34;&#34;&#34;

import qpcr.__init__ as qpcr
import matplotlib.pyplot as plt
import pandas as pd 
import statistics as stats
import qpcr._auxiliary.warnings as wa
import qpcr._auxiliary as aux
import qpcr.Plotters as Plotters
import qpcr.Filters as Filters
import re
import os 
import difflib

class Pipeline(qpcr.SampleReader):
    &#34;&#34;&#34;
    This is the basic template class for qpcr Pipelines. 
    It contains a set of basic preliminary methods
    that ensure that elementary required inputs are provided.

    Note
    ----
    The simplest implementation of this `Pipeline` template is the `Basic` pipeline.
    &#34;&#34;&#34;
    def __init__(self):
        super().__init__()
        self._Normalisers = []
        self._Assays = []
        self._save_to = None
        self._df = None
        self._stats_df = None
        self._Results = None
        self._replicates = None
        self._names = None
        self._softlink = True

    def run(self, **kwargs):
        &#34;&#34;&#34;
        Will run the pipeline provided that at least minimal inputs have been provided (i.e. Assays and Normalisers, as well as replicate specifics have been provided).
        This is a wrapper, the actual functional core is defined in the method `self._run()`. 
        To implement your own pipeline, make sure to define your own `_run()`, redefine `run()`
        as you require.

        Parameters
        ----------
        **kwargs
            Any additional keyword arguments that will be passed to the actual `_run()` method.
        &#34;&#34;&#34;
        if self._replicates is None:
            wa.HardWarning(&#34;Pipeline:no_reps&#34;)
        elif self._Normalisers == [] or self._Assays == []:
            wa.HardWarning(&#34;Pipeline:no_data&#34;)

        self._run(**kwargs)
    
    def save_to(self, directory:str):
        &#34;&#34;&#34;
        Set the location where to save result files

        Parameters
        ----------
        directory : str
            A directory to save the results to.
        &#34;&#34;&#34;
        self._save_to = directory
        # if the directory does not yet exist, we make it
        if not os.path.exists(self._save_to):
            os.mkdir(self._save_to)

    def get(self, kind=&#34;stats&#34;):
        &#34;&#34;&#34;
        Returns
        -------
        data 
            A pandas dataframe either in replicate version `kind=&#34;df&#34;`
            or in stats version `kind=&#34;stats&#34;` (default). Alternatively,
            a qpcr.Results object can be returned using `kind=&#34;obj&#34;`.
        &#34;&#34;&#34;
        if kind == &#34;stats&#34;:
            return self._stats_df
        elif kind == &#34;df&#34;:
            df = self._df
            df = df.drop(columns = [&#34;assay&#34;])
            return df
        elif kind == &#34;obj&#34;:
            return self._Results
    
    def link(self, samples:(list or str)):
        &#34;&#34;&#34;
        Links new sample assays to the pipline, either replacing old ones or keeping them, 
        depending on `softlink()` settings.

        Parameters
        ----------
        samples : list or str
            A `list` of filepaths to raw datafiles of sample assays, or a directory (`str`) where these are stored.
        &#34;&#34;&#34;
        if self._softlink:
            self.prune()
        self.add_assays(samples)

    def prune(self, assays = True, results = True, normalisers = False):
        &#34;&#34;&#34;
        Will clear assays, results, and/or normalisers

        Parameters
        ----------
        assays : bool
            Will clear any sample assays in the pipeline if True (default).
        
        results : bool
            Will clear any computed results in the pipline if True (default).
        
        normalisers : bool
            Will clear any normalisers in the pipline if True (default is False).
        &#34;&#34;&#34;
        if assays: self._Assays = []
        if normalisers: self._Normalisers = []
        if results: 
            self._df = None
            self._stats_df = None
            self._Results = None

    def add_normalisers(self, normalisers):
        &#34;&#34;&#34;
        Adds normalisers (filepaths) (keeping any already present)
        
        Parameters
        ----------
        normalisers : list or str
            A `list` of filepaths to raw datafiles of normaliser assays, or a directory (`str`) where these are stored.
        &#34;&#34;&#34;
        normalisers = self._from_directory(normalisers)
        self._Normalisers.extend(normalisers)
    
    def add_assays(self, samples):
        &#34;&#34;&#34;
        Adds sample assays (filepaths) (keeping any already present)

        Parameters
        ----------
        samples : list or str
            A `list` of filepaths to raw datafiles of sample assays, or a directory (`str`) where these are stored.
        &#34;&#34;&#34;
        samples = self._from_directory(samples)
        self._Assays.extend(samples)

    def softlink(self, bool = None):
        &#34;&#34;&#34;
        If `softlink = True`, then `link_assays()` will 
        prune any previous assays. Otherwise, it will 
        add new ones and keep old ones.

        Parameters
        ----------
        bool
            Set to False to disable `softlinking` (default is True).
        &#34;&#34;&#34;
        if bool is None:
            return self._softlink
        else:
            self._softlink = bool

    def _from_directory(self, files):
        &#34;&#34;&#34;
        Checks if a directory was provided for assays / normalisers and returns a list of all contained files if so.
        Otherwise it just returns the list of files.
        This is used for add_assays and add_normalisers
        &#34;&#34;&#34;
        if isinstance(files, str):
            if os.path.isdir(files):
                norms = os.listdir(files)
                norms = [os.path.join(files,n) for n in norms]
                return norms
        else:
            return files

    def _run(self, **kwargs):
        &#34;&#34;&#34;
        This is the actual function that each custom Pipeline has to define...
        &#34;&#34;&#34;
        print(&#34;self._run() is the actual function that each custom Pipeline has to define...&#34;)


class Basic(Pipeline):
    &#34;&#34;&#34;
    Performs simple standardized DeltaDeltaCt analysis 
    based on two lists of files, one for normalisers, one for Sample Assays...
    This makes use of standard settings for qpcr.Analyser() and qpcr.Assay()
    which cannot be customized! For customization generate your own pipeline!
    &#34;&#34;&#34;
    def __init__(self):
        super().__init__()
    
    def _run(self):
        &#34;&#34;&#34;
        The automated standard DeltaDeltaCt pipeline. 
        Using default settings of qpcr.Analyser()
        &#34;&#34;&#34;
        reader = qpcr.SampleReader()
        reader.replicates(self._replicates)
        if self._names is not None:
            reader.names(self._names)
        
        analyser = qpcr.Analyser()
        normaliser = qpcr.Normaliser()

        normalisers = []
        samples = []

        # analyse normalisers:
        for _normaliser in self._Normalisers:
            norm = reader.read(_normaliser)
            norm = analyser.pipe(norm)
            normalisers.append(norm)
        normaliser.link(normalisers = normalisers)

        # analyse sample assays
        for sample in self._Assays:
            _sample = reader.read(sample)
            _sample = analyser.pipe(_sample)
            samples.append(_sample)
        normaliser.link(samples = samples)

        normaliser.normalise()
        results = normaliser.get()

        self._Results = results
        self._df = results.get()
        self._stats_df = results.stats()

        if self._save_to is not None:
            results.save(self._save_to)

class BasicPlus(Basic):
    &#34;&#34;&#34;
    The same as the Basic Pipeline, but has the option to integrate Plotters and Filters.
    &#34;&#34;&#34;
    def __init__(self):
        super().__init__()
        self._Plotters = []
        self._Figures = []
        self._Filters = []
    
    def add_plotters(self, *Plotters:object):
        &#34;&#34;&#34;
        Adds already specified qpcr.Plotter objects to the Pipeline.
        
        Parameters
        ----------
        *Plotters
            Any number of qpcr.Plotters.Plotter objects.
        &#34;&#34;&#34;
        self._Plotters.extend(Plotters)
    
    def add_filters(self, *Filters:object):
        &#34;&#34;&#34;
        Adds already specified qpcr.Filter instances to the Pipeline.
        
        Parameters
        ----------
        *Filters
            Any number of `qpcr.Filters.Filter` objects.
        &#34;&#34;&#34;
        self._Filters.extend(Filters)

    def Figures(self):
        &#34;&#34;&#34;
        Returns
        -------
        list
            A list of all Figures generated by the pipeline&#39;s Plotters.
        &#34;&#34;&#34;
        return self._Figures

    def _run(self):
        &#34;&#34;&#34;
        The automated standard DeltaDeltaCt pipeline. 
        Also produces applies and Plotters to produce figures...
        &#34;&#34;&#34;

        reader = qpcr.SampleReader()
        reader.replicates(self._replicates)
        if self._names is not None:
            reader.names(self._names)
        
        analyser = qpcr.Analyser()
        normaliser = qpcr.Normaliser()

        normalisers = []
        samples = []

        # analyse normalisers:
        for _normaliser in self._Normalisers:
            norm = reader.read(_normaliser)

            for filter in self._Filters:
                norm = filter.pipe(norm)

            norm = analyser.pipe(norm)
            normalisers.append(norm)
        normaliser.link(normalisers = normalisers)

        # analyse sample assays
        for sample in self._Assays:
            _sample = reader.read(sample)

            for filter in self._Filters:
                _sample = filter.pipe(_sample)

            _sample = analyser.pipe(_sample)
            samples.append(_sample)
        normaliser.link(samples = samples)

        normaliser.normalise()
        results = normaliser.get()

        self._Results = results
        self._df = results.get()
        self._stats_df = results.stats()

        if self._save_to is not None:
            results.save(self._save_to)

        # plot filtering report
        for filter in self._Filters:
            if self._save_to is not None or filter.report() is not None:
                # add report location if none was specified...
                if filter.report() is None: 
                    filter.report(self._save_to)

            figs = filter.plot()
            self._Figures.extend(figs)

        # plot results
        for plotter in self._Plotters:
            plotter.link(self._Results)
            fig = plotter.plot()
            self._Figures.append(fig)

            if self._save_to is not None:
                filename = self._make_figure_filename(plotter)
                plotter.save(filename)

    def _make_figure_filename(self, plotter):
        &#34;&#34;&#34;
        Increments a filename with a numeric counter...
        &#34;&#34;&#34;
        num = 1
        suffix = plotter.suffix()
        while True:
            filename = os.path.join(self._save_to, f&#34;{plotter.id()}_{num}.{suffix}&#34;)
            if not os.path.exists(filename):
                break
            num+=1
        return filename

class Blueprint(BasicPlus):
    &#34;&#34;&#34;
    Performs simple Delta-Delta-Ct analysis based on the same workflow as the `Basic` pipeline, but allows full costumization of SampleReader, Analyser, and Normaliser objects.
    Optionally, SampleReader, Analyser, and Normaliser may be set up externally and linked into the pipeline. Any non-linked processing classes will be set up as per default.
    &#34;&#34;&#34;
    def __init__(self):
        super().__init__()
        self._Reader = None
        self._Analyser = None
        self._Normaliser = None

    def Reader(self, Reader : qpcr.SampleReader = None):
        &#34;&#34;&#34;
        Links a `qpcr.SampleReader` object to the pipeline.

        Parameters
        ----------
        Reader : qpcr.SampleReader
            A `qpcr.SampleReader` object
        &#34;&#34;&#34;
        if Reader is not None: 
            self._Reader = Reader
        return self._Reader

    def Analyser(self, Analyser : qpcr.Analyser = None):
        &#34;&#34;&#34;
        Links a `qpcr.Analyser` object to the pipeline.

        Parameters
        ----------
        Analyser : qpcr.Analyser
            A `qpcr.Analyser` object
        &#34;&#34;&#34;
        if Analyser is not None:
            self._Analyser = Analyser
        return self._Analyser

    def Normaliser(self, Normaliser : qpcr.Normaliser = None):
        &#34;&#34;&#34;
        Links a `qpcr.Normaliser` object to the pipeline.

        Parameters
        ----------
        Normaliser : qpcr.Normaliser
            A `qpcr.Normaliser` object
        &#34;&#34;&#34;
        if Normaliser is not None:
            self._Normaliser = Normaliser
        return self._Normaliser
    
    def _setup_cores(self):
        &#34;&#34;&#34;
        Sets SampleReader, Analyser, and Normaliser to defaults, if no external ones were provided...
        &#34;&#34;&#34;
        if self.Reader() is None: 
            self.Reader(qpcr.SampleReader())
        if self.Analyser() is None: 
            self.Analyser(qpcr.Analyser())
        if self.Normaliser() is None:
            self.Normaliser(qpcr.Normaliser())

    def _run(self):
        &#34;&#34;&#34;
        The automated standard DeltaDeltaCt pipeline. 
        Also produces applies and Plotters to produce figures...
        &#34;&#34;&#34;
        # setup SampleReader, Analyser, and Normaliser (if none were provided)
        self._setup_cores()
        
        reader = self.Reader()
        reader.replicates(self._replicates)
        if self._names is not None:
            reader.names(self._names)
        
        analyser = self.Analyser()
        normaliser = self.Normaliser()

        normalisers = []
        samples = []

        # analyse normalisers:
        for _normaliser in self._Normalisers:
            norm = reader.read(_normaliser)

            for filter in self._Filters:
                norm = filter.pipe(norm)

            norm = analyser.pipe(norm)
            normalisers.append(norm)
        normaliser.link(normalisers = normalisers)

        # analyse sample assays
        for sample in self._Assays:
            _sample = reader.read(sample)

            for filter in self._Filters:
                _sample = filter.pipe(_sample)

            _sample = analyser.pipe(_sample)
            samples.append(_sample)
        normaliser.link(samples = samples)

        normaliser.normalise()
        results = normaliser.get()

        self._Results = results
        self._df = results.get()
        self._stats_df = results.stats()

        if self._save_to is not None:
            results.save(self._save_to)

        # plot filtering report
        for filter in self._Filters:
            if self._save_to is not None or filter.report() is not None:
                # add report location if none was specified...
                if filter.report() is None: 
                    filter.report(self._save_to)

            figs = filter.plot()
            self._Figures.extend(figs)

        # plot results
        for plotter in self._Plotters:
            plotter.link(self._Results)
            fig = plotter.plot()
            self._Figures.append(fig)

            if self._save_to is not None:
                filename = self._make_figure_filename(plotter)
                plotter.save(filename)



class _Qupid_Blueprint(Blueprint):
    &#34;&#34;&#34;
    This is the implementation of the Plueprint pipeline for the Qupid webapp.
    It redefines the file-reading functions with methods compatible with the UploadedFile objects from streamlit.
    &#34;&#34;&#34;
    def __init__(self):
        super().__init__()

    def _setup_cores(self):
        &#34;&#34;&#34;
        Sets SampleReader, Analyser, and Normaliser to defaults, if no external ones were provided...
        &#34;&#34;&#34;
        if self.Reader() is None: 
            self.Reader(qpcr._Qupid_SampleReader())
        if self.Analyser() is None: 
            self.Analyser(qpcr.Analyser())
        if self.Normaliser() is None:
            self.Normaliser(qpcr.Normaliser())


if __name__ == &#34;__main__&#34;:

    norm_files = [&#34;Example Data/28S.csv&#34;, &#34;Example Data/actin.csv&#34;]
    sample_files = [&#34;Example Data/HNRNPL_nmd.csv&#34;, &#34;Example Data/HNRNPL_prot.csv&#34;]

    norm_folder = &#34;Example Data 2/normalisers&#34;
    sample_folder = &#34;Example Data 2/samples&#34;

    groupnames = [&#34;wt-&#34;, &#34;wt+&#34;, &#34;ko-&#34;, &#34;ko+&#34;]
    
    analysis = Blueprint()
    
    grouped_analyser = qpcr.Analyser()
    grouped_analyser.anchor(&#34;grouped&#34;)
    analysis.Analyser(grouped_analyser)

    analysis.save_to(&#34;Example Data 2&#34;)
    analysis.add_assays(sample_files) # alternative: link() for iteratively linking new assays...
    analysis.add_normalisers(norm_files)
    
    analysis.replicates(6)
    analysis.names(groupnames)

    iqr_filter = Filters.RangeFilter()
    # iqr_filter.report(&#34;Example Data 2&#34;)
    analysis.add_filters(iqr_filter)

    preview = Plotters.PreviewResults(mode = &#34;interactive&#34;)
    analysis.add_plotters(preview)

    # now that pipeline is ready, we can run!
    analysis.run()

    # now we can get results!
    results = analysis.get(kind=&#34;df&#34;)
    print(results)
    
    
    # norm_folder = &#34;Example Data 3/normalisers&#34;
    # exp_folder = &#34;Example Data 3/experimental/samples&#34;
    # ctr_folder = &#34;Example Data 3/experimental/samples&#34;

    # groupnames = [&#34;wt-&#34;, &#34;wt+&#34;, &#34;ko-&#34;, &#34;ko+&#34;]
    
    # analysis = BasicPlus(index = &#34;Example Data 2/index.csv&#34;)
    # analysis.save_to(&#34;Example Data &#34;)
    
    # print(analysis._index)
    # # analysis.set_experimental(assays = exp_folder, normalisers = norm_folder)
    # # analysis.set_control(assays = ctr_folder, normalisers = norm_folder)

    # # analysis.replicates(6)
    # # analysis.names(groupnames)

    # iqr_filter = Filters.RangeFilter()
    # # iqr_filter.report(&#34;Example Data 2&#34;)
    # analysis.add_filters(iqr_filter)

    # # preview = Plotters.PreviewResults(mode = &#34;interactive&#34;)
    # # analysis.add_plotters(preview)

    # # # now that pipeline is ready, we can run!
    # # analysis.run()

    # # # now we can get results!
    # # results = analysis.get(kind=&#34;df&#34;)
    # # print(results)

    # # exit(0)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="qpcr.Pipes.Basic"><code class="flex name class">
<span>class <span class="ident">Basic</span></span>
</code></dt>
<dd>
<div class="desc"><p>Performs simple standardized DeltaDeltaCt analysis
based on two lists of files, one for normalisers, one for Sample Assays&hellip;
This makes use of standard settings for qpcr.Analyser() and qpcr.Assay()
which cannot be customized! For customization generate your own pipeline!</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Basic(Pipeline):
    &#34;&#34;&#34;
    Performs simple standardized DeltaDeltaCt analysis 
    based on two lists of files, one for normalisers, one for Sample Assays...
    This makes use of standard settings for qpcr.Analyser() and qpcr.Assay()
    which cannot be customized! For customization generate your own pipeline!
    &#34;&#34;&#34;
    def __init__(self):
        super().__init__()
    
    def _run(self):
        &#34;&#34;&#34;
        The automated standard DeltaDeltaCt pipeline. 
        Using default settings of qpcr.Analyser()
        &#34;&#34;&#34;
        reader = qpcr.SampleReader()
        reader.replicates(self._replicates)
        if self._names is not None:
            reader.names(self._names)
        
        analyser = qpcr.Analyser()
        normaliser = qpcr.Normaliser()

        normalisers = []
        samples = []

        # analyse normalisers:
        for _normaliser in self._Normalisers:
            norm = reader.read(_normaliser)
            norm = analyser.pipe(norm)
            normalisers.append(norm)
        normaliser.link(normalisers = normalisers)

        # analyse sample assays
        for sample in self._Assays:
            _sample = reader.read(sample)
            _sample = analyser.pipe(_sample)
            samples.append(_sample)
        normaliser.link(samples = samples)

        normaliser.normalise()
        results = normaliser.get()

        self._Results = results
        self._df = results.get()
        self._stats_df = results.stats()

        if self._save_to is not None:
            results.save(self._save_to)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="qpcr.Pipes.Pipeline" href="#qpcr.Pipes.Pipeline">Pipeline</a></li>
<li>qpcr.__init__.SampleReader</li>
<li>qpcr.__init__.Assay</li>
<li>qpcr._auxiliary._ID</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="qpcr.Pipes.BasicPlus" href="#qpcr.Pipes.BasicPlus">BasicPlus</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="qpcr.Pipes.Pipeline" href="#qpcr.Pipes.Pipeline">Pipeline</a></b></code>:
<ul class="hlist">
<li><code><a title="qpcr.Pipes.Pipeline.add_assays" href="#qpcr.Pipes.Pipeline.add_assays">add_assays</a></code></li>
<li><code><a title="qpcr.Pipes.Pipeline.add_normalisers" href="#qpcr.Pipes.Pipeline.add_normalisers">add_normalisers</a></code></li>
<li><code><a title="qpcr.Pipes.Pipeline.get" href="#qpcr.Pipes.Pipeline.get">get</a></code></li>
<li><code><a title="qpcr.Pipes.Pipeline.link" href="#qpcr.Pipes.Pipeline.link">link</a></code></li>
<li><code><a title="qpcr.Pipes.Pipeline.prune" href="#qpcr.Pipes.Pipeline.prune">prune</a></code></li>
<li><code><a title="qpcr.Pipes.Pipeline.run" href="#qpcr.Pipes.Pipeline.run">run</a></code></li>
<li><code><a title="qpcr.Pipes.Pipeline.save_to" href="#qpcr.Pipes.Pipeline.save_to">save_to</a></code></li>
<li><code><a title="qpcr.Pipes.Pipeline.softlink" href="#qpcr.Pipes.Pipeline.softlink">softlink</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="qpcr.Pipes.BasicPlus"><code class="flex name class">
<span>class <span class="ident">BasicPlus</span></span>
</code></dt>
<dd>
<div class="desc"><p>The same as the Basic Pipeline, but has the option to integrate Plotters and Filters.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BasicPlus(Basic):
    &#34;&#34;&#34;
    The same as the Basic Pipeline, but has the option to integrate Plotters and Filters.
    &#34;&#34;&#34;
    def __init__(self):
        super().__init__()
        self._Plotters = []
        self._Figures = []
        self._Filters = []
    
    def add_plotters(self, *Plotters:object):
        &#34;&#34;&#34;
        Adds already specified qpcr.Plotter objects to the Pipeline.
        
        Parameters
        ----------
        *Plotters
            Any number of qpcr.Plotters.Plotter objects.
        &#34;&#34;&#34;
        self._Plotters.extend(Plotters)
    
    def add_filters(self, *Filters:object):
        &#34;&#34;&#34;
        Adds already specified qpcr.Filter instances to the Pipeline.
        
        Parameters
        ----------
        *Filters
            Any number of `qpcr.Filters.Filter` objects.
        &#34;&#34;&#34;
        self._Filters.extend(Filters)

    def Figures(self):
        &#34;&#34;&#34;
        Returns
        -------
        list
            A list of all Figures generated by the pipeline&#39;s Plotters.
        &#34;&#34;&#34;
        return self._Figures

    def _run(self):
        &#34;&#34;&#34;
        The automated standard DeltaDeltaCt pipeline. 
        Also produces applies and Plotters to produce figures...
        &#34;&#34;&#34;

        reader = qpcr.SampleReader()
        reader.replicates(self._replicates)
        if self._names is not None:
            reader.names(self._names)
        
        analyser = qpcr.Analyser()
        normaliser = qpcr.Normaliser()

        normalisers = []
        samples = []

        # analyse normalisers:
        for _normaliser in self._Normalisers:
            norm = reader.read(_normaliser)

            for filter in self._Filters:
                norm = filter.pipe(norm)

            norm = analyser.pipe(norm)
            normalisers.append(norm)
        normaliser.link(normalisers = normalisers)

        # analyse sample assays
        for sample in self._Assays:
            _sample = reader.read(sample)

            for filter in self._Filters:
                _sample = filter.pipe(_sample)

            _sample = analyser.pipe(_sample)
            samples.append(_sample)
        normaliser.link(samples = samples)

        normaliser.normalise()
        results = normaliser.get()

        self._Results = results
        self._df = results.get()
        self._stats_df = results.stats()

        if self._save_to is not None:
            results.save(self._save_to)

        # plot filtering report
        for filter in self._Filters:
            if self._save_to is not None or filter.report() is not None:
                # add report location if none was specified...
                if filter.report() is None: 
                    filter.report(self._save_to)

            figs = filter.plot()
            self._Figures.extend(figs)

        # plot results
        for plotter in self._Plotters:
            plotter.link(self._Results)
            fig = plotter.plot()
            self._Figures.append(fig)

            if self._save_to is not None:
                filename = self._make_figure_filename(plotter)
                plotter.save(filename)

    def _make_figure_filename(self, plotter):
        &#34;&#34;&#34;
        Increments a filename with a numeric counter...
        &#34;&#34;&#34;
        num = 1
        suffix = plotter.suffix()
        while True:
            filename = os.path.join(self._save_to, f&#34;{plotter.id()}_{num}.{suffix}&#34;)
            if not os.path.exists(filename):
                break
            num+=1
        return filename</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="qpcr.Pipes.Basic" href="#qpcr.Pipes.Basic">Basic</a></li>
<li><a title="qpcr.Pipes.Pipeline" href="#qpcr.Pipes.Pipeline">Pipeline</a></li>
<li>qpcr.__init__.SampleReader</li>
<li>qpcr.__init__.Assay</li>
<li>qpcr._auxiliary._ID</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="qpcr.Pipes.Blueprint" href="#qpcr.Pipes.Blueprint">Blueprint</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="qpcr.Pipes.BasicPlus.Figures"><code class="name flex">
<span>def <span class="ident">Figures</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>A list of all Figures generated by the pipeline's Plotters.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Figures(self):
    &#34;&#34;&#34;
    Returns
    -------
    list
        A list of all Figures generated by the pipeline&#39;s Plotters.
    &#34;&#34;&#34;
    return self._Figures</code></pre>
</details>
</dd>
<dt id="qpcr.Pipes.BasicPlus.add_filters"><code class="name flex">
<span>def <span class="ident">add_filters</span></span>(<span>self, *Filters: object)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds already specified qpcr.Filter instances to the Pipeline.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>*Filters</code></strong></dt>
<dd>Any number of <code><a title="qpcr.Filters.Filter" href="Filters.html#qpcr.Filters.Filter">Filter</a></code> objects.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_filters(self, *Filters:object):
    &#34;&#34;&#34;
    Adds already specified qpcr.Filter instances to the Pipeline.
    
    Parameters
    ----------
    *Filters
        Any number of `qpcr.Filters.Filter` objects.
    &#34;&#34;&#34;
    self._Filters.extend(Filters)</code></pre>
</details>
</dd>
<dt id="qpcr.Pipes.BasicPlus.add_plotters"><code class="name flex">
<span>def <span class="ident">add_plotters</span></span>(<span>self, *Plotters: object)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds already specified qpcr.Plotter objects to the Pipeline.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>*Plotters</code></strong></dt>
<dd>Any number of qpcr.Plotters.Plotter objects.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_plotters(self, *Plotters:object):
    &#34;&#34;&#34;
    Adds already specified qpcr.Plotter objects to the Pipeline.
    
    Parameters
    ----------
    *Plotters
        Any number of qpcr.Plotters.Plotter objects.
    &#34;&#34;&#34;
    self._Plotters.extend(Plotters)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="qpcr.Pipes.Basic" href="#qpcr.Pipes.Basic">Basic</a></b></code>:
<ul class="hlist">
<li><code><a title="qpcr.Pipes.Basic.add_assays" href="#qpcr.Pipes.Pipeline.add_assays">add_assays</a></code></li>
<li><code><a title="qpcr.Pipes.Basic.add_normalisers" href="#qpcr.Pipes.Pipeline.add_normalisers">add_normalisers</a></code></li>
<li><code><a title="qpcr.Pipes.Basic.get" href="#qpcr.Pipes.Pipeline.get">get</a></code></li>
<li><code><a title="qpcr.Pipes.Basic.link" href="#qpcr.Pipes.Pipeline.link">link</a></code></li>
<li><code><a title="qpcr.Pipes.Basic.prune" href="#qpcr.Pipes.Pipeline.prune">prune</a></code></li>
<li><code><a title="qpcr.Pipes.Basic.run" href="#qpcr.Pipes.Pipeline.run">run</a></code></li>
<li><code><a title="qpcr.Pipes.Basic.save_to" href="#qpcr.Pipes.Pipeline.save_to">save_to</a></code></li>
<li><code><a title="qpcr.Pipes.Basic.softlink" href="#qpcr.Pipes.Pipeline.softlink">softlink</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="qpcr.Pipes.Blueprint"><code class="flex name class">
<span>class <span class="ident">Blueprint</span></span>
</code></dt>
<dd>
<div class="desc"><p>Performs simple Delta-Delta-Ct analysis based on the same workflow as the <code><a title="qpcr.Pipes.Basic" href="#qpcr.Pipes.Basic">Basic</a></code> pipeline, but allows full costumization of SampleReader, Analyser, and Normaliser objects.
Optionally, SampleReader, Analyser, and Normaliser may be set up externally and linked into the pipeline. Any non-linked processing classes will be set up as per default.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Blueprint(BasicPlus):
    &#34;&#34;&#34;
    Performs simple Delta-Delta-Ct analysis based on the same workflow as the `Basic` pipeline, but allows full costumization of SampleReader, Analyser, and Normaliser objects.
    Optionally, SampleReader, Analyser, and Normaliser may be set up externally and linked into the pipeline. Any non-linked processing classes will be set up as per default.
    &#34;&#34;&#34;
    def __init__(self):
        super().__init__()
        self._Reader = None
        self._Analyser = None
        self._Normaliser = None

    def Reader(self, Reader : qpcr.SampleReader = None):
        &#34;&#34;&#34;
        Links a `qpcr.SampleReader` object to the pipeline.

        Parameters
        ----------
        Reader : qpcr.SampleReader
            A `qpcr.SampleReader` object
        &#34;&#34;&#34;
        if Reader is not None: 
            self._Reader = Reader
        return self._Reader

    def Analyser(self, Analyser : qpcr.Analyser = None):
        &#34;&#34;&#34;
        Links a `qpcr.Analyser` object to the pipeline.

        Parameters
        ----------
        Analyser : qpcr.Analyser
            A `qpcr.Analyser` object
        &#34;&#34;&#34;
        if Analyser is not None:
            self._Analyser = Analyser
        return self._Analyser

    def Normaliser(self, Normaliser : qpcr.Normaliser = None):
        &#34;&#34;&#34;
        Links a `qpcr.Normaliser` object to the pipeline.

        Parameters
        ----------
        Normaliser : qpcr.Normaliser
            A `qpcr.Normaliser` object
        &#34;&#34;&#34;
        if Normaliser is not None:
            self._Normaliser = Normaliser
        return self._Normaliser
    
    def _setup_cores(self):
        &#34;&#34;&#34;
        Sets SampleReader, Analyser, and Normaliser to defaults, if no external ones were provided...
        &#34;&#34;&#34;
        if self.Reader() is None: 
            self.Reader(qpcr.SampleReader())
        if self.Analyser() is None: 
            self.Analyser(qpcr.Analyser())
        if self.Normaliser() is None:
            self.Normaliser(qpcr.Normaliser())

    def _run(self):
        &#34;&#34;&#34;
        The automated standard DeltaDeltaCt pipeline. 
        Also produces applies and Plotters to produce figures...
        &#34;&#34;&#34;
        # setup SampleReader, Analyser, and Normaliser (if none were provided)
        self._setup_cores()
        
        reader = self.Reader()
        reader.replicates(self._replicates)
        if self._names is not None:
            reader.names(self._names)
        
        analyser = self.Analyser()
        normaliser = self.Normaliser()

        normalisers = []
        samples = []

        # analyse normalisers:
        for _normaliser in self._Normalisers:
            norm = reader.read(_normaliser)

            for filter in self._Filters:
                norm = filter.pipe(norm)

            norm = analyser.pipe(norm)
            normalisers.append(norm)
        normaliser.link(normalisers = normalisers)

        # analyse sample assays
        for sample in self._Assays:
            _sample = reader.read(sample)

            for filter in self._Filters:
                _sample = filter.pipe(_sample)

            _sample = analyser.pipe(_sample)
            samples.append(_sample)
        normaliser.link(samples = samples)

        normaliser.normalise()
        results = normaliser.get()

        self._Results = results
        self._df = results.get()
        self._stats_df = results.stats()

        if self._save_to is not None:
            results.save(self._save_to)

        # plot filtering report
        for filter in self._Filters:
            if self._save_to is not None or filter.report() is not None:
                # add report location if none was specified...
                if filter.report() is None: 
                    filter.report(self._save_to)

            figs = filter.plot()
            self._Figures.extend(figs)

        # plot results
        for plotter in self._Plotters:
            plotter.link(self._Results)
            fig = plotter.plot()
            self._Figures.append(fig)

            if self._save_to is not None:
                filename = self._make_figure_filename(plotter)
                plotter.save(filename)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="qpcr.Pipes.BasicPlus" href="#qpcr.Pipes.BasicPlus">BasicPlus</a></li>
<li><a title="qpcr.Pipes.Basic" href="#qpcr.Pipes.Basic">Basic</a></li>
<li><a title="qpcr.Pipes.Pipeline" href="#qpcr.Pipes.Pipeline">Pipeline</a></li>
<li>qpcr.__init__.SampleReader</li>
<li>qpcr.__init__.Assay</li>
<li>qpcr._auxiliary._ID</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>qpcr.Pipes._Qupid_Blueprint</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="qpcr.Pipes.Blueprint.Analyser"><code class="name flex">
<span>def <span class="ident">Analyser</span></span>(<span>self, Analyser: qpcr.__init__.Analyser = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Links a <code><a title="qpcr.Analyser" href="index.html#qpcr.Analyser">Analyser</a></code> object to the pipeline.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>Analyser</code></strong> :&ensp;<code><a title="qpcr.Analyser" href="index.html#qpcr.Analyser">Analyser</a></code></dt>
<dd>A <code><a title="qpcr.Analyser" href="index.html#qpcr.Analyser">Analyser</a></code> object</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Analyser(self, Analyser : qpcr.Analyser = None):
    &#34;&#34;&#34;
    Links a `qpcr.Analyser` object to the pipeline.

    Parameters
    ----------
    Analyser : qpcr.Analyser
        A `qpcr.Analyser` object
    &#34;&#34;&#34;
    if Analyser is not None:
        self._Analyser = Analyser
    return self._Analyser</code></pre>
</details>
</dd>
<dt id="qpcr.Pipes.Blueprint.Normaliser"><code class="name flex">
<span>def <span class="ident">Normaliser</span></span>(<span>self, Normaliser: qpcr.__init__.Normaliser = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Links a <code><a title="qpcr.Normaliser" href="index.html#qpcr.Normaliser">Normaliser</a></code> object to the pipeline.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>Normaliser</code></strong> :&ensp;<code><a title="qpcr.Normaliser" href="index.html#qpcr.Normaliser">Normaliser</a></code></dt>
<dd>A <code><a title="qpcr.Normaliser" href="index.html#qpcr.Normaliser">Normaliser</a></code> object</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Normaliser(self, Normaliser : qpcr.Normaliser = None):
    &#34;&#34;&#34;
    Links a `qpcr.Normaliser` object to the pipeline.

    Parameters
    ----------
    Normaliser : qpcr.Normaliser
        A `qpcr.Normaliser` object
    &#34;&#34;&#34;
    if Normaliser is not None:
        self._Normaliser = Normaliser
    return self._Normaliser</code></pre>
</details>
</dd>
<dt id="qpcr.Pipes.Blueprint.Reader"><code class="name flex">
<span>def <span class="ident">Reader</span></span>(<span>self, Reader: qpcr.__init__.SampleReader = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Links a <code><a title="qpcr.SampleReader" href="index.html#qpcr.SampleReader">SampleReader</a></code> object to the pipeline.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>Reader</code></strong> :&ensp;<code><a title="qpcr.SampleReader" href="index.html#qpcr.SampleReader">SampleReader</a></code></dt>
<dd>A <code><a title="qpcr.SampleReader" href="index.html#qpcr.SampleReader">SampleReader</a></code> object</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Reader(self, Reader : qpcr.SampleReader = None):
    &#34;&#34;&#34;
    Links a `qpcr.SampleReader` object to the pipeline.

    Parameters
    ----------
    Reader : qpcr.SampleReader
        A `qpcr.SampleReader` object
    &#34;&#34;&#34;
    if Reader is not None: 
        self._Reader = Reader
    return self._Reader</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="qpcr.Pipes.BasicPlus" href="#qpcr.Pipes.BasicPlus">BasicPlus</a></b></code>:
<ul class="hlist">
<li><code><a title="qpcr.Pipes.BasicPlus.Figures" href="#qpcr.Pipes.BasicPlus.Figures">Figures</a></code></li>
<li><code><a title="qpcr.Pipes.BasicPlus.add_assays" href="#qpcr.Pipes.Pipeline.add_assays">add_assays</a></code></li>
<li><code><a title="qpcr.Pipes.BasicPlus.add_filters" href="#qpcr.Pipes.BasicPlus.add_filters">add_filters</a></code></li>
<li><code><a title="qpcr.Pipes.BasicPlus.add_normalisers" href="#qpcr.Pipes.Pipeline.add_normalisers">add_normalisers</a></code></li>
<li><code><a title="qpcr.Pipes.BasicPlus.add_plotters" href="#qpcr.Pipes.BasicPlus.add_plotters">add_plotters</a></code></li>
<li><code><a title="qpcr.Pipes.BasicPlus.get" href="#qpcr.Pipes.Pipeline.get">get</a></code></li>
<li><code><a title="qpcr.Pipes.BasicPlus.link" href="#qpcr.Pipes.Pipeline.link">link</a></code></li>
<li><code><a title="qpcr.Pipes.BasicPlus.prune" href="#qpcr.Pipes.Pipeline.prune">prune</a></code></li>
<li><code><a title="qpcr.Pipes.BasicPlus.run" href="#qpcr.Pipes.Pipeline.run">run</a></code></li>
<li><code><a title="qpcr.Pipes.BasicPlus.save_to" href="#qpcr.Pipes.Pipeline.save_to">save_to</a></code></li>
<li><code><a title="qpcr.Pipes.BasicPlus.softlink" href="#qpcr.Pipes.Pipeline.softlink">softlink</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="qpcr.Pipes.Pipeline"><code class="flex name class">
<span>class <span class="ident">Pipeline</span></span>
</code></dt>
<dd>
<div class="desc"><p>This is the basic template class for qpcr Pipelines.
It contains a set of basic preliminary methods
that ensure that elementary required inputs are provided.</p>
<h2 id="note">Note</h2>
<p>The simplest implementation of this <code><a title="qpcr.Pipes.Pipeline" href="#qpcr.Pipes.Pipeline">Pipeline</a></code> template is the <code><a title="qpcr.Pipes.Basic" href="#qpcr.Pipes.Basic">Basic</a></code> pipeline.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Pipeline(qpcr.SampleReader):
    &#34;&#34;&#34;
    This is the basic template class for qpcr Pipelines. 
    It contains a set of basic preliminary methods
    that ensure that elementary required inputs are provided.

    Note
    ----
    The simplest implementation of this `Pipeline` template is the `Basic` pipeline.
    &#34;&#34;&#34;
    def __init__(self):
        super().__init__()
        self._Normalisers = []
        self._Assays = []
        self._save_to = None
        self._df = None
        self._stats_df = None
        self._Results = None
        self._replicates = None
        self._names = None
        self._softlink = True

    def run(self, **kwargs):
        &#34;&#34;&#34;
        Will run the pipeline provided that at least minimal inputs have been provided (i.e. Assays and Normalisers, as well as replicate specifics have been provided).
        This is a wrapper, the actual functional core is defined in the method `self._run()`. 
        To implement your own pipeline, make sure to define your own `_run()`, redefine `run()`
        as you require.

        Parameters
        ----------
        **kwargs
            Any additional keyword arguments that will be passed to the actual `_run()` method.
        &#34;&#34;&#34;
        if self._replicates is None:
            wa.HardWarning(&#34;Pipeline:no_reps&#34;)
        elif self._Normalisers == [] or self._Assays == []:
            wa.HardWarning(&#34;Pipeline:no_data&#34;)

        self._run(**kwargs)
    
    def save_to(self, directory:str):
        &#34;&#34;&#34;
        Set the location where to save result files

        Parameters
        ----------
        directory : str
            A directory to save the results to.
        &#34;&#34;&#34;
        self._save_to = directory
        # if the directory does not yet exist, we make it
        if not os.path.exists(self._save_to):
            os.mkdir(self._save_to)

    def get(self, kind=&#34;stats&#34;):
        &#34;&#34;&#34;
        Returns
        -------
        data 
            A pandas dataframe either in replicate version `kind=&#34;df&#34;`
            or in stats version `kind=&#34;stats&#34;` (default). Alternatively,
            a qpcr.Results object can be returned using `kind=&#34;obj&#34;`.
        &#34;&#34;&#34;
        if kind == &#34;stats&#34;:
            return self._stats_df
        elif kind == &#34;df&#34;:
            df = self._df
            df = df.drop(columns = [&#34;assay&#34;])
            return df
        elif kind == &#34;obj&#34;:
            return self._Results
    
    def link(self, samples:(list or str)):
        &#34;&#34;&#34;
        Links new sample assays to the pipline, either replacing old ones or keeping them, 
        depending on `softlink()` settings.

        Parameters
        ----------
        samples : list or str
            A `list` of filepaths to raw datafiles of sample assays, or a directory (`str`) where these are stored.
        &#34;&#34;&#34;
        if self._softlink:
            self.prune()
        self.add_assays(samples)

    def prune(self, assays = True, results = True, normalisers = False):
        &#34;&#34;&#34;
        Will clear assays, results, and/or normalisers

        Parameters
        ----------
        assays : bool
            Will clear any sample assays in the pipeline if True (default).
        
        results : bool
            Will clear any computed results in the pipline if True (default).
        
        normalisers : bool
            Will clear any normalisers in the pipline if True (default is False).
        &#34;&#34;&#34;
        if assays: self._Assays = []
        if normalisers: self._Normalisers = []
        if results: 
            self._df = None
            self._stats_df = None
            self._Results = None

    def add_normalisers(self, normalisers):
        &#34;&#34;&#34;
        Adds normalisers (filepaths) (keeping any already present)
        
        Parameters
        ----------
        normalisers : list or str
            A `list` of filepaths to raw datafiles of normaliser assays, or a directory (`str`) where these are stored.
        &#34;&#34;&#34;
        normalisers = self._from_directory(normalisers)
        self._Normalisers.extend(normalisers)
    
    def add_assays(self, samples):
        &#34;&#34;&#34;
        Adds sample assays (filepaths) (keeping any already present)

        Parameters
        ----------
        samples : list or str
            A `list` of filepaths to raw datafiles of sample assays, or a directory (`str`) where these are stored.
        &#34;&#34;&#34;
        samples = self._from_directory(samples)
        self._Assays.extend(samples)

    def softlink(self, bool = None):
        &#34;&#34;&#34;
        If `softlink = True`, then `link_assays()` will 
        prune any previous assays. Otherwise, it will 
        add new ones and keep old ones.

        Parameters
        ----------
        bool
            Set to False to disable `softlinking` (default is True).
        &#34;&#34;&#34;
        if bool is None:
            return self._softlink
        else:
            self._softlink = bool

    def _from_directory(self, files):
        &#34;&#34;&#34;
        Checks if a directory was provided for assays / normalisers and returns a list of all contained files if so.
        Otherwise it just returns the list of files.
        This is used for add_assays and add_normalisers
        &#34;&#34;&#34;
        if isinstance(files, str):
            if os.path.isdir(files):
                norms = os.listdir(files)
                norms = [os.path.join(files,n) for n in norms]
                return norms
        else:
            return files

    def _run(self, **kwargs):
        &#34;&#34;&#34;
        This is the actual function that each custom Pipeline has to define...
        &#34;&#34;&#34;
        print(&#34;self._run() is the actual function that each custom Pipeline has to define...&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>qpcr.__init__.SampleReader</li>
<li>qpcr.__init__.Assay</li>
<li>qpcr._auxiliary._ID</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="qpcr.Pipes.Basic" href="#qpcr.Pipes.Basic">Basic</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="qpcr.Pipes.Pipeline.add_assays"><code class="name flex">
<span>def <span class="ident">add_assays</span></span>(<span>self, samples)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds sample assays (filepaths) (keeping any already present)</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>samples</code></strong> :&ensp;<code>list</code> or <code>str</code></dt>
<dd>A <code>list</code> of filepaths to raw datafiles of sample assays, or a directory (<code>str</code>) where these are stored.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_assays(self, samples):
    &#34;&#34;&#34;
    Adds sample assays (filepaths) (keeping any already present)

    Parameters
    ----------
    samples : list or str
        A `list` of filepaths to raw datafiles of sample assays, or a directory (`str`) where these are stored.
    &#34;&#34;&#34;
    samples = self._from_directory(samples)
    self._Assays.extend(samples)</code></pre>
</details>
</dd>
<dt id="qpcr.Pipes.Pipeline.add_normalisers"><code class="name flex">
<span>def <span class="ident">add_normalisers</span></span>(<span>self, normalisers)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds normalisers (filepaths) (keeping any already present)</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>normalisers</code></strong> :&ensp;<code>list</code> or <code>str</code></dt>
<dd>A <code>list</code> of filepaths to raw datafiles of normaliser assays, or a directory (<code>str</code>) where these are stored.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_normalisers(self, normalisers):
    &#34;&#34;&#34;
    Adds normalisers (filepaths) (keeping any already present)
    
    Parameters
    ----------
    normalisers : list or str
        A `list` of filepaths to raw datafiles of normaliser assays, or a directory (`str`) where these are stored.
    &#34;&#34;&#34;
    normalisers = self._from_directory(normalisers)
    self._Normalisers.extend(normalisers)</code></pre>
</details>
</dd>
<dt id="qpcr.Pipes.Pipeline.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, kind='stats')</span>
</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<dl>
<dt><code>data </code></dt>
<dd>A pandas dataframe either in replicate version <code>kind="df"</code>
or in stats version <code>kind="stats"</code> (default). Alternatively,
a qpcr.Results object can be returned using <code>kind="obj"</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(self, kind=&#34;stats&#34;):
    &#34;&#34;&#34;
    Returns
    -------
    data 
        A pandas dataframe either in replicate version `kind=&#34;df&#34;`
        or in stats version `kind=&#34;stats&#34;` (default). Alternatively,
        a qpcr.Results object can be returned using `kind=&#34;obj&#34;`.
    &#34;&#34;&#34;
    if kind == &#34;stats&#34;:
        return self._stats_df
    elif kind == &#34;df&#34;:
        df = self._df
        df = df.drop(columns = [&#34;assay&#34;])
        return df
    elif kind == &#34;obj&#34;:
        return self._Results</code></pre>
</details>
</dd>
<dt id="qpcr.Pipes.Pipeline.link"><code class="name flex">
<span>def <span class="ident">link</span></span>(<span>self, samples: list)</span>
</code></dt>
<dd>
<div class="desc"><p>Links new sample assays to the pipline, either replacing old ones or keeping them,
depending on <code>softlink()</code> settings.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>samples</code></strong> :&ensp;<code>list</code> or <code>str</code></dt>
<dd>A <code>list</code> of filepaths to raw datafiles of sample assays, or a directory (<code>str</code>) where these are stored.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def link(self, samples:(list or str)):
    &#34;&#34;&#34;
    Links new sample assays to the pipline, either replacing old ones or keeping them, 
    depending on `softlink()` settings.

    Parameters
    ----------
    samples : list or str
        A `list` of filepaths to raw datafiles of sample assays, or a directory (`str`) where these are stored.
    &#34;&#34;&#34;
    if self._softlink:
        self.prune()
    self.add_assays(samples)</code></pre>
</details>
</dd>
<dt id="qpcr.Pipes.Pipeline.prune"><code class="name flex">
<span>def <span class="ident">prune</span></span>(<span>self, assays=True, results=True, normalisers=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Will clear assays, results, and/or normalisers</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>assays</code></strong> :&ensp;<code>bool</code></dt>
<dd>Will clear any sample assays in the pipeline if True (default).</dd>
<dt><strong><code>results</code></strong> :&ensp;<code>bool</code></dt>
<dd>Will clear any computed results in the pipline if True (default).</dd>
<dt><strong><code>normalisers</code></strong> :&ensp;<code>bool</code></dt>
<dd>Will clear any normalisers in the pipline if True (default is False).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prune(self, assays = True, results = True, normalisers = False):
    &#34;&#34;&#34;
    Will clear assays, results, and/or normalisers

    Parameters
    ----------
    assays : bool
        Will clear any sample assays in the pipeline if True (default).
    
    results : bool
        Will clear any computed results in the pipline if True (default).
    
    normalisers : bool
        Will clear any normalisers in the pipline if True (default is False).
    &#34;&#34;&#34;
    if assays: self._Assays = []
    if normalisers: self._Normalisers = []
    if results: 
        self._df = None
        self._stats_df = None
        self._Results = None</code></pre>
</details>
</dd>
<dt id="qpcr.Pipes.Pipeline.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Will run the pipeline provided that at least minimal inputs have been provided (i.e. Assays and Normalisers, as well as replicate specifics have been provided).
This is a wrapper, the actual functional core is defined in the method <code>self._run()</code>.
To implement your own pipeline, make sure to define your own <code>_run()</code>, redefine <code>run()</code>
as you require.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Any additional keyword arguments that will be passed to the actual <code>_run()</code> method.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self, **kwargs):
    &#34;&#34;&#34;
    Will run the pipeline provided that at least minimal inputs have been provided (i.e. Assays and Normalisers, as well as replicate specifics have been provided).
    This is a wrapper, the actual functional core is defined in the method `self._run()`. 
    To implement your own pipeline, make sure to define your own `_run()`, redefine `run()`
    as you require.

    Parameters
    ----------
    **kwargs
        Any additional keyword arguments that will be passed to the actual `_run()` method.
    &#34;&#34;&#34;
    if self._replicates is None:
        wa.HardWarning(&#34;Pipeline:no_reps&#34;)
    elif self._Normalisers == [] or self._Assays == []:
        wa.HardWarning(&#34;Pipeline:no_data&#34;)

    self._run(**kwargs)</code></pre>
</details>
</dd>
<dt id="qpcr.Pipes.Pipeline.save_to"><code class="name flex">
<span>def <span class="ident">save_to</span></span>(<span>self, directory: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the location where to save result files</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>directory</code></strong> :&ensp;<code>str</code></dt>
<dd>A directory to save the results to.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_to(self, directory:str):
    &#34;&#34;&#34;
    Set the location where to save result files

    Parameters
    ----------
    directory : str
        A directory to save the results to.
    &#34;&#34;&#34;
    self._save_to = directory
    # if the directory does not yet exist, we make it
    if not os.path.exists(self._save_to):
        os.mkdir(self._save_to)</code></pre>
</details>
</dd>
<dt id="qpcr.Pipes.Pipeline.softlink"><code class="name flex">
<span>def <span class="ident">softlink</span></span>(<span>self, bool=None)</span>
</code></dt>
<dd>
<div class="desc"><p>If <code>softlink = True</code>, then <code>link_assays()</code> will
prune any previous assays. Otherwise, it will
add new ones and keep old ones.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>bool</code></strong></dt>
<dd>Set to False to disable <code>softlinking</code> (default is True).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def softlink(self, bool = None):
    &#34;&#34;&#34;
    If `softlink = True`, then `link_assays()` will 
    prune any previous assays. Otherwise, it will 
    add new ones and keep old ones.

    Parameters
    ----------
    bool
        Set to False to disable `softlinking` (default is True).
    &#34;&#34;&#34;
    if bool is None:
        return self._softlink
    else:
        self._softlink = bool</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="qpcr" href="index.html">qpcr</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="qpcr.Pipes.Basic" href="#qpcr.Pipes.Basic">Basic</a></code></h4>
</li>
<li>
<h4><code><a title="qpcr.Pipes.BasicPlus" href="#qpcr.Pipes.BasicPlus">BasicPlus</a></code></h4>
<ul class="">
<li><code><a title="qpcr.Pipes.BasicPlus.Figures" href="#qpcr.Pipes.BasicPlus.Figures">Figures</a></code></li>
<li><code><a title="qpcr.Pipes.BasicPlus.add_filters" href="#qpcr.Pipes.BasicPlus.add_filters">add_filters</a></code></li>
<li><code><a title="qpcr.Pipes.BasicPlus.add_plotters" href="#qpcr.Pipes.BasicPlus.add_plotters">add_plotters</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="qpcr.Pipes.Blueprint" href="#qpcr.Pipes.Blueprint">Blueprint</a></code></h4>
<ul class="">
<li><code><a title="qpcr.Pipes.Blueprint.Analyser" href="#qpcr.Pipes.Blueprint.Analyser">Analyser</a></code></li>
<li><code><a title="qpcr.Pipes.Blueprint.Normaliser" href="#qpcr.Pipes.Blueprint.Normaliser">Normaliser</a></code></li>
<li><code><a title="qpcr.Pipes.Blueprint.Reader" href="#qpcr.Pipes.Blueprint.Reader">Reader</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="qpcr.Pipes.Pipeline" href="#qpcr.Pipes.Pipeline">Pipeline</a></code></h4>
<ul class="two-column">
<li><code><a title="qpcr.Pipes.Pipeline.add_assays" href="#qpcr.Pipes.Pipeline.add_assays">add_assays</a></code></li>
<li><code><a title="qpcr.Pipes.Pipeline.add_normalisers" href="#qpcr.Pipes.Pipeline.add_normalisers">add_normalisers</a></code></li>
<li><code><a title="qpcr.Pipes.Pipeline.get" href="#qpcr.Pipes.Pipeline.get">get</a></code></li>
<li><code><a title="qpcr.Pipes.Pipeline.link" href="#qpcr.Pipes.Pipeline.link">link</a></code></li>
<li><code><a title="qpcr.Pipes.Pipeline.prune" href="#qpcr.Pipes.Pipeline.prune">prune</a></code></li>
<li><code><a title="qpcr.Pipes.Pipeline.run" href="#qpcr.Pipes.Pipeline.run">run</a></code></li>
<li><code><a title="qpcr.Pipes.Pipeline.save_to" href="#qpcr.Pipes.Pipeline.save_to">save_to</a></code></li>
<li><code><a title="qpcr.Pipes.Pipeline.softlink" href="#qpcr.Pipes.Pipeline.softlink">softlink</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>