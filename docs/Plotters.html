<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>qpcr.Plotters API documentation</title>
<meta name="description" content="This module is designed for streamlined data visualisation of the qpcr generated results
It is designed to work directly with qpcr.Results() instances." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>qpcr.Plotters</code></h1>
</header>
<section id="section-intro">
<p>This module is designed for streamlined data visualisation of the qpcr generated results
It is designed to work directly with qpcr.Results() instances.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This module is designed for streamlined data visualisation of the qpcr generated results
It is designed to work directly with qpcr.Results() instances. 
&#34;&#34;&#34;

import qpcr.__init__ as qpcr
import qpcr.Pipes
import qpcr._auxiliary.graphical as gx
import qpcr._auxiliary as aux 
import qpcr._auxiliary.warnings as wa
import pandas as pd 
import matplotlib.pyplot as plt
import plotly.graph_objs as go
from plotly.subplots import make_subplots
import plotly
import seaborn as sns 

# setup some default settings for charts

_default_static_PreviewResults = dict(
                                        color = &#34;Lightgray&#34;,
                                        rot = 0,
                                        legend = False, 
                                        frame = False,
                                        title = &#34;Preview of Results&#34;
                                    )

_default_interactive_PreviewResults = dict(
                                            template = &#34;plotly_white&#34;,
                                            title = &#34;Preview of Results&#34;
                                        )


_default_static_ReplicateBoxPlot = dict(
                                        title = &#34;Summary of Replicates&#34;,
                                        linewidth = 0.8,
                                        frame = False,
                                        palette = &#34;Blues&#34;
                                    )

_default_interactive_ReplicateBoxPlot = dict(
                                            template = &#34;plotly_white&#34;,
                                            title = &#34;Summary of Replicates&#34;
                                        )


# Concept: 
# Plotter: 
#       We define a superclass Plotter that will handle linking to data, 
#       linking to default parameters, and setting up default parameters.
#       It also provides a generic plot() method that will call on a FigureClass specific _plot() method...
#       Wether or not to use static or interactive plots is also handled by this class...
#
# FigureClass:
#       A parent class for each type of figure. It contains two potential _plot() 
#       methods, one for interactive one for static plotting... Which one to use is decided based on the plotting mode...
#       Each FigureClass has therefore to link default parameters, then init Plotter (superclass), 
#       and define their own _static_plot() and _interactive_plot() methods! Any additionally required methods can be written as well...


class Plotter:
    &#34;&#34;&#34;
    A superclass that handles Data Linking and Parameter setup for FigureClasses
    (not for End-User usage)
    Parameters
    ----------
    mode : str
        The plotting mode. May be either &#34;static&#34; (matplotlib) or &#34;interactive&#34; (plotly).
    &#34;&#34;&#34;
    def __init__(self, mode = None):
        self._default_params = None
        self._PARAMS = {} #: _PARAMS will store the plotting parameter kwargs from both _default_params and any additional user specified parameters
        self._Results = None
        self._data = None
        self._id = type(self).__name__
        self._MODE = &#34;interactive&#34; if mode is None else mode
        self._fig = None
        self._set_plot()

    def link(self, Results:(qpcr.Results or pd.DataFrame)):
        &#34;&#34;&#34;
        Links a Results object or pandas DataFrame of the same architecture
        as one handled by a Results object to the Plotter. 
        Note, that this will replace any previously linked data!

        Parameters
        ----------
        Results : qpcr.Results or pd.DataFrame
            A qpcr.Results Object or a pandas DataFrame of the same architecture.
        &#34;&#34;&#34;

        if type(Results).__name__ == type(qpcr.Results()).__name__:
            self._Results = Results
            self._data = self._Results.stats()
        elif isinstance(Results, pd.DataFrame):
            self._Results = None
            self._data = Results
        else:
            wa.HardWarning(&#34;Plotter:unknown_data&#34;, obj = Results)

    def plot(self, **kwargs):
        &#34;&#34;&#34;
        Generate Figure

        Parameters
        ----------
        **kwargs
            Any arbitrary keyword arguments to be passed to the plotting method
        
        Returns
        -------
        fig
            A figure object, either from matplotlib or plotly
        &#34;&#34;&#34;
        total_kwargs = self.update_params(kwargs)
        fig = self._plot(**total_kwargs)
        self._fig = fig
        return fig

    def id(self, id:str = None):
        &#34;&#34;&#34;
        Set a unique Id, by default the Classname will be used.

        Parameters
        ----------
        id : str
            A unique identifier for the Plotter object
        
        Returns
        -------
        id 
            The Plotter Id (if no id keyword was entered)
        &#34;&#34;&#34;
        if id is not None:
            self._id = id
        else:
            return self._id

    def get(self):
        &#34;&#34;&#34;
        Returns the DataFrame used for plotting

        Returns
        -------
        data
            A pandas DataFrame containing the data underlying the plot.
        &#34;&#34;&#34;
        return self._data

    def params(self, **params):
        &#34;&#34;&#34;
        Set default parameters for plotting (will be forwarded to **kwargs)
        Returns default parameters if no new parameters are added.

        Parameters
        ----------
        **params
            Any arbitrary keyword arguments to be passed on to the pre-set plotting kwargs.
            This will either set the default parameters (if none has been specified up to the function call)
            or will update the parameters. In case of keyword duplications any OLD key : value pairs will be 
            OVERWRITTEN by new ones. 
        
        Returns
        -------
        params : dict
            A dictionary of the new pre-set plotting parameters
        &#34;&#34;&#34;
        if params != {} and self._PARAMS == {}:
            self._PARAMS = params
        elif params != {}:
            self.update_params(params, store = True)
        return self._PARAMS

    def update_params(self, kwargs, supersede = True, store = False):
        &#34;&#34;&#34;
        Appends pre-set parameters to kwargs. 
        
        Parameters
        ----------
        kwargs : dict
            A dictionary of arbitrary keywords for plotting 
        supersede : bool 
            In case of key duplications: Old values will be replaced with new ones (if supersede = True, default), 
            or keep old ones (supersede = False).
        store : bool
            The newly set plotting parameter dictionary will be stored by the plotting object as new default (if store = True, default is False).
        
        Returns
        -------
        params : dict
            A dictionary of updated plotting parameters
        &#34;&#34;&#34;
        if supersede:
            kwargs = dict(self._PARAMS, **kwargs)
        else:
            kwargs = kwargs = dict(kwargs, **self._PARAMS)
        
        if store:
            self._PARAMS = kwargs

        return kwargs

    def save(self, filename, **kwargs):
        &#34;&#34;&#34;
        Saves the figure to a file. 
        Figures are either saved using `plt.savefig` or `plotly.offline.plot`.

        Parameters
        ----------
        filename : str 
            A filename to save the figure to.
        
        **kwargs
            Any arbitrary keyword arguments for the respective figure saving method. 
        &#34;&#34;&#34;
        if self._fig is None:
            wa.SoftWarning(&#34;Plotter:no_fig_yet&#34;)
        else:
            if self._MODE == &#34;static&#34;:
                self._fig.savefig(filename, bbox_inches = &#39;tight&#39;, **kwargs)
            elif self._MODE == &#34;interactive&#34;:
                plotly.offline.plot(self._fig, filename=filename, **kwargs)

    def suffix(self):
        &#34;&#34;&#34;
        Returns
        ------- 
        suffix : str
            The appropriate file suffix for save (html for &#34;interactive&#34; or jpg for &#34;static&#34; figures)
        &#34;&#34;&#34;
        suffix = &#34;jpg&#34; if self._MODE == &#34;static&#34; else &#34;html&#34;
        return suffix

    def _setup_default_params(self, static:dict, interactive:dict):
        &#34;&#34;&#34;
        Setup and set default parameters for a FigureClass
        &#34;&#34;&#34;
        self._static_default = static
        self._interactive_default = interactive

    def _set_plot(self):
        &#34;&#34;&#34;
        Sets self._plot either interactive or static depending on MODe
        &#34;&#34;&#34;
        self._plot  = self._static_plot if self._MODE == &#34;static&#34; else self._interactive_plot
        prev_default = self._default_params
        self._default_params = self._static_default if self._MODE == &#34;static&#34; else self._interactive_default

        if self.params() == {} or self.params() == prev_default:
            self.params(**self._default_params)
        else:
            self.update_params(self._default_params, store = True, supersede = False)

    def _static_plot(self, **kwargs):
        &#34;&#34;&#34;
        The plot function that will handle static plotting (will be redefined for each FigureClass)
        &#34;&#34;&#34;
        print(&#34;The plot function that will handle static plotting...&#34;)
        print(&#34;Surprised to see this?, \nPerhaps your desired plotting methods are not named properly. Make sure to name your method _static_plot()!&#34;)

    def _interactive_plot(self, **kwargs):
        &#34;&#34;&#34;
        The plot function that will handle interactive plotting (will be redefined for each FigureClass)
        &#34;&#34;&#34;
        print(&#34;The plot function that will handle interactive plotting...&#34;)
        print(&#34;Surprised to see this?, \nPerhaps your desired plotting methods are not named properly. Make sure to name your method _interactive_plot()!&#34;)

    def _prep_properties(self):
        &#34;&#34;&#34;
        Setup ncols, nrows, subplot titles (headers), x, y, and sterr, columns for figure...
        &#34;&#34;&#34;
        self._setup_default_plot_cols()
        kwargs = self.params()
        data = self.get()

        # setup reference column and figure subplots
        ref_col = aux.from_kwargs(&#34;key&#34;, &#34;assay&#34;, kwargs, rm=True)
        ncols, nrows = aux.from_kwargs(&#34;subplots&#34;, 
                                        gx.make_layout(data, ref_col), 
                                        kwargs, rm=True
                                       )

        # transposing currently not supported...
        # if aux.from_kwargs(&#34;transpose&#34;, False, kwargs, rm = True):
        #     ncols, nrows = nrows, ncols

        headers = aux.sorted_set(data[ref_col])

        x = aux.from_kwargs(&#34;x&#34;, self._default_x, kwargs, rm = True)
        y = aux.from_kwargs(&#34;y&#34;, self._default_y, kwargs, rm = True)
        sterr = aux.from_kwargs(&#34;sterr&#34;, self._default_sterr, kwargs, rm = True)
        
        # the query to be used if group or group_name is ref_col
        query = &#34;{ref_col} == &#39;{q}&#39;&#34; if isinstance(headers[0], str) else &#34;{ref_col} == {q}&#34;

        return ref_col,ncols,nrows, headers, x, y, sterr, query

    def _setup_default_plot_cols(self):
        &#34;&#34;&#34;
        Sets default columns for x and y in barcharts,
        default x
        - &#34;group_name&#34; column if present 
        - &#34;group&#34; Otherwise
        default y
        - &#34;mean&#34;
        default sterr
        - &#34;stdev&#34;
        &#34;&#34;&#34;
        columns = self._data.columns
        self._default_x = &#34;group_name&#34; if &#34;group_name&#34; in columns else &#34;group&#34;
        self._default_y = &#34;mean&#34;
        self._default_sterr = &#34;stdev&#34;

class PreviewResults(Plotter):
    &#34;&#34;&#34;
    Generate a Preview of all results from all Assays in subplots.

    Parameters
    ----------
    mode : str
        The plotting mode. May be either &#34;static&#34; (matplotlib) or &#34;interactive&#34; (plotly).

    &#34;&#34;&#34;
    def __init__(self, mode:str):
        self._setup_default_params(
                                    static = _default_static_PreviewResults, 
                                    interactive = _default_interactive_PreviewResults
                                )
        # __init__ is going to require default_params to be already set!
        super().__init__(mode)

    def _static_plot(self, **kwargs):
        &#34;&#34;&#34;
        The static Preview Results Figure
        &#34;&#34;&#34;
        kwargs = self.update_params(kwargs)
        data = self.get()

        ref_col, ncols, nrows, headings, x, y, sterr, query = self._prep_properties()

        headers = aux.from_kwargs(&#34;headers&#34;, None, kwargs, rm = True)
        label_subplots = aux.from_kwargs(&#34;label_subplots&#34;, True, kwargs, rm = True)
        start_character = aux.from_kwargs(&#34;labeltype&#34;, &#34;A&#34;, kwargs, rm = True)
        show_spines = aux.from_kwargs(&#34;frame&#34;, True, kwargs, rm = True)
        show = aux.from_kwargs(&#34;show&#34;, True, kwargs, rm = True)

        edgecolor = aux.from_kwargs(&#34;edgecolor&#34;, &#34;black&#34;, kwargs, rm = True)
        edgewidth = aux.from_kwargs(&#34;edgewidth&#34;, 0.3, kwargs, rm = True)
        figsize = aux.from_kwargs(&#34;figsize&#34;, None, kwargs, rm = True)
        fig, axs = plt.subplots(nrows = nrows, ncols = ncols, figsize = figsize)

        # setup Coords
        Coords = gx.AxesCoords(fig, axs, (nrows, ncols))
        idx = 0
        for assay in headings: 
            try: 
                q = query.format(ref_col = ref_col, q = assay)
                tmp_df = data.query(q)

                # now plot a new bar chart 
                subplot = Coords.subplot()

                tmp_df.plot.bar(
                                x = x, y = y, 
                                ax = subplot,

                                edgecolor = edgecolor,
                                linewidth = edgewidth,
                                **kwargs
                            )

                subplot.errorbar(
                                x = tmp_df[x], y = tmp_df[y], 
                                yerr = tmp_df[sterr], 
                                fmt = &#34;.&#34;, markersize = 0, capsize = 3, 
                                ecolor = aux.from_kwargs(&#34;ecolor&#34;, &#34;black&#34;, kwargs),
                            )

                subplot.set(
                            title = assay if headers is None else headers[idx],
                            xlabel = aux.from_kwargs(&#34;xlabel&#34;, None, kwargs),
                            ylabel = aux.from_kwargs(&#34;ylabel&#34;, &#34;$\Delta\Delta$Ct&#34;, kwargs),        
                        )

                if not show_spines:
                    subplot.spines[&#34;right&#34;].set_visible(False)
                    subplot.spines[&#34;top&#34;].set_visible(False)
                    subplot.spines[&#34;left&#34;].set_linewidth(1.05)
                    subplot.spines[&#34;bottom&#34;].set_linewidth(1.05)

                # add ABCD... label to subplot
                if label_subplots:
                    self._add_subplot_label(idx, subplot, start_character)         

                Coords.increment()
                idx += 1
            except Exception as e:
                raise e 
                break
        
        plt.tight_layout()

        
        if show:
            plt.show()

        # print(&#34;&lt;&lt;&lt; Static Check &gt;&gt;&gt;&#34;)

        return fig 

    def _add_subplot_label(self, idx, subplot, start_character):
        &#34;&#34;&#34;
        Adds A B C ... to upper left corner of a subplot...
        It will start labelling at any arbitrary start_character
        &#34;&#34;&#34;
        subplot_label = chr(ord(start_character)+idx)
        subplot.annotate(
                    xy = (-0.1,1.03), 
                    text = subplot_label, 
                    xycoords = &#34;axes fraction&#34;,
                    weight = &#34;bold&#34;, fontsize = 12
                )

    def _interactive_plot(self, **kwargs):
        &#34;&#34;&#34;
        The interactive Preview Results Figure
        &#34;&#34;&#34;

        kwargs = self.update_params(kwargs)
        data = self.get()

        try: 
            # setup figure framework variables that have to be removed from 
            ref_col, ncols, nrows, headings, x, y, sterr, query = self._prep_properties()
            headers = aux.from_kwargs(&#34;headers&#34;, headings, kwargs, rm = True)
            show = aux.from_kwargs(&#34;show&#34;, True, kwargs, rm = True)

            speclist = gx.make_speclist(nrows, ncols, &#34;xy&#34;)
            fig = make_subplots(rows = nrows, cols = ncols, specs = speclist, subplot_titles = headers)


            Coords = gx.AxesCoords(fig, [], (ncols, nrows))

            fig.update_layout(
                        title = aux.from_kwargs(&#34;title&#34;, &#34;Results Preview&#34;, kwargs, rm = True), 
                        height = aux.from_kwargs(&#34;height&#34;, None, kwargs, rm = True), 
                        width = aux.from_kwargs(&#34;width&#34;, None, kwargs, rm = True),
                        margin = {&#34;autoexpand&#34;: True, &#34;pad&#34; : 0, &#34;b&#34;: 1, &#34;t&#34;: 50}, 
                        autosize = True, 
                        template = aux.from_kwargs(&#34;template&#34;, &#34;plotly_white&#34;, kwargs, rm = True),
                        legend = {&#34;title&#34; : aux.from_kwargs(&#34;legend_title&#34;, ref_col, kwargs, rm = True),
                        },
                    )

            idx = 0
            for assay in headings:
                row, col = Coords.get()
                tmp_df = data.query(query.format(ref_col = ref_col, q = assay))
                # now plot a new bar chart 
                fig.add_trace(

                    go.Bar(
                        name = assay,
                        y = tmp_df[y], x = tmp_df[x], 
                        error_y=dict(type=&#39;data&#39;, array = tmp_df[sterr]),
                        hoverinfo = aux.from_kwargs(&#34;hoverinfo&#34;, &#34;y&#34;, kwargs, rm = True), 
                        **kwargs
                    ), 

                    row, col
                )
                Coords.increment()

                idx += 1

            if show:
                fig.show()

            # print(&#34;&lt;&lt;&lt; Interactive Check &gt;&gt;&gt;&#34;)
            return fig 
        except Exception as e: 
            raise e 


class ReplicateBoxPlot(Plotter):
    &#34;&#34;&#34;
    Generate a boxplot figure summary for the input sample replicates.
    
    Note
    ----
    This is embedded in the Filter class. Since this is designed to work with Assays and not with DeltaCt Results,
    it redefines link to get() and not stats() the get required tables.

    Parameters
    ----------
    Filter : qpcr.Filters.Filter
        A qpcr.Filters.Filter object. The Filter can also be set using the `filter()` method.

    mode : str
        The plotting mode (either `&#34;interactive&#34;` or `&#34;static&#34;`).
    &#34;&#34;&#34;
    def __init__(self, Filter = None, mode=&#34;interactive&#34;):
        self._setup_default_params(
                                    static = _default_static_ReplicateBoxPlot, 
                                    interactive = _default_interactive_ReplicateBoxPlot
                                )
        # __init__ is going to require default_params to be already set!
        super().__init__(mode=mode)
        self._data = None
        self._Filter = Filter
        self._filter_stats = None
    
    def filter(self, Filter):
        &#34;&#34;&#34;
        Links a Filter object for which a report figure shall be generated

        Parameters
        ----------
        Filter : qpcr.Filters.Filter
            A qpcr.Filters.Filter object.

        &#34;&#34;&#34;
        self._Filter = Filter

    def link(self, Assay:qpcr.Assay):
        &#34;&#34;&#34;
        Links an Assay object to the BoxPlotter.
        This will simply add the Ct column to the current overall data!

        Parameters
        ----------
        Assay : qpcr.Assay
            A qpcr.Assay object.
        &#34;&#34;&#34;
        # somehow isinstance would not work...
        # future TODO: check out why isinstance didn&#39;t work here...
        example = qpcr.Assay()
        if type(Assay).__name__ == type(example).__name__:
            self._Results = Assay
            data = self._Results.get()
        else:
            wa.HardWarning(&#34;Plotter:unknown_data&#34;, obj = Assay)

        # add itentifier column
        data[&#34;assay&#34;] = [self._Results.id() for i in range(len(data))]

        if self._data is None: 
            self._data = data
        else:
            self._data = pd.concat([self._data, data], ignore_index=True)
        

    def _interactive_plot(self, **kwargs):
        &#34;&#34;&#34;
        Generates an interactive Boxplot summary of the input Ct values
        &#34;&#34;&#34;

        show = aux.from_kwargs(&#34;show&#34;, False, kwargs, rm = True)
        template = aux.from_kwargs(&#34;template&#34;, None, kwargs, rm=True)
        title = aux.from_kwargs(&#34;title&#34;, None, kwargs, rm=True)

        data = self._data
        
        # currently unused (needs to be integrated in the future..., see TODO below)
        # filter_stats = self._Filter.get_stats()

        groups = aux.sorted_set(data[&#34;group&#34;])
        group_names = aux.sorted_set(data[&#34;group_name&#34;])

        fig = go.Figure()

        for group, name in zip(groups, group_names):
            tmp_df = data.query(f&#34;group == {group}&#34;)
            
            # future TODO: 
            # currently the inclusion-range is NOT yet represented.
            # It appears as if boxplot cannot use precomputed mean-sd when x and y are specified... (hypothesis of mine)
            # so we&#39;d need an alternative way of plotting this stuff so we can include it...
             
            fig.add_trace(
                            go.Box(
                                x = tmp_df[&#34;assay&#34;],
                                y = tmp_df[&#34;Ct&#34;],
                                name = name,
                                hoverinfo = &#34;y+name&#34;,
                                **kwargs,
                            ),
                        )
            
           
        fig.update_layout(
                            boxmode=&#34;group&#34;, 
                            template = template, 
                            title = title,
                        )

        if show:
            fig.show()

        return fig 


    def _static_plot(self, **kwargs):
        &#34;&#34;&#34;
        Generates a static Boxplot summary of the input Ct values
        &#34;&#34;&#34;

        data = self._data
        
        show = aux.from_kwargs(&#34;show&#34;, False, kwargs, rm = True)
        figsize = aux.from_kwargs(&#34;figsize&#34;, (7,5), kwargs, rm=True)
        title = aux.from_kwargs(&#34;title&#34;, None, kwargs, rm=True)
        show_spines = aux.from_kwargs(&#34;frame&#34;, True, kwargs, rm = True)
        ncols, nrows = aux.from_kwargs(&#34;subplots&#34;, gx.make_layout(data, &#34;assay&#34;), kwargs, rm=True)

        # future TODO: 
        # currently the inclusion-range is NOT yet represented.
        # It appears as if boxplot cannot use precomputed mean-sd when x and y are specified... (hypothesis of mine)
        # so we&#39;d need an alternative way of plotting this stuff so we can include it...
            
        # filter_stats = self._Filter.get_stats()

        # sns.set_style(&#34;whitegrid&#34;)

        fig, axs = plt.subplots(nrows = nrows, ncols = ncols, figsize=figsize)
        
        # possibly nrows and ncols should be switched...
        Coords = gx.AxesCoords(fig, axs, (nrows, ncols))
        
        for assay in aux.sorted_set(data[&#34;assay&#34;]):
            
            try: 
                ax = Coords.subplot()
            except: 
                print(&#34;We ran out of axes ... &#34;)
                break
            tmp = data.query(f&#34;assay == &#39;{assay}&#39;&#34;)

            sns.boxplot(
                        data=tmp, 
                        x = &#34;assay&#34;, y = &#34;Ct&#34;, hue=&#34;group_name&#34;, 
                        ax = ax, 
                        **kwargs
                    )

            ax.legend(bbox_to_anchor=(1,1), loc = None).remove()
            ax.set(title=assay, xlabel = &#34;&#34;, xticklabels = [],)
            
            if not show_spines:
                sns.despine()

            Coords.increment()

        # add one single legend to the last plot
        ax.legend(bbox_to_anchor=(1,1), loc = None)

        fig.suptitle(title)
        plt.tight_layout()

        if show:
            fig.show()

        return fig 


if __name__ == &#39;__main__&#39;:

    files = [&#34;Example Data/28S.csv&#34;, &#34;Example Data/28S_again.csv&#34;, &#34;Example Data/actin.csv&#34;,
    &#34;Example Data/actin2.csv&#34;,
    &#34;Example Data/actin3.csv&#34;,
    &#34;Example Data/HNRNPL_nmd.csv&#34;, &#34;Example Data/HNRNPL_prot.csv&#34;]
    groupnames = [&#34;wt-&#34;, &#34;wt+&#34;, &#34;ko-&#34;, &#34;ko+&#34;]

    # setup figures
    a = PreviewResults(mode = &#34;static&#34;)
    b = PreviewResults(mode = &#34;interactive&#34;)

    a.params(
          frame = True, labeltype = &#34;a&#34;, show = False
    )
    b.params(
        show = False, template = &#34;plotly&#34;  
    )

    # predefined pipeline use
    pipe = qpcr.Pipes.Basic()
    pipe.link(files)
    pipe.add_normalisers(files[:2])
    pipe.replicates(6)
    pipe.names(groupnames)


    print()
    print(&#34;==== Multiple (ALL) Samples ====&#34;)
    pipe.run()
    result = pipe.get(kind = &#34;obj&#34;)
    try:
        a.link(result)
        a.plot(color = &#34;green&#34;)
    except: 
        print(&#34;Static Failed!&#34;)

    try:
        b.link(result)
        b.plot()
    except: print(&#34;Interactive Failed!&#34;)

    print()
    print(&#34;==== Multiple (7) Samples ====&#34;)
    pipe.link(files[:7])
    pipe.run()
    result = pipe.get(kind = &#34;obj&#34;)
    try:
        a.link(result)
        a.plot(show = False)
    except: 
        print(&#34;Static Failed!&#34;)

    try:
        b.link(result)
        b.plot(template = &#34;plotly&#34;)
    except: print(&#34;Interactive Failed!&#34;)

    print()
    print(&#34;==== Multiple (6) Samples ====&#34;)
    pipe.link(files[:6])
    pipe.run()
    result = pipe.get(kind = &#34;obj&#34;)
    try:
        a.link(result)
        a.plot()
    except: 
        print(&#34;Static Failed!&#34;)

    try:
        b.link(result)
        b.plot()
    except: print(&#34;Interactive Failed!&#34;)

    print()
    print(&#34;==== Multiple (4) Samples ====&#34;)
    pipe.link(files[:4])
    pipe.run()
    result = pipe.get(kind = &#34;obj&#34;)
    try:
        a.link(result)
        a.plot()
    except: 
        print(&#34;Static Failed!&#34;)

    try:
        b.link(result)
        b.plot()
    except: print(&#34;Interactive Failed!&#34;)

    print()
    print(&#34;==== Multiple (3) Samples ====&#34;)
    pipe.link(files[:3])
    pipe.run()
    result = pipe.get(kind = &#34;obj&#34;)
    try:
        a.link(result)
        a.plot()
    except Exception as e: 
        print(e)
        print(&#34;Static Failed!&#34;)

    try:
        b.link(result)
        b.plot()
    except Exception as e: 
        print(&#34;Interactive Failed!&#34;)
        raise e

    print()
    print(&#34;==== Multiple (2) Samples ====&#34;)
    pipe.link(files[:2])
    pipe.run()
    result = pipe.get(kind = &#34;obj&#34;)
    try:
        a.link(result)
        a.plot(show = False)
    except Exception as e: 
        print(e)
        print(&#34;Static Failed!&#34;)

    try:
        b.link(result)
        b.plot(show = False)
    except Exception as e: 
        print(&#34;Interactive Failed!&#34;)
        raise e


    print()
    print(&#34;==== One (1) Sample ====&#34;)
    pipe.link([files[0]])
    pipe.run()
    result = pipe.get(kind = &#34;obj&#34;)
    try:
        a.link(result)
        a.plot()
    except: 
        print(&#34;Static Failed!&#34;)

    try:
        b.link(result)
        b.plot()
    except: print(&#34;Interactive Failed!&#34;)
    exit(0)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="qpcr.Plotters.Plotter"><code class="flex name class">
<span>class <span class="ident">Plotter</span></span>
<span>(</span><span>mode=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A superclass that handles Data Linking and Parameter setup for FigureClasses
(not for End-User usage)
Parameters</p>
<hr>
<dl>
<dt><strong><code>mode</code></strong> :&ensp;<code>str</code></dt>
<dd>The plotting mode. May be either "static" (matplotlib) or "interactive" (plotly).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Plotter:
    &#34;&#34;&#34;
    A superclass that handles Data Linking and Parameter setup for FigureClasses
    (not for End-User usage)
    Parameters
    ----------
    mode : str
        The plotting mode. May be either &#34;static&#34; (matplotlib) or &#34;interactive&#34; (plotly).
    &#34;&#34;&#34;
    def __init__(self, mode = None):
        self._default_params = None
        self._PARAMS = {} #: _PARAMS will store the plotting parameter kwargs from both _default_params and any additional user specified parameters
        self._Results = None
        self._data = None
        self._id = type(self).__name__
        self._MODE = &#34;interactive&#34; if mode is None else mode
        self._fig = None
        self._set_plot()

    def link(self, Results:(qpcr.Results or pd.DataFrame)):
        &#34;&#34;&#34;
        Links a Results object or pandas DataFrame of the same architecture
        as one handled by a Results object to the Plotter. 
        Note, that this will replace any previously linked data!

        Parameters
        ----------
        Results : qpcr.Results or pd.DataFrame
            A qpcr.Results Object or a pandas DataFrame of the same architecture.
        &#34;&#34;&#34;

        if type(Results).__name__ == type(qpcr.Results()).__name__:
            self._Results = Results
            self._data = self._Results.stats()
        elif isinstance(Results, pd.DataFrame):
            self._Results = None
            self._data = Results
        else:
            wa.HardWarning(&#34;Plotter:unknown_data&#34;, obj = Results)

    def plot(self, **kwargs):
        &#34;&#34;&#34;
        Generate Figure

        Parameters
        ----------
        **kwargs
            Any arbitrary keyword arguments to be passed to the plotting method
        
        Returns
        -------
        fig
            A figure object, either from matplotlib or plotly
        &#34;&#34;&#34;
        total_kwargs = self.update_params(kwargs)
        fig = self._plot(**total_kwargs)
        self._fig = fig
        return fig

    def id(self, id:str = None):
        &#34;&#34;&#34;
        Set a unique Id, by default the Classname will be used.

        Parameters
        ----------
        id : str
            A unique identifier for the Plotter object
        
        Returns
        -------
        id 
            The Plotter Id (if no id keyword was entered)
        &#34;&#34;&#34;
        if id is not None:
            self._id = id
        else:
            return self._id

    def get(self):
        &#34;&#34;&#34;
        Returns the DataFrame used for plotting

        Returns
        -------
        data
            A pandas DataFrame containing the data underlying the plot.
        &#34;&#34;&#34;
        return self._data

    def params(self, **params):
        &#34;&#34;&#34;
        Set default parameters for plotting (will be forwarded to **kwargs)
        Returns default parameters if no new parameters are added.

        Parameters
        ----------
        **params
            Any arbitrary keyword arguments to be passed on to the pre-set plotting kwargs.
            This will either set the default parameters (if none has been specified up to the function call)
            or will update the parameters. In case of keyword duplications any OLD key : value pairs will be 
            OVERWRITTEN by new ones. 
        
        Returns
        -------
        params : dict
            A dictionary of the new pre-set plotting parameters
        &#34;&#34;&#34;
        if params != {} and self._PARAMS == {}:
            self._PARAMS = params
        elif params != {}:
            self.update_params(params, store = True)
        return self._PARAMS

    def update_params(self, kwargs, supersede = True, store = False):
        &#34;&#34;&#34;
        Appends pre-set parameters to kwargs. 
        
        Parameters
        ----------
        kwargs : dict
            A dictionary of arbitrary keywords for plotting 
        supersede : bool 
            In case of key duplications: Old values will be replaced with new ones (if supersede = True, default), 
            or keep old ones (supersede = False).
        store : bool
            The newly set plotting parameter dictionary will be stored by the plotting object as new default (if store = True, default is False).
        
        Returns
        -------
        params : dict
            A dictionary of updated plotting parameters
        &#34;&#34;&#34;
        if supersede:
            kwargs = dict(self._PARAMS, **kwargs)
        else:
            kwargs = kwargs = dict(kwargs, **self._PARAMS)
        
        if store:
            self._PARAMS = kwargs

        return kwargs

    def save(self, filename, **kwargs):
        &#34;&#34;&#34;
        Saves the figure to a file. 
        Figures are either saved using `plt.savefig` or `plotly.offline.plot`.

        Parameters
        ----------
        filename : str 
            A filename to save the figure to.
        
        **kwargs
            Any arbitrary keyword arguments for the respective figure saving method. 
        &#34;&#34;&#34;
        if self._fig is None:
            wa.SoftWarning(&#34;Plotter:no_fig_yet&#34;)
        else:
            if self._MODE == &#34;static&#34;:
                self._fig.savefig(filename, bbox_inches = &#39;tight&#39;, **kwargs)
            elif self._MODE == &#34;interactive&#34;:
                plotly.offline.plot(self._fig, filename=filename, **kwargs)

    def suffix(self):
        &#34;&#34;&#34;
        Returns
        ------- 
        suffix : str
            The appropriate file suffix for save (html for &#34;interactive&#34; or jpg for &#34;static&#34; figures)
        &#34;&#34;&#34;
        suffix = &#34;jpg&#34; if self._MODE == &#34;static&#34; else &#34;html&#34;
        return suffix

    def _setup_default_params(self, static:dict, interactive:dict):
        &#34;&#34;&#34;
        Setup and set default parameters for a FigureClass
        &#34;&#34;&#34;
        self._static_default = static
        self._interactive_default = interactive

    def _set_plot(self):
        &#34;&#34;&#34;
        Sets self._plot either interactive or static depending on MODe
        &#34;&#34;&#34;
        self._plot  = self._static_plot if self._MODE == &#34;static&#34; else self._interactive_plot
        prev_default = self._default_params
        self._default_params = self._static_default if self._MODE == &#34;static&#34; else self._interactive_default

        if self.params() == {} or self.params() == prev_default:
            self.params(**self._default_params)
        else:
            self.update_params(self._default_params, store = True, supersede = False)

    def _static_plot(self, **kwargs):
        &#34;&#34;&#34;
        The plot function that will handle static plotting (will be redefined for each FigureClass)
        &#34;&#34;&#34;
        print(&#34;The plot function that will handle static plotting...&#34;)
        print(&#34;Surprised to see this?, \nPerhaps your desired plotting methods are not named properly. Make sure to name your method _static_plot()!&#34;)

    def _interactive_plot(self, **kwargs):
        &#34;&#34;&#34;
        The plot function that will handle interactive plotting (will be redefined for each FigureClass)
        &#34;&#34;&#34;
        print(&#34;The plot function that will handle interactive plotting...&#34;)
        print(&#34;Surprised to see this?, \nPerhaps your desired plotting methods are not named properly. Make sure to name your method _interactive_plot()!&#34;)

    def _prep_properties(self):
        &#34;&#34;&#34;
        Setup ncols, nrows, subplot titles (headers), x, y, and sterr, columns for figure...
        &#34;&#34;&#34;
        self._setup_default_plot_cols()
        kwargs = self.params()
        data = self.get()

        # setup reference column and figure subplots
        ref_col = aux.from_kwargs(&#34;key&#34;, &#34;assay&#34;, kwargs, rm=True)
        ncols, nrows = aux.from_kwargs(&#34;subplots&#34;, 
                                        gx.make_layout(data, ref_col), 
                                        kwargs, rm=True
                                       )

        # transposing currently not supported...
        # if aux.from_kwargs(&#34;transpose&#34;, False, kwargs, rm = True):
        #     ncols, nrows = nrows, ncols

        headers = aux.sorted_set(data[ref_col])

        x = aux.from_kwargs(&#34;x&#34;, self._default_x, kwargs, rm = True)
        y = aux.from_kwargs(&#34;y&#34;, self._default_y, kwargs, rm = True)
        sterr = aux.from_kwargs(&#34;sterr&#34;, self._default_sterr, kwargs, rm = True)
        
        # the query to be used if group or group_name is ref_col
        query = &#34;{ref_col} == &#39;{q}&#39;&#34; if isinstance(headers[0], str) else &#34;{ref_col} == {q}&#34;

        return ref_col,ncols,nrows, headers, x, y, sterr, query

    def _setup_default_plot_cols(self):
        &#34;&#34;&#34;
        Sets default columns for x and y in barcharts,
        default x
        - &#34;group_name&#34; column if present 
        - &#34;group&#34; Otherwise
        default y
        - &#34;mean&#34;
        default sterr
        - &#34;stdev&#34;
        &#34;&#34;&#34;
        columns = self._data.columns
        self._default_x = &#34;group_name&#34; if &#34;group_name&#34; in columns else &#34;group&#34;
        self._default_y = &#34;mean&#34;
        self._default_sterr = &#34;stdev&#34;</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="qpcr.Plotters.PreviewResults" href="#qpcr.Plotters.PreviewResults">PreviewResults</a></li>
<li><a title="qpcr.Plotters.ReplicateBoxPlot" href="#qpcr.Plotters.ReplicateBoxPlot">ReplicateBoxPlot</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="qpcr.Plotters.Plotter.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the DataFrame used for plotting</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>data</code></dt>
<dd>A pandas DataFrame containing the data underlying the plot.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(self):
    &#34;&#34;&#34;
    Returns the DataFrame used for plotting

    Returns
    -------
    data
        A pandas DataFrame containing the data underlying the plot.
    &#34;&#34;&#34;
    return self._data</code></pre>
</details>
</dd>
<dt id="qpcr.Plotters.Plotter.id"><code class="name flex">
<span>def <span class="ident">id</span></span>(<span>self, id: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Set a unique Id, by default the Classname will be used.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>id</code></strong> :&ensp;<code>str</code></dt>
<dd>A unique identifier for the Plotter object</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>id </code></dt>
<dd>The Plotter Id (if no id keyword was entered)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def id(self, id:str = None):
    &#34;&#34;&#34;
    Set a unique Id, by default the Classname will be used.

    Parameters
    ----------
    id : str
        A unique identifier for the Plotter object
    
    Returns
    -------
    id 
        The Plotter Id (if no id keyword was entered)
    &#34;&#34;&#34;
    if id is not None:
        self._id = id
    else:
        return self._id</code></pre>
</details>
</dd>
<dt id="qpcr.Plotters.Plotter.link"><code class="name flex">
<span>def <span class="ident">link</span></span>(<span>self, Results: <a title="qpcr.Results" href="index.html#qpcr.Results">Results</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Links a Results object or pandas DataFrame of the same architecture
as one handled by a Results object to the Plotter.
Note, that this will replace any previously linked data!</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>Results</code></strong> :&ensp;<code><a title="qpcr.Results" href="index.html#qpcr.Results">Results</a></code> or <code>pd.DataFrame</code></dt>
<dd>A qpcr.Results Object or a pandas DataFrame of the same architecture.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def link(self, Results:(qpcr.Results or pd.DataFrame)):
    &#34;&#34;&#34;
    Links a Results object or pandas DataFrame of the same architecture
    as one handled by a Results object to the Plotter. 
    Note, that this will replace any previously linked data!

    Parameters
    ----------
    Results : qpcr.Results or pd.DataFrame
        A qpcr.Results Object or a pandas DataFrame of the same architecture.
    &#34;&#34;&#34;

    if type(Results).__name__ == type(qpcr.Results()).__name__:
        self._Results = Results
        self._data = self._Results.stats()
    elif isinstance(Results, pd.DataFrame):
        self._Results = None
        self._data = Results
    else:
        wa.HardWarning(&#34;Plotter:unknown_data&#34;, obj = Results)</code></pre>
</details>
</dd>
<dt id="qpcr.Plotters.Plotter.params"><code class="name flex">
<span>def <span class="ident">params</span></span>(<span>self, **params)</span>
</code></dt>
<dd>
<div class="desc"><p>Set default parameters for plotting (will be forwarded to **kwargs)
Returns default parameters if no new parameters are added.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>**params</code></strong></dt>
<dd>Any arbitrary keyword arguments to be passed on to the pre-set plotting kwargs.
This will either set the default parameters (if none has been specified up to the function call)
or will update the parameters. In case of keyword duplications any OLD key : value pairs will be
OVERWRITTEN by new ones.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>params</code></strong> :&ensp;<code>dict</code></dt>
<dd>A dictionary of the new pre-set plotting parameters</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def params(self, **params):
    &#34;&#34;&#34;
    Set default parameters for plotting (will be forwarded to **kwargs)
    Returns default parameters if no new parameters are added.

    Parameters
    ----------
    **params
        Any arbitrary keyword arguments to be passed on to the pre-set plotting kwargs.
        This will either set the default parameters (if none has been specified up to the function call)
        or will update the parameters. In case of keyword duplications any OLD key : value pairs will be 
        OVERWRITTEN by new ones. 
    
    Returns
    -------
    params : dict
        A dictionary of the new pre-set plotting parameters
    &#34;&#34;&#34;
    if params != {} and self._PARAMS == {}:
        self._PARAMS = params
    elif params != {}:
        self.update_params(params, store = True)
    return self._PARAMS</code></pre>
</details>
</dd>
<dt id="qpcr.Plotters.Plotter.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate Figure</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Any arbitrary keyword arguments to be passed to the plotting method</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>fig</code></dt>
<dd>A figure object, either from matplotlib or plotly</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self, **kwargs):
    &#34;&#34;&#34;
    Generate Figure

    Parameters
    ----------
    **kwargs
        Any arbitrary keyword arguments to be passed to the plotting method
    
    Returns
    -------
    fig
        A figure object, either from matplotlib or plotly
    &#34;&#34;&#34;
    total_kwargs = self.update_params(kwargs)
    fig = self._plot(**total_kwargs)
    self._fig = fig
    return fig</code></pre>
</details>
</dd>
<dt id="qpcr.Plotters.Plotter.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, filename, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Saves the figure to a file.
Figures are either saved using <code>plt.savefig</code> or <code>plotly.offline.plot</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>str </code></dt>
<dd>A filename to save the figure to.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Any arbitrary keyword arguments for the respective figure saving method.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save(self, filename, **kwargs):
    &#34;&#34;&#34;
    Saves the figure to a file. 
    Figures are either saved using `plt.savefig` or `plotly.offline.plot`.

    Parameters
    ----------
    filename : str 
        A filename to save the figure to.
    
    **kwargs
        Any arbitrary keyword arguments for the respective figure saving method. 
    &#34;&#34;&#34;
    if self._fig is None:
        wa.SoftWarning(&#34;Plotter:no_fig_yet&#34;)
    else:
        if self._MODE == &#34;static&#34;:
            self._fig.savefig(filename, bbox_inches = &#39;tight&#39;, **kwargs)
        elif self._MODE == &#34;interactive&#34;:
            plotly.offline.plot(self._fig, filename=filename, **kwargs)</code></pre>
</details>
</dd>
<dt id="qpcr.Plotters.Plotter.suffix"><code class="name flex">
<span>def <span class="ident">suffix</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<p>suffix : str
The appropriate file suffix for save (html for "interactive" or jpg for "static" figures)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def suffix(self):
    &#34;&#34;&#34;
    Returns
    ------- 
    suffix : str
        The appropriate file suffix for save (html for &#34;interactive&#34; or jpg for &#34;static&#34; figures)
    &#34;&#34;&#34;
    suffix = &#34;jpg&#34; if self._MODE == &#34;static&#34; else &#34;html&#34;
    return suffix</code></pre>
</details>
</dd>
<dt id="qpcr.Plotters.Plotter.update_params"><code class="name flex">
<span>def <span class="ident">update_params</span></span>(<span>self, kwargs, supersede=True, store=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Appends pre-set parameters to kwargs. </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>A dictionary of arbitrary keywords for plotting</dd>
<dt><strong><code>supersede</code></strong> :&ensp;<code>bool </code></dt>
<dd>In case of key duplications: Old values will be replaced with new ones (if supersede = True, default),
or keep old ones (supersede = False).</dd>
<dt><strong><code>store</code></strong> :&ensp;<code>bool</code></dt>
<dd>The newly set plotting parameter dictionary will be stored by the plotting object as new default (if store = True, default is False).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>params</code></strong> :&ensp;<code>dict</code></dt>
<dd>A dictionary of updated plotting parameters</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_params(self, kwargs, supersede = True, store = False):
    &#34;&#34;&#34;
    Appends pre-set parameters to kwargs. 
    
    Parameters
    ----------
    kwargs : dict
        A dictionary of arbitrary keywords for plotting 
    supersede : bool 
        In case of key duplications: Old values will be replaced with new ones (if supersede = True, default), 
        or keep old ones (supersede = False).
    store : bool
        The newly set plotting parameter dictionary will be stored by the plotting object as new default (if store = True, default is False).
    
    Returns
    -------
    params : dict
        A dictionary of updated plotting parameters
    &#34;&#34;&#34;
    if supersede:
        kwargs = dict(self._PARAMS, **kwargs)
    else:
        kwargs = kwargs = dict(kwargs, **self._PARAMS)
    
    if store:
        self._PARAMS = kwargs

    return kwargs</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="qpcr.Plotters.PreviewResults"><code class="flex name class">
<span>class <span class="ident">PreviewResults</span></span>
<span>(</span><span>mode: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a Preview of all results from all Assays in subplots.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>mode</code></strong> :&ensp;<code>str</code></dt>
<dd>The plotting mode. May be either "static" (matplotlib) or "interactive" (plotly).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PreviewResults(Plotter):
    &#34;&#34;&#34;
    Generate a Preview of all results from all Assays in subplots.

    Parameters
    ----------
    mode : str
        The plotting mode. May be either &#34;static&#34; (matplotlib) or &#34;interactive&#34; (plotly).

    &#34;&#34;&#34;
    def __init__(self, mode:str):
        self._setup_default_params(
                                    static = _default_static_PreviewResults, 
                                    interactive = _default_interactive_PreviewResults
                                )
        # __init__ is going to require default_params to be already set!
        super().__init__(mode)

    def _static_plot(self, **kwargs):
        &#34;&#34;&#34;
        The static Preview Results Figure
        &#34;&#34;&#34;
        kwargs = self.update_params(kwargs)
        data = self.get()

        ref_col, ncols, nrows, headings, x, y, sterr, query = self._prep_properties()

        headers = aux.from_kwargs(&#34;headers&#34;, None, kwargs, rm = True)
        label_subplots = aux.from_kwargs(&#34;label_subplots&#34;, True, kwargs, rm = True)
        start_character = aux.from_kwargs(&#34;labeltype&#34;, &#34;A&#34;, kwargs, rm = True)
        show_spines = aux.from_kwargs(&#34;frame&#34;, True, kwargs, rm = True)
        show = aux.from_kwargs(&#34;show&#34;, True, kwargs, rm = True)

        edgecolor = aux.from_kwargs(&#34;edgecolor&#34;, &#34;black&#34;, kwargs, rm = True)
        edgewidth = aux.from_kwargs(&#34;edgewidth&#34;, 0.3, kwargs, rm = True)
        figsize = aux.from_kwargs(&#34;figsize&#34;, None, kwargs, rm = True)
        fig, axs = plt.subplots(nrows = nrows, ncols = ncols, figsize = figsize)

        # setup Coords
        Coords = gx.AxesCoords(fig, axs, (nrows, ncols))
        idx = 0
        for assay in headings: 
            try: 
                q = query.format(ref_col = ref_col, q = assay)
                tmp_df = data.query(q)

                # now plot a new bar chart 
                subplot = Coords.subplot()

                tmp_df.plot.bar(
                                x = x, y = y, 
                                ax = subplot,

                                edgecolor = edgecolor,
                                linewidth = edgewidth,
                                **kwargs
                            )

                subplot.errorbar(
                                x = tmp_df[x], y = tmp_df[y], 
                                yerr = tmp_df[sterr], 
                                fmt = &#34;.&#34;, markersize = 0, capsize = 3, 
                                ecolor = aux.from_kwargs(&#34;ecolor&#34;, &#34;black&#34;, kwargs),
                            )

                subplot.set(
                            title = assay if headers is None else headers[idx],
                            xlabel = aux.from_kwargs(&#34;xlabel&#34;, None, kwargs),
                            ylabel = aux.from_kwargs(&#34;ylabel&#34;, &#34;$\Delta\Delta$Ct&#34;, kwargs),        
                        )

                if not show_spines:
                    subplot.spines[&#34;right&#34;].set_visible(False)
                    subplot.spines[&#34;top&#34;].set_visible(False)
                    subplot.spines[&#34;left&#34;].set_linewidth(1.05)
                    subplot.spines[&#34;bottom&#34;].set_linewidth(1.05)

                # add ABCD... label to subplot
                if label_subplots:
                    self._add_subplot_label(idx, subplot, start_character)         

                Coords.increment()
                idx += 1
            except Exception as e:
                raise e 
                break
        
        plt.tight_layout()

        
        if show:
            plt.show()

        # print(&#34;&lt;&lt;&lt; Static Check &gt;&gt;&gt;&#34;)

        return fig 

    def _add_subplot_label(self, idx, subplot, start_character):
        &#34;&#34;&#34;
        Adds A B C ... to upper left corner of a subplot...
        It will start labelling at any arbitrary start_character
        &#34;&#34;&#34;
        subplot_label = chr(ord(start_character)+idx)
        subplot.annotate(
                    xy = (-0.1,1.03), 
                    text = subplot_label, 
                    xycoords = &#34;axes fraction&#34;,
                    weight = &#34;bold&#34;, fontsize = 12
                )

    def _interactive_plot(self, **kwargs):
        &#34;&#34;&#34;
        The interactive Preview Results Figure
        &#34;&#34;&#34;

        kwargs = self.update_params(kwargs)
        data = self.get()

        try: 
            # setup figure framework variables that have to be removed from 
            ref_col, ncols, nrows, headings, x, y, sterr, query = self._prep_properties()
            headers = aux.from_kwargs(&#34;headers&#34;, headings, kwargs, rm = True)
            show = aux.from_kwargs(&#34;show&#34;, True, kwargs, rm = True)

            speclist = gx.make_speclist(nrows, ncols, &#34;xy&#34;)
            fig = make_subplots(rows = nrows, cols = ncols, specs = speclist, subplot_titles = headers)


            Coords = gx.AxesCoords(fig, [], (ncols, nrows))

            fig.update_layout(
                        title = aux.from_kwargs(&#34;title&#34;, &#34;Results Preview&#34;, kwargs, rm = True), 
                        height = aux.from_kwargs(&#34;height&#34;, None, kwargs, rm = True), 
                        width = aux.from_kwargs(&#34;width&#34;, None, kwargs, rm = True),
                        margin = {&#34;autoexpand&#34;: True, &#34;pad&#34; : 0, &#34;b&#34;: 1, &#34;t&#34;: 50}, 
                        autosize = True, 
                        template = aux.from_kwargs(&#34;template&#34;, &#34;plotly_white&#34;, kwargs, rm = True),
                        legend = {&#34;title&#34; : aux.from_kwargs(&#34;legend_title&#34;, ref_col, kwargs, rm = True),
                        },
                    )

            idx = 0
            for assay in headings:
                row, col = Coords.get()
                tmp_df = data.query(query.format(ref_col = ref_col, q = assay))
                # now plot a new bar chart 
                fig.add_trace(

                    go.Bar(
                        name = assay,
                        y = tmp_df[y], x = tmp_df[x], 
                        error_y=dict(type=&#39;data&#39;, array = tmp_df[sterr]),
                        hoverinfo = aux.from_kwargs(&#34;hoverinfo&#34;, &#34;y&#34;, kwargs, rm = True), 
                        **kwargs
                    ), 

                    row, col
                )
                Coords.increment()

                idx += 1

            if show:
                fig.show()

            # print(&#34;&lt;&lt;&lt; Interactive Check &gt;&gt;&gt;&#34;)
            return fig 
        except Exception as e: 
            raise e </code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="qpcr.Plotters.Plotter" href="#qpcr.Plotters.Plotter">Plotter</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="qpcr.Plotters.Plotter" href="#qpcr.Plotters.Plotter">Plotter</a></b></code>:
<ul class="hlist">
<li><code><a title="qpcr.Plotters.Plotter.get" href="#qpcr.Plotters.Plotter.get">get</a></code></li>
<li><code><a title="qpcr.Plotters.Plotter.id" href="#qpcr.Plotters.Plotter.id">id</a></code></li>
<li><code><a title="qpcr.Plotters.Plotter.link" href="#qpcr.Plotters.Plotter.link">link</a></code></li>
<li><code><a title="qpcr.Plotters.Plotter.params" href="#qpcr.Plotters.Plotter.params">params</a></code></li>
<li><code><a title="qpcr.Plotters.Plotter.plot" href="#qpcr.Plotters.Plotter.plot">plot</a></code></li>
<li><code><a title="qpcr.Plotters.Plotter.save" href="#qpcr.Plotters.Plotter.save">save</a></code></li>
<li><code><a title="qpcr.Plotters.Plotter.suffix" href="#qpcr.Plotters.Plotter.suffix">suffix</a></code></li>
<li><code><a title="qpcr.Plotters.Plotter.update_params" href="#qpcr.Plotters.Plotter.update_params">update_params</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="qpcr.Plotters.ReplicateBoxPlot"><code class="flex name class">
<span>class <span class="ident">ReplicateBoxPlot</span></span>
<span>(</span><span>Filter=None, mode='interactive')</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a boxplot figure summary for the input sample replicates.</p>
<h2 id="note">Note</h2>
<p>This is embedded in the Filter class. Since this is designed to work with Assays and not with DeltaCt Results,
it redefines link to get() and not stats() the get required tables.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>Filter</code></strong> :&ensp;<code><a title="qpcr.Filters.Filter" href="Filters.html#qpcr.Filters.Filter">Filter</a></code></dt>
<dd>A qpcr.Filters.Filter object. The Filter can also be set using the <code>filter()</code> method.</dd>
<dt><strong><code>mode</code></strong> :&ensp;<code>str</code></dt>
<dd>The plotting mode (either <code>"interactive"</code> or <code>"static"</code>).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ReplicateBoxPlot(Plotter):
    &#34;&#34;&#34;
    Generate a boxplot figure summary for the input sample replicates.
    
    Note
    ----
    This is embedded in the Filter class. Since this is designed to work with Assays and not with DeltaCt Results,
    it redefines link to get() and not stats() the get required tables.

    Parameters
    ----------
    Filter : qpcr.Filters.Filter
        A qpcr.Filters.Filter object. The Filter can also be set using the `filter()` method.

    mode : str
        The plotting mode (either `&#34;interactive&#34;` or `&#34;static&#34;`).
    &#34;&#34;&#34;
    def __init__(self, Filter = None, mode=&#34;interactive&#34;):
        self._setup_default_params(
                                    static = _default_static_ReplicateBoxPlot, 
                                    interactive = _default_interactive_ReplicateBoxPlot
                                )
        # __init__ is going to require default_params to be already set!
        super().__init__(mode=mode)
        self._data = None
        self._Filter = Filter
        self._filter_stats = None
    
    def filter(self, Filter):
        &#34;&#34;&#34;
        Links a Filter object for which a report figure shall be generated

        Parameters
        ----------
        Filter : qpcr.Filters.Filter
            A qpcr.Filters.Filter object.

        &#34;&#34;&#34;
        self._Filter = Filter

    def link(self, Assay:qpcr.Assay):
        &#34;&#34;&#34;
        Links an Assay object to the BoxPlotter.
        This will simply add the Ct column to the current overall data!

        Parameters
        ----------
        Assay : qpcr.Assay
            A qpcr.Assay object.
        &#34;&#34;&#34;
        # somehow isinstance would not work...
        # future TODO: check out why isinstance didn&#39;t work here...
        example = qpcr.Assay()
        if type(Assay).__name__ == type(example).__name__:
            self._Results = Assay
            data = self._Results.get()
        else:
            wa.HardWarning(&#34;Plotter:unknown_data&#34;, obj = Assay)

        # add itentifier column
        data[&#34;assay&#34;] = [self._Results.id() for i in range(len(data))]

        if self._data is None: 
            self._data = data
        else:
            self._data = pd.concat([self._data, data], ignore_index=True)
        

    def _interactive_plot(self, **kwargs):
        &#34;&#34;&#34;
        Generates an interactive Boxplot summary of the input Ct values
        &#34;&#34;&#34;

        show = aux.from_kwargs(&#34;show&#34;, False, kwargs, rm = True)
        template = aux.from_kwargs(&#34;template&#34;, None, kwargs, rm=True)
        title = aux.from_kwargs(&#34;title&#34;, None, kwargs, rm=True)

        data = self._data
        
        # currently unused (needs to be integrated in the future..., see TODO below)
        # filter_stats = self._Filter.get_stats()

        groups = aux.sorted_set(data[&#34;group&#34;])
        group_names = aux.sorted_set(data[&#34;group_name&#34;])

        fig = go.Figure()

        for group, name in zip(groups, group_names):
            tmp_df = data.query(f&#34;group == {group}&#34;)
            
            # future TODO: 
            # currently the inclusion-range is NOT yet represented.
            # It appears as if boxplot cannot use precomputed mean-sd when x and y are specified... (hypothesis of mine)
            # so we&#39;d need an alternative way of plotting this stuff so we can include it...
             
            fig.add_trace(
                            go.Box(
                                x = tmp_df[&#34;assay&#34;],
                                y = tmp_df[&#34;Ct&#34;],
                                name = name,
                                hoverinfo = &#34;y+name&#34;,
                                **kwargs,
                            ),
                        )
            
           
        fig.update_layout(
                            boxmode=&#34;group&#34;, 
                            template = template, 
                            title = title,
                        )

        if show:
            fig.show()

        return fig 


    def _static_plot(self, **kwargs):
        &#34;&#34;&#34;
        Generates a static Boxplot summary of the input Ct values
        &#34;&#34;&#34;

        data = self._data
        
        show = aux.from_kwargs(&#34;show&#34;, False, kwargs, rm = True)
        figsize = aux.from_kwargs(&#34;figsize&#34;, (7,5), kwargs, rm=True)
        title = aux.from_kwargs(&#34;title&#34;, None, kwargs, rm=True)
        show_spines = aux.from_kwargs(&#34;frame&#34;, True, kwargs, rm = True)
        ncols, nrows = aux.from_kwargs(&#34;subplots&#34;, gx.make_layout(data, &#34;assay&#34;), kwargs, rm=True)

        # future TODO: 
        # currently the inclusion-range is NOT yet represented.
        # It appears as if boxplot cannot use precomputed mean-sd when x and y are specified... (hypothesis of mine)
        # so we&#39;d need an alternative way of plotting this stuff so we can include it...
            
        # filter_stats = self._Filter.get_stats()

        # sns.set_style(&#34;whitegrid&#34;)

        fig, axs = plt.subplots(nrows = nrows, ncols = ncols, figsize=figsize)
        
        # possibly nrows and ncols should be switched...
        Coords = gx.AxesCoords(fig, axs, (nrows, ncols))
        
        for assay in aux.sorted_set(data[&#34;assay&#34;]):
            
            try: 
                ax = Coords.subplot()
            except: 
                print(&#34;We ran out of axes ... &#34;)
                break
            tmp = data.query(f&#34;assay == &#39;{assay}&#39;&#34;)

            sns.boxplot(
                        data=tmp, 
                        x = &#34;assay&#34;, y = &#34;Ct&#34;, hue=&#34;group_name&#34;, 
                        ax = ax, 
                        **kwargs
                    )

            ax.legend(bbox_to_anchor=(1,1), loc = None).remove()
            ax.set(title=assay, xlabel = &#34;&#34;, xticklabels = [],)
            
            if not show_spines:
                sns.despine()

            Coords.increment()

        # add one single legend to the last plot
        ax.legend(bbox_to_anchor=(1,1), loc = None)

        fig.suptitle(title)
        plt.tight_layout()

        if show:
            fig.show()

        return fig </code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="qpcr.Plotters.Plotter" href="#qpcr.Plotters.Plotter">Plotter</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="qpcr.Plotters.ReplicateBoxPlot.filter"><code class="name flex">
<span>def <span class="ident">filter</span></span>(<span>self, Filter)</span>
</code></dt>
<dd>
<div class="desc"><p>Links a Filter object for which a report figure shall be generated</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>Filter</code></strong> :&ensp;<code><a title="qpcr.Filters.Filter" href="Filters.html#qpcr.Filters.Filter">Filter</a></code></dt>
<dd>A qpcr.Filters.Filter object.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter(self, Filter):
    &#34;&#34;&#34;
    Links a Filter object for which a report figure shall be generated

    Parameters
    ----------
    Filter : qpcr.Filters.Filter
        A qpcr.Filters.Filter object.

    &#34;&#34;&#34;
    self._Filter = Filter</code></pre>
</details>
</dd>
<dt id="qpcr.Plotters.ReplicateBoxPlot.link"><code class="name flex">
<span>def <span class="ident">link</span></span>(<span>self, Assay: <a title="qpcr.Assay" href="index.html#qpcr.Assay">Assay</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Links an Assay object to the BoxPlotter.
This will simply add the Ct column to the current overall data!</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>Assay</code></strong> :&ensp;<code><a title="qpcr.Assay" href="index.html#qpcr.Assay">Assay</a></code></dt>
<dd>A qpcr.Assay object.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def link(self, Assay:qpcr.Assay):
    &#34;&#34;&#34;
    Links an Assay object to the BoxPlotter.
    This will simply add the Ct column to the current overall data!

    Parameters
    ----------
    Assay : qpcr.Assay
        A qpcr.Assay object.
    &#34;&#34;&#34;
    # somehow isinstance would not work...
    # future TODO: check out why isinstance didn&#39;t work here...
    example = qpcr.Assay()
    if type(Assay).__name__ == type(example).__name__:
        self._Results = Assay
        data = self._Results.get()
    else:
        wa.HardWarning(&#34;Plotter:unknown_data&#34;, obj = Assay)

    # add itentifier column
    data[&#34;assay&#34;] = [self._Results.id() for i in range(len(data))]

    if self._data is None: 
        self._data = data
    else:
        self._data = pd.concat([self._data, data], ignore_index=True)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="qpcr.Plotters.Plotter" href="#qpcr.Plotters.Plotter">Plotter</a></b></code>:
<ul class="hlist">
<li><code><a title="qpcr.Plotters.Plotter.get" href="#qpcr.Plotters.Plotter.get">get</a></code></li>
<li><code><a title="qpcr.Plotters.Plotter.id" href="#qpcr.Plotters.Plotter.id">id</a></code></li>
<li><code><a title="qpcr.Plotters.Plotter.params" href="#qpcr.Plotters.Plotter.params">params</a></code></li>
<li><code><a title="qpcr.Plotters.Plotter.plot" href="#qpcr.Plotters.Plotter.plot">plot</a></code></li>
<li><code><a title="qpcr.Plotters.Plotter.save" href="#qpcr.Plotters.Plotter.save">save</a></code></li>
<li><code><a title="qpcr.Plotters.Plotter.suffix" href="#qpcr.Plotters.Plotter.suffix">suffix</a></code></li>
<li><code><a title="qpcr.Plotters.Plotter.update_params" href="#qpcr.Plotters.Plotter.update_params">update_params</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<a href="https://github.com/NoahHenrikKleinschmidt/qpcr">
<img src="./qpcr_light.svg" width = "100%" >
</a>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="qpcr" href="index.html">qpcr</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="qpcr.Plotters.Plotter" href="#qpcr.Plotters.Plotter">Plotter</a></code></h4>
<ul class="two-column">
<li><code><a title="qpcr.Plotters.Plotter.get" href="#qpcr.Plotters.Plotter.get">get</a></code></li>
<li><code><a title="qpcr.Plotters.Plotter.id" href="#qpcr.Plotters.Plotter.id">id</a></code></li>
<li><code><a title="qpcr.Plotters.Plotter.link" href="#qpcr.Plotters.Plotter.link">link</a></code></li>
<li><code><a title="qpcr.Plotters.Plotter.params" href="#qpcr.Plotters.Plotter.params">params</a></code></li>
<li><code><a title="qpcr.Plotters.Plotter.plot" href="#qpcr.Plotters.Plotter.plot">plot</a></code></li>
<li><code><a title="qpcr.Plotters.Plotter.save" href="#qpcr.Plotters.Plotter.save">save</a></code></li>
<li><code><a title="qpcr.Plotters.Plotter.suffix" href="#qpcr.Plotters.Plotter.suffix">suffix</a></code></li>
<li><code><a title="qpcr.Plotters.Plotter.update_params" href="#qpcr.Plotters.Plotter.update_params">update_params</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="qpcr.Plotters.PreviewResults" href="#qpcr.Plotters.PreviewResults">PreviewResults</a></code></h4>
</li>
<li>
<h4><code><a title="qpcr.Plotters.ReplicateBoxPlot" href="#qpcr.Plotters.ReplicateBoxPlot">ReplicateBoxPlot</a></code></h4>
<ul class="">
<li><code><a title="qpcr.Plotters.ReplicateBoxPlot.filter" href="#qpcr.Plotters.ReplicateBoxPlot.filter">filter</a></code></li>
<li><code><a title="qpcr.Plotters.ReplicateBoxPlot.link" href="#qpcr.Plotters.ReplicateBoxPlot.link">link</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>